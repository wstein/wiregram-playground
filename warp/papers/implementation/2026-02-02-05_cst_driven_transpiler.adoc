= CST-Driven Crystal to Ruby Transpiler Architecture
:author: Warp Development
:date: 2026-02-02
:version: 1.0

== Overview

The Warp transpiler now uses a **Concrete Syntax Tree (CST) visitor pattern** instead of regex substitutions to transform Crystal code to Ruby. This provides:

- **Robustness**: No false positives in comments or strings
- **Accuracy**: Only transforms actual syntax nodes
- **Maintainability**: Clear separation of concerns (parse → transform → emit)

== Architecture

=== Phase 1: Lexing

Crystal source is lexed into tokens using `Warp::Lang::Crystal::Lexer.scan()`.

*Input:* Bytes
*Output:* `Array(Token)`, error code

*Trivia Preservation:* The lexer preserves whitespace, newlines, and comments as trivia.

=== Phase 2: Parsing (CST Construction)

Tokens are parsed into a Concrete Syntax Tree using `Warp::Lang::Crystal::CST::Parser.parse()`.

The CST represents the full source structure:

- `GreenNode`: Immutable AST node with kind, children, text, and trivia
- `RedNode`: Navigable view of GreenNode with parent pointers
- `MethodDefPayload`: Structured metadata for method definitions (name, params, return type, body)

*Key Property:* The CST preserves **all trivia** (comments, newlines) in `RawText` nodes.

=== Phase 3: Transformation (CST Visitor)

A visitor traverses the CST and transforms specific node types:

==== CrystalToRubyTransformer

The `CrystalToRubyTransformer` class uses the visitor pattern:

[source,crystal]
----
class CrystalToRubyTransformer
  def visit(node : CST::GreenNode) : String
    case node.kind
    when CST::NodeKind::Root
      visit_root(node)
    when CST::NodeKind::MethodDef
      visit_method_def(node)
    when CST::NodeKind::RawText
      visit_raw_text(node)
    # ... other node types
    else
      node.text || ""
    end
  end
end
----

==== Transformation Rules

===== RawText Nodes

Post-process bare `require` statements:

[source,crystal]
----
require "./foo"   →  require_relative "./foo"
require "../bar"  →  require_relative "../bar"
----

Normalize duplicate slashes:
[source]
----
require_relative ".//"  →  require_relative "./"
----

===== MethodDef Nodes

For methods with type annotations:

1. Extract method name, parameters, return type from `MethodDefPayload`
2. Generate Sorbet `sig { ... }` with translated types
3. Emit Ruby `def` line with untyped parameters

*Example:*

[source,crystal]
----
def add(x : Int32, y : Int32) : Int32
  x + y
end
----

Transforms to:

[source,ruby]
----
sig { params(x: Integer, y: Integer).returns(Integer) }
def add(x, y)
  x + y
end
----

===== MethodCall Nodes

Transform Crystal `&.` method shorthand to Ruby `&:` symbol shorthand:

[source,crystal]
----
items.map(&.to_s)  →  items.map(&:to_s)
----

==== Type Translation Table

Crystal types are mapped to Ruby/Sorbet types:

[cols="1,1"]
|===
| Crystal | Ruby/Sorbet

| `String` | `String`
| `Int32`, `Int64`, `Int` | `Integer`
| `Float32`, `Float64`, `Float` | `Float`
| `Bool` | `T::Boolean`
| `Array` | `Array`
| `Hash` | `Hash`
| `Nil`, `Void` | `NilClass`
| `String?` | `T.nilable(String)`
|===

=== Phase 4: Output

The transformed source is returned as a String.

*Post-processing:* The `RubySerializer` class normalizes require statements and ensures consistent formatting.

== Key Improvements Over Regex-Based Approach

[cols="2,2"]
|===
| Regex-Based | CST-Based

| Applied text substitutions globally | Only transforms actual syntax nodes
| Could corrupt code in comments/strings | Comments and strings never affected
| Fragile and error-prone | Robust and maintainable
| No understanding of syntax structure | Full semantic awareness
| Hard to debug and extend | Clear visitor pattern, easy to extend
|===

=== Example: Comment Safety

*Input:*
[source,crystal]
----
# Convert '&.method' to Ruby '&:method'
items.map(&.method_name)
----

*Regex-Based Result (BROKEN):*
The regex `&\.(\w+)` would match in the comment!

*CST-Based Result (CORRECT):*
Only the actual method call node is transformed. Comment is preserved as-is.

== Testing Strategy

Comprehensive unit tests cover:

1. **Require Transformation**
   - `require "./foo"` → `require_relative "./foo"`
   - Relative path handling (`../`, `./`)
   - No duplicate slashes

2. **Type Annotations**
   - Single and multiple typed parameters
   - Return type translation
   - Sorbet sig generation
   - Untyped methods (no sig)

3. **Edge Cases**
   - Nilable types (`String?` → `T.nilable(String)`)
   - Mixed typed and untyped parameters
   - Method calls with `&.` syntax

4. **Correctness**
   - Comments preserved
   - Newlines preserved
   - No false positives

== Future Extensions

=== Planned Transformations

1. **Type Conversion for Complex Types**
   - `Array(String)` → `Array[String]` or keep as-is
   - `Hash(String, Int32)` → `Hash[String, Integer]`
   - Custom class references

2. **Method Body Transformations**
   - `not_nil!` → safe navigation patterns
   - Crystal-specific syntax to idiomatic Ruby

3. **Macro Expansion**
   - Handle Crystal `macro` definitions
   - Expand common macro patterns

4. **Incremental Transformation**
   - Cache CST and only retransform changed nodes
   - Improve performance for large files

== Files Affected

- `src/warp/lang/crystal/crystal_to_ruby_transpiler.cr` — Main transpiler with CrystalToRubyTransformer class
- `spec/unit/crystal_to_ruby_transpiler_spec.cr` — Comprehensive unit tests
- `spec/integration/cli_spec.cr` — CLI integration tests
- `src/warp/lang/crystal/cst.cr` — CST data structures and parser
- `src/warp/lang/crystal/lexer.cr` — Crystal lexer for tokenization

== Performance Implications

- **CST construction:** ~5-10% overhead vs. raw text (due to token collection and tree building)
- **Transformation:** O(n) where n = number of nodes (linear pass over CST)
- **Memory:** CST stores original source bytes, so overhead is ~2-3x the source size
- **Benefit:** Correctness and maintainability outweigh small performance cost

== Conclusion

The CST-driven transpiler represents a significant architectural improvement from regex-based text substitution. By leveraging the full structure of the source language, we achieve correctness, clarity, and extensibility.

This approach aligns with industry best practices (LLVM, Rust Compiler, etc.) and provides a solid foundation for future language transformations and analysis.
