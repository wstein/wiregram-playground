# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def deconstruct(); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  def deconstruct(); end

  def fetch_values(*indexes, &block); end

  def place(*values); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

module Base64
  VERSION = ::T.let(nil, ::T.untyped)
end

class BasicObject
  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def _decimal_shift(arg); end

  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module BigDecimal::Internal
end

module BigDecimal::Internal
  def self.coerce_to_bigdecimal(x, prec, method_name); end

  def self.coerce_validate_prec(prec, method_name, accept_zero: T.unsafe(nil)); end

  def self.infinity_computation_result(); end

  def self.nan_computation_result(); end
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def clone(); end
end

module Builder
end

class Builder::IllegalBlockError
end

class Builder::IllegalBlockError
end

module Builder::XChar
  CP1252 = ::T.let(nil, ::T.untyped)
  CP1252_DIFFERENCES = ::T.let(nil, ::T.untyped)
  ENCODING_BINARY = ::T.let(nil, ::T.untyped)
  ENCODING_ISO1 = ::T.let(nil, ::T.untyped)
  ENCODING_UTF8 = ::T.let(nil, ::T.untyped)
  INVALID_XML_CHAR = ::T.let(nil, ::T.untyped)
  PREDEFINED = ::T.let(nil, ::T.untyped)
  REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
  UNICODE_EQUIVALENT = ::T.let(nil, ::T.untyped)
  VALID = ::T.let(nil, ::T.untyped)
  XML_PREDEFINED = ::T.let(nil, ::T.untyped)
end

module Builder::XChar
  def self.encode(string); end

  def self.unicode(string); end
end

class Builder::XmlBase
  def <<(text); end

  def explicit_nil_handling?(); end

  def initialize(indent=T.unsafe(nil), initial=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def method_missing(sym, *args, &block); end

  def nil?(); end

  def tag!(sym, *args, &block); end

  def text!(text); end
end

class Builder::XmlBase
  def self.cache_method_calls(); end

  def self.cache_method_calls=(cache_method_calls); end
end

class Builder::XmlEvents
end

class Builder::XmlEvents
end

class Builder::XmlMarkup
  def cdata!(text); end

  def cdata_value!(open, text); end

  def comment!(comment_text); end

  def declare!(inst, *args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def instruct!(directive_tag=T.unsafe(nil), attrs=T.unsafe(nil)); end

  def target!(); end
end

class Builder::XmlMarkup
end

module Builder
  def self.check_for_name_collision(klass, method_name, defined_constant=T.unsafe(nil)); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

module Bundler::BuildMetadata
  def self.timestamp(); end
end

module Bundler::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Bundler::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

class Bundler::CLI
  def add(*gems); end

  def binstubs(*gems); end

  def cache(); end

  def check(); end

  def clean(); end

  def cli_help(); end

  def config(*args); end

  def console(group=T.unsafe(nil)); end

  def doctor(*args); end

  def env(); end

  def exec(*args); end

  def fund(); end

  def gem(name); end

  def help(cli=T.unsafe(nil)); end

  def info(gem_name); end

  def init(); end

  def initialize(*args); end

  def inject(*arg); end

  def install(); end

  def install_or_cli_help(); end

  def issue(); end

  def licenses(); end

  def list(); end

  def lock(); end

  def open(name); end

  def outdated(*gems); end

  def platform(); end

  def plugin(*args); end

  def pristine(*gems); end

  def remove(*gems); end

  def show(gem_name=T.unsafe(nil)); end

  def update(*gems); end

  def version(); end

  def viz(); end
  AUTO_INSTALL_CMDS = ::T.let(nil, ::T.untyped)
  COMMAND_ALIASES = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  PARSEABLE_COMMANDS = ::T.let(nil, ::T.untyped)
end

module Bundler::CLI::Common
end

module Bundler::CLI::Common
  def self.ask_for_spec_from(specs); end

  def self.clean_after_install?(); end

  def self.configure_gem_version_promoter(definition, options); end

  def self.default_gem_spec(name); end

  def self.ensure_all_gems_in_lockfile!(names, locked_gems=T.unsafe(nil)); end

  def self.gem_not_found_message(missing_gem_name, alternatives); end

  def self.output_fund_metadata_summary(); end

  def self.output_post_install_messages(messages); end

  def self.output_without_groups_message(command); end

  def self.patch_level_options(options); end

  def self.print_post_install_message(name, msg); end

  def self.select_spec(name, regex_match=T.unsafe(nil)); end

  def self.verbalize_groups(groups); end

  def self.without_groups_message(command); end

  def self.word_list(words); end
end

class Bundler::CLI::Config
  def base(name=T.unsafe(nil), *value); end

  def get(name); end

  def list(); end

  def set(name, value, *value_); end

  def unset(name); end
end

class Bundler::CLI::Config::Base
  def confirm(name); end

  def confirm_all(); end

  def explicit_scope?(); end

  def initialize(options, name, value, thor); end

  def message(); end

  def name(); end

  def new_value(); end

  def options(); end

  def run(); end

  def scope(); end

  def show_pretty_values_for(setting); end

  def thor(); end

  def validate_scope!(); end

  def value(); end

  def warn_unused_scope(msg); end
end

class Bundler::CLI::Config::Base
end

class Bundler::CLI::Config
end

class Bundler::CLI::Doctor
  def diagnose(); end

  def ssl(); end
end

class Bundler::CLI::Doctor
end

class Bundler::CLI::Install
  def initialize(options); end

  def options(); end

  def run(); end
end

class Bundler::CLI::Install
end

class Bundler::CLI::Plugin
  def install(*plugins); end

  def list(); end

  def uninstall(*plugins); end
end

class Bundler::CLI::Plugin
end

class Bundler::CLI
  def self.aliases_for(command_name); end

  def self.all_aliases(); end

  def self.check_invalid_ext_option(arguments); end

  def self.dispatch(*arg); end

  def self.invalid_ext_value?(arguments); end

  def self.reformatted_help_args(args); end

  def self.source_root(); end

  def self.start(*arg); end
end

class Bundler::Checksum
  def ==(other); end

  def algo(); end

  def digest(); end

  def eql?(other); end

  def formatted_sources(); end

  def initialize(algo, digest, source); end

  def match?(other); end

  def merge!(other); end

  def removable?(); end

  def removal_instructions(); end

  def same_source?(other); end

  def sources(); end

  def to_lock(); end
  ALGO_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Bundler::Checksum::Source
  def ==(other); end

  def initialize(type, location); end

  def location(); end

  def removable?(); end

  def removal(); end

  def type(); end
end

class Bundler::Checksum::Source
end

class Bundler::Checksum::Store
  def empty?(spec); end

  def merge!(other); end

  def missing?(spec); end

  def register(spec, checksum); end

  def replace(spec, checksum); end

  def store(); end

  def to_lock(spec); end
end

class Bundler::Checksum::Store
end

class Bundler::Checksum
  def self.from_api(digest, source_uri, algo=T.unsafe(nil)); end

  def self.from_gem(io, pathname, algo=T.unsafe(nil)); end

  def self.from_gem_package(gem_package, algo=T.unsafe(nil)); end

  def self.from_lock(lock_checksum, lockfile_location); end

  def self.to_hexdigest(digest, algo=T.unsafe(nil)); end
end

class Bundler::ChecksumMismatchError
  def initialize(lock_name, existing, checksum); end

  def mismatch_resolution_instructions(); end
end

class Bundler::ChecksumMismatchError
end

class Bundler::CompactIndexClient
  def available?(); end

  def dependencies(names); end

  def info(name); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def latest_version(name); end

  def names(); end

  def reset!(); end

  def versions(); end
  DEBUG_MUTEX = ::T.let(nil, ::T.untyped)
  INFO_DEPS = ::T.let(nil, ::T.untyped)
  INFO_NAME = ::T.let(nil, ::T.untyped)
  INFO_PLATFORM = ::T.let(nil, ::T.untyped)
  INFO_REQS = ::T.let(nil, ::T.untyped)
  INFO_VERSION = ::T.let(nil, ::T.untyped)
  SUPPORTED_DIGESTS = ::T.let(nil, ::T.untyped)
end

class Bundler::CompactIndexClient::Cache
  def directory(); end

  def info(name, remote_checksum=T.unsafe(nil)); end

  def initialize(directory, fetcher=T.unsafe(nil)); end

  def names(); end

  def reset!(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Cache
end

class Bundler::CompactIndexClient::CacheFile
  def append(data); end

  def close(); end

  def commit(); end

  def commit!(); end

  def digests=(expected_digests); end

  def digests?(); end

  def initialize(original_path, &block); end

  def initialize_digests(keys=T.unsafe(nil)); end

  def open(write_mode=T.unsafe(nil), perm=T.unsafe(nil), &block); end

  def original_path(); end

  def path(); end

  def reset_digests(); end

  def size(); end

  def verify(); end

  def write(data); end
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::ClosedError
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
  def initialize(digests, expected_digests); end
end

class Bundler::CompactIndexClient::CacheFile::DigestMismatchError
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile::Error
end

class Bundler::CompactIndexClient::CacheFile
  def self.copy(path, &block); end

  def self.write(path, data, digests=T.unsafe(nil)); end
end

class Bundler::CompactIndexClient::Error
end

class Bundler::CompactIndexClient::Error
end

class Bundler::CompactIndexClient::Parser
  def available?(); end

  def info(name); end

  def initialize(compact_index); end

  def names(); end

  def versions(); end
end

class Bundler::CompactIndexClient::Parser
end

class Bundler::CompactIndexClient::Updater
  def initialize(fetcher); end

  def update(remote_path, local_path, etag_path); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
  def initialize(path, message); end
end

class Bundler::CompactIndexClient::Updater::MismatchedChecksumError
end

class Bundler::CompactIndexClient::Updater
end

class Bundler::CompactIndexClient
  def self.debug(); end
end

class Bundler::ConnectionPool
  def auto_reload_after_fork(); end

  def available(); end

  def checkin(force: T.unsafe(nil)); end

  def checkout(options=T.unsafe(nil)); end

  def discard_current_connection(&block); end

  def idle(); end

  def initialize(options=T.unsafe(nil), &block); end

  def reap(idle_seconds=T.unsafe(nil), &block); end

  def reload(&block); end

  def shutdown(&block); end

  def size(); end

  def then(options=T.unsafe(nil)); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def decrement_created(); end

  def empty?(); end

  def idle(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def reap(idle_seconds, &block); end

  def shutdown(reload: T.unsafe(nil), &block); end
end

class Bundler::ConnectionPool::TimedStack
end

class Bundler::ConnectionPool
  def self.after_fork(); end

  def self.wrap(options, &block); end
end

class Bundler::CorruptBundlerInstallError
  def initialize(loaded_spec); end

  def status_code(); end
end

class Bundler::CorruptBundlerInstallError
end

class Bundler::CurrentRuby
  def jruby_18_18?(); end

  def jruby_18_19?(); end

  def jruby_18_1?(); end

  def jruby_18_20?(); end

  def jruby_18_21?(); end

  def jruby_18_22?(); end

  def jruby_18_23?(); end

  def jruby_18_24?(); end

  def jruby_18_25?(); end

  def jruby_18_26?(); end

  def jruby_18_27?(); end

  def jruby_18_2?(); end

  def jruby_18_30?(); end

  def jruby_18_31?(); end

  def jruby_18_32?(); end

  def jruby_18_33?(); end

  def jruby_18_34?(); end

  def jruby_18_3?(); end

  def jruby_18_40?(); end

  def jruby_18_4?(); end

  def jruby_19_18?(); end

  def jruby_19_19?(); end

  def jruby_19_1?(); end

  def jruby_19_20?(); end

  def jruby_19_21?(); end

  def jruby_19_22?(); end

  def jruby_19_23?(); end

  def jruby_19_24?(); end

  def jruby_19_25?(); end

  def jruby_19_26?(); end

  def jruby_19_27?(); end

  def jruby_19_2?(); end

  def jruby_19_30?(); end

  def jruby_19_31?(); end

  def jruby_19_32?(); end

  def jruby_19_33?(); end

  def jruby_19_34?(); end

  def jruby_19_3?(); end

  def jruby_19_40?(); end

  def jruby_19_4?(); end

  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_34?(); end

  def jruby_3?(); end

  def jruby_40?(); end

  def jruby_4?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_34?(); end

  def maglev_3?(); end

  def maglev_40?(); end

  def maglev_4?(); end

  def mingw_18_18?(); end

  def mingw_18_19?(); end

  def mingw_18_1?(); end

  def mingw_18_20?(); end

  def mingw_18_21?(); end

  def mingw_18_22?(); end

  def mingw_18_23?(); end

  def mingw_18_24?(); end

  def mingw_18_25?(); end

  def mingw_18_26?(); end

  def mingw_18_27?(); end

  def mingw_18_2?(); end

  def mingw_18_30?(); end

  def mingw_18_31?(); end

  def mingw_18_32?(); end

  def mingw_18_33?(); end

  def mingw_18_34?(); end

  def mingw_18_3?(); end

  def mingw_18_40?(); end

  def mingw_18_4?(); end

  def mingw_19_18?(); end

  def mingw_19_19?(); end

  def mingw_19_1?(); end

  def mingw_19_20?(); end

  def mingw_19_21?(); end

  def mingw_19_22?(); end

  def mingw_19_23?(); end

  def mingw_19_24?(); end

  def mingw_19_25?(); end

  def mingw_19_26?(); end

  def mingw_19_27?(); end

  def mingw_19_2?(); end

  def mingw_19_30?(); end

  def mingw_19_31?(); end

  def mingw_19_32?(); end

  def mingw_19_33?(); end

  def mingw_19_34?(); end

  def mingw_19_3?(); end

  def mingw_19_40?(); end

  def mingw_19_4?(); end

  def mingw_20_18?(); end

  def mingw_20_19?(); end

  def mingw_20_1?(); end

  def mingw_20_20?(); end

  def mingw_20_21?(); end

  def mingw_20_22?(); end

  def mingw_20_23?(); end

  def mingw_20_24?(); end

  def mingw_20_25?(); end

  def mingw_20_26?(); end

  def mingw_20_27?(); end

  def mingw_20_2?(); end

  def mingw_20_30?(); end

  def mingw_20_31?(); end

  def mingw_20_32?(); end

  def mingw_20_33?(); end

  def mingw_20_34?(); end

  def mingw_20_3?(); end

  def mingw_20_40?(); end

  def mingw_20_4?(); end

  def mingw_21_18?(); end

  def mingw_21_19?(); end

  def mingw_21_1?(); end

  def mingw_21_20?(); end

  def mingw_21_21?(); end

  def mingw_21_22?(); end

  def mingw_21_23?(); end

  def mingw_21_24?(); end

  def mingw_21_25?(); end

  def mingw_21_26?(); end

  def mingw_21_27?(); end

  def mingw_21_2?(); end

  def mingw_21_30?(); end

  def mingw_21_31?(); end

  def mingw_21_32?(); end

  def mingw_21_33?(); end

  def mingw_21_34?(); end

  def mingw_21_3?(); end

  def mingw_21_40?(); end

  def mingw_21_4?(); end

  def mingw_22_18?(); end

  def mingw_22_19?(); end

  def mingw_22_1?(); end

  def mingw_22_20?(); end

  def mingw_22_21?(); end

  def mingw_22_22?(); end

  def mingw_22_23?(); end

  def mingw_22_24?(); end

  def mingw_22_25?(); end

  def mingw_22_26?(); end

  def mingw_22_27?(); end

  def mingw_22_2?(); end

  def mingw_22_30?(); end

  def mingw_22_31?(); end

  def mingw_22_32?(); end

  def mingw_22_33?(); end

  def mingw_22_34?(); end

  def mingw_22_3?(); end

  def mingw_22_40?(); end

  def mingw_22_4?(); end

  def mingw_23_18?(); end

  def mingw_23_19?(); end

  def mingw_23_1?(); end

  def mingw_23_20?(); end

  def mingw_23_21?(); end

  def mingw_23_22?(); end

  def mingw_23_23?(); end

  def mingw_23_24?(); end

  def mingw_23_25?(); end

  def mingw_23_26?(); end

  def mingw_23_27?(); end

  def mingw_23_2?(); end

  def mingw_23_30?(); end

  def mingw_23_31?(); end

  def mingw_23_32?(); end

  def mingw_23_33?(); end

  def mingw_23_34?(); end

  def mingw_23_3?(); end

  def mingw_23_40?(); end

  def mingw_23_4?(); end

  def mingw_24_18?(); end

  def mingw_24_19?(); end

  def mingw_24_1?(); end

  def mingw_24_20?(); end

  def mingw_24_21?(); end

  def mingw_24_22?(); end

  def mingw_24_23?(); end

  def mingw_24_24?(); end

  def mingw_24_25?(); end

  def mingw_24_26?(); end

  def mingw_24_27?(); end

  def mingw_24_2?(); end

  def mingw_24_30?(); end

  def mingw_24_31?(); end

  def mingw_24_32?(); end

  def mingw_24_33?(); end

  def mingw_24_34?(); end

  def mingw_24_3?(); end

  def mingw_24_40?(); end

  def mingw_24_4?(); end

  def mingw_25_18?(); end

  def mingw_25_19?(); end

  def mingw_25_1?(); end

  def mingw_25_20?(); end

  def mingw_25_21?(); end

  def mingw_25_22?(); end

  def mingw_25_23?(); end

  def mingw_25_24?(); end

  def mingw_25_25?(); end

  def mingw_25_26?(); end

  def mingw_25_27?(); end

  def mingw_25_2?(); end

  def mingw_25_30?(); end

  def mingw_25_31?(); end

  def mingw_25_32?(); end

  def mingw_25_33?(); end

  def mingw_25_34?(); end

  def mingw_25_3?(); end

  def mingw_25_40?(); end

  def mingw_25_4?(); end

  def mingw_26_18?(); end

  def mingw_26_19?(); end

  def mingw_26_1?(); end

  def mingw_26_20?(); end

  def mingw_26_21?(); end

  def mingw_26_22?(); end

  def mingw_26_23?(); end

  def mingw_26_24?(); end

  def mingw_26_25?(); end

  def mingw_26_26?(); end

  def mingw_26_27?(); end

  def mingw_26_2?(); end

  def mingw_26_30?(); end

  def mingw_26_31?(); end

  def mingw_26_32?(); end

  def mingw_26_33?(); end

  def mingw_26_34?(); end

  def mingw_26_3?(); end

  def mingw_26_40?(); end

  def mingw_26_4?(); end

  def mingw_27_18?(); end

  def mingw_27_19?(); end

  def mingw_27_1?(); end

  def mingw_27_20?(); end

  def mingw_27_21?(); end

  def mingw_27_22?(); end

  def mingw_27_23?(); end

  def mingw_27_24?(); end

  def mingw_27_25?(); end

  def mingw_27_26?(); end

  def mingw_27_27?(); end

  def mingw_27_2?(); end

  def mingw_27_30?(); end

  def mingw_27_31?(); end

  def mingw_27_32?(); end

  def mingw_27_33?(); end

  def mingw_27_34?(); end

  def mingw_27_3?(); end

  def mingw_27_40?(); end

  def mingw_27_4?(); end

  def mingw_30?(); end

  def mingw_30_18?(); end

  def mingw_30_19?(); end

  def mingw_30_1?(); end

  def mingw_30_20?(); end

  def mingw_30_21?(); end

  def mingw_30_22?(); end

  def mingw_30_23?(); end

  def mingw_30_24?(); end

  def mingw_30_25?(); end

  def mingw_30_26?(); end

  def mingw_30_27?(); end

  def mingw_30_2?(); end

  def mingw_30_30?(); end

  def mingw_30_31?(); end

  def mingw_30_32?(); end

  def mingw_30_33?(); end

  def mingw_30_34?(); end

  def mingw_30_3?(); end

  def mingw_30_40?(); end

  def mingw_30_4?(); end

  def mingw_31?(); end

  def mingw_31_18?(); end

  def mingw_31_19?(); end

  def mingw_31_1?(); end

  def mingw_31_20?(); end

  def mingw_31_21?(); end

  def mingw_31_22?(); end

  def mingw_31_23?(); end

  def mingw_31_24?(); end

  def mingw_31_25?(); end

  def mingw_31_26?(); end

  def mingw_31_27?(); end

  def mingw_31_2?(); end

  def mingw_31_30?(); end

  def mingw_31_31?(); end

  def mingw_31_32?(); end

  def mingw_31_33?(); end

  def mingw_31_34?(); end

  def mingw_31_3?(); end

  def mingw_31_40?(); end

  def mingw_31_4?(); end

  def mingw_32?(); end

  def mingw_32_18?(); end

  def mingw_32_19?(); end

  def mingw_32_1?(); end

  def mingw_32_20?(); end

  def mingw_32_21?(); end

  def mingw_32_22?(); end

  def mingw_32_23?(); end

  def mingw_32_24?(); end

  def mingw_32_25?(); end

  def mingw_32_26?(); end

  def mingw_32_27?(); end

  def mingw_32_2?(); end

  def mingw_32_30?(); end

  def mingw_32_31?(); end

  def mingw_32_32?(); end

  def mingw_32_33?(); end

  def mingw_32_34?(); end

  def mingw_32_3?(); end

  def mingw_32_40?(); end

  def mingw_32_4?(); end

  def mingw_33?(); end

  def mingw_33_18?(); end

  def mingw_33_19?(); end

  def mingw_33_1?(); end

  def mingw_33_20?(); end

  def mingw_33_21?(); end

  def mingw_33_22?(); end

  def mingw_33_23?(); end

  def mingw_33_24?(); end

  def mingw_33_25?(); end

  def mingw_33_26?(); end

  def mingw_33_27?(); end

  def mingw_33_2?(); end

  def mingw_33_30?(); end

  def mingw_33_31?(); end

  def mingw_33_32?(); end

  def mingw_33_33?(); end

  def mingw_33_34?(); end

  def mingw_33_3?(); end

  def mingw_33_40?(); end

  def mingw_33_4?(); end

  def mingw_34?(); end

  def mingw_34_18?(); end

  def mingw_34_19?(); end

  def mingw_34_1?(); end

  def mingw_34_20?(); end

  def mingw_34_21?(); end

  def mingw_34_22?(); end

  def mingw_34_23?(); end

  def mingw_34_24?(); end

  def mingw_34_25?(); end

  def mingw_34_26?(); end

  def mingw_34_27?(); end

  def mingw_34_2?(); end

  def mingw_34_30?(); end

  def mingw_34_31?(); end

  def mingw_34_32?(); end

  def mingw_34_33?(); end

  def mingw_34_34?(); end

  def mingw_34_3?(); end

  def mingw_34_40?(); end

  def mingw_34_4?(); end

  def mingw_3?(); end

  def mingw_40?(); end

  def mingw_40_18?(); end

  def mingw_40_19?(); end

  def mingw_40_1?(); end

  def mingw_40_20?(); end

  def mingw_40_21?(); end

  def mingw_40_22?(); end

  def mingw_40_23?(); end

  def mingw_40_24?(); end

  def mingw_40_25?(); end

  def mingw_40_26?(); end

  def mingw_40_27?(); end

  def mingw_40_2?(); end

  def mingw_40_30?(); end

  def mingw_40_31?(); end

  def mingw_40_32?(); end

  def mingw_40_33?(); end

  def mingw_40_34?(); end

  def mingw_40_3?(); end

  def mingw_40_40?(); end

  def mingw_40_4?(); end

  def mingw_4?(); end

  def mri_18_18?(); end

  def mri_18_19?(); end

  def mri_18_1?(); end

  def mri_18_20?(); end

  def mri_18_21?(); end

  def mri_18_22?(); end

  def mri_18_23?(); end

  def mri_18_24?(); end

  def mri_18_25?(); end

  def mri_18_26?(); end

  def mri_18_27?(); end

  def mri_18_2?(); end

  def mri_18_30?(); end

  def mri_18_31?(); end

  def mri_18_32?(); end

  def mri_18_33?(); end

  def mri_18_34?(); end

  def mri_18_3?(); end

  def mri_18_40?(); end

  def mri_18_4?(); end

  def mri_19_18?(); end

  def mri_19_19?(); end

  def mri_19_1?(); end

  def mri_19_20?(); end

  def mri_19_21?(); end

  def mri_19_22?(); end

  def mri_19_23?(); end

  def mri_19_24?(); end

  def mri_19_25?(); end

  def mri_19_26?(); end

  def mri_19_27?(); end

  def mri_19_2?(); end

  def mri_19_30?(); end

  def mri_19_31?(); end

  def mri_19_32?(); end

  def mri_19_33?(); end

  def mri_19_34?(); end

  def mri_19_3?(); end

  def mri_19_40?(); end

  def mri_19_4?(); end

  def mri_20_18?(); end

  def mri_20_19?(); end

  def mri_20_1?(); end

  def mri_20_20?(); end

  def mri_20_21?(); end

  def mri_20_22?(); end

  def mri_20_23?(); end

  def mri_20_24?(); end

  def mri_20_25?(); end

  def mri_20_26?(); end

  def mri_20_27?(); end

  def mri_20_2?(); end

  def mri_20_30?(); end

  def mri_20_31?(); end

  def mri_20_32?(); end

  def mri_20_33?(); end

  def mri_20_34?(); end

  def mri_20_3?(); end

  def mri_20_40?(); end

  def mri_20_4?(); end

  def mri_21_18?(); end

  def mri_21_19?(); end

  def mri_21_1?(); end

  def mri_21_20?(); end

  def mri_21_21?(); end

  def mri_21_22?(); end

  def mri_21_23?(); end

  def mri_21_24?(); end

  def mri_21_25?(); end

  def mri_21_26?(); end

  def mri_21_27?(); end

  def mri_21_2?(); end

  def mri_21_30?(); end

  def mri_21_31?(); end

  def mri_21_32?(); end

  def mri_21_33?(); end

  def mri_21_34?(); end

  def mri_21_3?(); end

  def mri_21_40?(); end

  def mri_21_4?(); end

  def mri_22_18?(); end

  def mri_22_19?(); end

  def mri_22_1?(); end

  def mri_22_20?(); end

  def mri_22_21?(); end

  def mri_22_22?(); end

  def mri_22_23?(); end

  def mri_22_24?(); end

  def mri_22_25?(); end

  def mri_22_26?(); end

  def mri_22_27?(); end

  def mri_22_2?(); end

  def mri_22_30?(); end

  def mri_22_31?(); end

  def mri_22_32?(); end

  def mri_22_33?(); end

  def mri_22_34?(); end

  def mri_22_3?(); end

  def mri_22_40?(); end

  def mri_22_4?(); end

  def mri_23_18?(); end

  def mri_23_19?(); end

  def mri_23_1?(); end

  def mri_23_20?(); end

  def mri_23_21?(); end

  def mri_23_22?(); end

  def mri_23_23?(); end

  def mri_23_24?(); end

  def mri_23_25?(); end

  def mri_23_26?(); end

  def mri_23_27?(); end

  def mri_23_2?(); end

  def mri_23_30?(); end

  def mri_23_31?(); end

  def mri_23_32?(); end

  def mri_23_33?(); end

  def mri_23_34?(); end

  def mri_23_3?(); end

  def mri_23_40?(); end

  def mri_23_4?(); end

  def mri_24_18?(); end

  def mri_24_19?(); end

  def mri_24_1?(); end

  def mri_24_20?(); end

  def mri_24_21?(); end

  def mri_24_22?(); end

  def mri_24_23?(); end

  def mri_24_24?(); end

  def mri_24_25?(); end

  def mri_24_26?(); end

  def mri_24_27?(); end

  def mri_24_2?(); end

  def mri_24_30?(); end

  def mri_24_31?(); end

  def mri_24_32?(); end

  def mri_24_33?(); end

  def mri_24_34?(); end

  def mri_24_3?(); end

  def mri_24_40?(); end

  def mri_24_4?(); end

  def mri_25_18?(); end

  def mri_25_19?(); end

  def mri_25_1?(); end

  def mri_25_20?(); end

  def mri_25_21?(); end

  def mri_25_22?(); end

  def mri_25_23?(); end

  def mri_25_24?(); end

  def mri_25_25?(); end

  def mri_25_26?(); end

  def mri_25_27?(); end

  def mri_25_2?(); end

  def mri_25_30?(); end

  def mri_25_31?(); end

  def mri_25_32?(); end

  def mri_25_33?(); end

  def mri_25_34?(); end

  def mri_25_3?(); end

  def mri_25_40?(); end

  def mri_25_4?(); end

  def mri_26_18?(); end

  def mri_26_19?(); end

  def mri_26_1?(); end

  def mri_26_20?(); end

  def mri_26_21?(); end

  def mri_26_22?(); end

  def mri_26_23?(); end

  def mri_26_24?(); end

  def mri_26_25?(); end

  def mri_26_26?(); end

  def mri_26_27?(); end

  def mri_26_2?(); end

  def mri_26_30?(); end

  def mri_26_31?(); end

  def mri_26_32?(); end

  def mri_26_33?(); end

  def mri_26_34?(); end

  def mri_26_3?(); end

  def mri_26_40?(); end

  def mri_26_4?(); end

  def mri_27_18?(); end

  def mri_27_19?(); end

  def mri_27_1?(); end

  def mri_27_20?(); end

  def mri_27_21?(); end

  def mri_27_22?(); end

  def mri_27_23?(); end

  def mri_27_24?(); end

  def mri_27_25?(); end

  def mri_27_26?(); end

  def mri_27_27?(); end

  def mri_27_2?(); end

  def mri_27_30?(); end

  def mri_27_31?(); end

  def mri_27_32?(); end

  def mri_27_33?(); end

  def mri_27_34?(); end

  def mri_27_3?(); end

  def mri_27_40?(); end

  def mri_27_4?(); end

  def mri_30?(); end

  def mri_30_18?(); end

  def mri_30_19?(); end

  def mri_30_1?(); end

  def mri_30_20?(); end

  def mri_30_21?(); end

  def mri_30_22?(); end

  def mri_30_23?(); end

  def mri_30_24?(); end

  def mri_30_25?(); end

  def mri_30_26?(); end

  def mri_30_27?(); end

  def mri_30_2?(); end

  def mri_30_30?(); end

  def mri_30_31?(); end

  def mri_30_32?(); end

  def mri_30_33?(); end

  def mri_30_34?(); end

  def mri_30_3?(); end

  def mri_30_40?(); end

  def mri_30_4?(); end

  def mri_31?(); end

  def mri_31_18?(); end

  def mri_31_19?(); end

  def mri_31_1?(); end

  def mri_31_20?(); end

  def mri_31_21?(); end

  def mri_31_22?(); end

  def mri_31_23?(); end

  def mri_31_24?(); end

  def mri_31_25?(); end

  def mri_31_26?(); end

  def mri_31_27?(); end

  def mri_31_2?(); end

  def mri_31_30?(); end

  def mri_31_31?(); end

  def mri_31_32?(); end

  def mri_31_33?(); end

  def mri_31_34?(); end

  def mri_31_3?(); end

  def mri_31_40?(); end

  def mri_31_4?(); end

  def mri_32?(); end

  def mri_32_18?(); end

  def mri_32_19?(); end

  def mri_32_1?(); end

  def mri_32_20?(); end

  def mri_32_21?(); end

  def mri_32_22?(); end

  def mri_32_23?(); end

  def mri_32_24?(); end

  def mri_32_25?(); end

  def mri_32_26?(); end

  def mri_32_27?(); end

  def mri_32_2?(); end

  def mri_32_30?(); end

  def mri_32_31?(); end

  def mri_32_32?(); end

  def mri_32_33?(); end

  def mri_32_34?(); end

  def mri_32_3?(); end

  def mri_32_40?(); end

  def mri_32_4?(); end

  def mri_33?(); end

  def mri_33_18?(); end

  def mri_33_19?(); end

  def mri_33_1?(); end

  def mri_33_20?(); end

  def mri_33_21?(); end

  def mri_33_22?(); end

  def mri_33_23?(); end

  def mri_33_24?(); end

  def mri_33_25?(); end

  def mri_33_26?(); end

  def mri_33_27?(); end

  def mri_33_2?(); end

  def mri_33_30?(); end

  def mri_33_31?(); end

  def mri_33_32?(); end

  def mri_33_33?(); end

  def mri_33_34?(); end

  def mri_33_3?(); end

  def mri_33_40?(); end

  def mri_33_4?(); end

  def mri_34?(); end

  def mri_34_18?(); end

  def mri_34_19?(); end

  def mri_34_1?(); end

  def mri_34_20?(); end

  def mri_34_21?(); end

  def mri_34_22?(); end

  def mri_34_23?(); end

  def mri_34_24?(); end

  def mri_34_25?(); end

  def mri_34_26?(); end

  def mri_34_27?(); end

  def mri_34_2?(); end

  def mri_34_30?(); end

  def mri_34_31?(); end

  def mri_34_32?(); end

  def mri_34_33?(); end

  def mri_34_34?(); end

  def mri_34_3?(); end

  def mri_34_40?(); end

  def mri_34_4?(); end

  def mri_3?(); end

  def mri_40?(); end

  def mri_40_18?(); end

  def mri_40_19?(); end

  def mri_40_1?(); end

  def mri_40_20?(); end

  def mri_40_21?(); end

  def mri_40_22?(); end

  def mri_40_23?(); end

  def mri_40_24?(); end

  def mri_40_25?(); end

  def mri_40_26?(); end

  def mri_40_27?(); end

  def mri_40_2?(); end

  def mri_40_30?(); end

  def mri_40_31?(); end

  def mri_40_32?(); end

  def mri_40_33?(); end

  def mri_40_34?(); end

  def mri_40_3?(); end

  def mri_40_40?(); end

  def mri_40_4?(); end

  def mri_4?(); end

  def mswin64_19_18?(); end

  def mswin64_19_19?(); end

  def mswin64_19_1?(); end

  def mswin64_19_20?(); end

  def mswin64_19_21?(); end

  def mswin64_19_22?(); end

  def mswin64_19_23?(); end

  def mswin64_19_24?(); end

  def mswin64_19_25?(); end

  def mswin64_19_26?(); end

  def mswin64_19_27?(); end

  def mswin64_19_2?(); end

  def mswin64_19_30?(); end

  def mswin64_19_31?(); end

  def mswin64_19_32?(); end

  def mswin64_19_33?(); end

  def mswin64_19_34?(); end

  def mswin64_19_3?(); end

  def mswin64_19_40?(); end

  def mswin64_19_4?(); end

  def mswin64_20_18?(); end

  def mswin64_20_19?(); end

  def mswin64_20_1?(); end

  def mswin64_20_20?(); end

  def mswin64_20_21?(); end

  def mswin64_20_22?(); end

  def mswin64_20_23?(); end

  def mswin64_20_24?(); end

  def mswin64_20_25?(); end

  def mswin64_20_26?(); end

  def mswin64_20_27?(); end

  def mswin64_20_2?(); end

  def mswin64_20_30?(); end

  def mswin64_20_31?(); end

  def mswin64_20_32?(); end

  def mswin64_20_33?(); end

  def mswin64_20_34?(); end

  def mswin64_20_3?(); end

  def mswin64_20_40?(); end

  def mswin64_20_4?(); end

  def mswin64_21_18?(); end

  def mswin64_21_19?(); end

  def mswin64_21_1?(); end

  def mswin64_21_20?(); end

  def mswin64_21_21?(); end

  def mswin64_21_22?(); end

  def mswin64_21_23?(); end

  def mswin64_21_24?(); end

  def mswin64_21_25?(); end

  def mswin64_21_26?(); end

  def mswin64_21_27?(); end

  def mswin64_21_2?(); end

  def mswin64_21_30?(); end

  def mswin64_21_31?(); end

  def mswin64_21_32?(); end

  def mswin64_21_33?(); end

  def mswin64_21_34?(); end

  def mswin64_21_3?(); end

  def mswin64_21_40?(); end

  def mswin64_21_4?(); end

  def mswin64_22_18?(); end

  def mswin64_22_19?(); end

  def mswin64_22_1?(); end

  def mswin64_22_20?(); end

  def mswin64_22_21?(); end

  def mswin64_22_22?(); end

  def mswin64_22_23?(); end

  def mswin64_22_24?(); end

  def mswin64_22_25?(); end

  def mswin64_22_26?(); end

  def mswin64_22_27?(); end

  def mswin64_22_2?(); end

  def mswin64_22_30?(); end

  def mswin64_22_31?(); end

  def mswin64_22_32?(); end

  def mswin64_22_33?(); end

  def mswin64_22_34?(); end

  def mswin64_22_3?(); end

  def mswin64_22_40?(); end

  def mswin64_22_4?(); end

  def mswin64_23_18?(); end

  def mswin64_23_19?(); end

  def mswin64_23_1?(); end

  def mswin64_23_20?(); end

  def mswin64_23_21?(); end

  def mswin64_23_22?(); end

  def mswin64_23_23?(); end

  def mswin64_23_24?(); end

  def mswin64_23_25?(); end

  def mswin64_23_26?(); end

  def mswin64_23_27?(); end

  def mswin64_23_2?(); end

  def mswin64_23_30?(); end

  def mswin64_23_31?(); end

  def mswin64_23_32?(); end

  def mswin64_23_33?(); end

  def mswin64_23_34?(); end

  def mswin64_23_3?(); end

  def mswin64_23_40?(); end

  def mswin64_23_4?(); end

  def mswin64_24_18?(); end

  def mswin64_24_19?(); end

  def mswin64_24_1?(); end

  def mswin64_24_20?(); end

  def mswin64_24_21?(); end

  def mswin64_24_22?(); end

  def mswin64_24_23?(); end

  def mswin64_24_24?(); end

  def mswin64_24_25?(); end

  def mswin64_24_26?(); end

  def mswin64_24_27?(); end

  def mswin64_24_2?(); end

  def mswin64_24_30?(); end

  def mswin64_24_31?(); end

  def mswin64_24_32?(); end

  def mswin64_24_33?(); end

  def mswin64_24_34?(); end

  def mswin64_24_3?(); end

  def mswin64_24_40?(); end

  def mswin64_24_4?(); end

  def mswin64_25_18?(); end

  def mswin64_25_19?(); end

  def mswin64_25_1?(); end

  def mswin64_25_20?(); end

  def mswin64_25_21?(); end

  def mswin64_25_22?(); end

  def mswin64_25_23?(); end

  def mswin64_25_24?(); end

  def mswin64_25_25?(); end

  def mswin64_25_26?(); end

  def mswin64_25_27?(); end

  def mswin64_25_2?(); end

  def mswin64_25_30?(); end

  def mswin64_25_31?(); end

  def mswin64_25_32?(); end

  def mswin64_25_33?(); end

  def mswin64_25_34?(); end

  def mswin64_25_3?(); end

  def mswin64_25_40?(); end

  def mswin64_25_4?(); end

  def mswin64_26_18?(); end

  def mswin64_26_19?(); end

  def mswin64_26_1?(); end

  def mswin64_26_20?(); end

  def mswin64_26_21?(); end

  def mswin64_26_22?(); end

  def mswin64_26_23?(); end

  def mswin64_26_24?(); end

  def mswin64_26_25?(); end

  def mswin64_26_26?(); end

  def mswin64_26_27?(); end

  def mswin64_26_2?(); end

  def mswin64_26_30?(); end

  def mswin64_26_31?(); end

  def mswin64_26_32?(); end

  def mswin64_26_33?(); end

  def mswin64_26_34?(); end

  def mswin64_26_3?(); end

  def mswin64_26_40?(); end

  def mswin64_26_4?(); end

  def mswin64_27_18?(); end

  def mswin64_27_19?(); end

  def mswin64_27_1?(); end

  def mswin64_27_20?(); end

  def mswin64_27_21?(); end

  def mswin64_27_22?(); end

  def mswin64_27_23?(); end

  def mswin64_27_24?(); end

  def mswin64_27_25?(); end

  def mswin64_27_26?(); end

  def mswin64_27_27?(); end

  def mswin64_27_2?(); end

  def mswin64_27_30?(); end

  def mswin64_27_31?(); end

  def mswin64_27_32?(); end

  def mswin64_27_33?(); end

  def mswin64_27_34?(); end

  def mswin64_27_3?(); end

  def mswin64_27_40?(); end

  def mswin64_27_4?(); end

  def mswin64_30?(); end

  def mswin64_30_18?(); end

  def mswin64_30_19?(); end

  def mswin64_30_1?(); end

  def mswin64_30_20?(); end

  def mswin64_30_21?(); end

  def mswin64_30_22?(); end

  def mswin64_30_23?(); end

  def mswin64_30_24?(); end

  def mswin64_30_25?(); end

  def mswin64_30_26?(); end

  def mswin64_30_27?(); end

  def mswin64_30_2?(); end

  def mswin64_30_30?(); end

  def mswin64_30_31?(); end

  def mswin64_30_32?(); end

  def mswin64_30_33?(); end

  def mswin64_30_34?(); end

  def mswin64_30_3?(); end

  def mswin64_30_40?(); end

  def mswin64_30_4?(); end

  def mswin64_31?(); end

  def mswin64_31_18?(); end

  def mswin64_31_19?(); end

  def mswin64_31_1?(); end

  def mswin64_31_20?(); end

  def mswin64_31_21?(); end

  def mswin64_31_22?(); end

  def mswin64_31_23?(); end

  def mswin64_31_24?(); end

  def mswin64_31_25?(); end

  def mswin64_31_26?(); end

  def mswin64_31_27?(); end

  def mswin64_31_2?(); end

  def mswin64_31_30?(); end

  def mswin64_31_31?(); end

  def mswin64_31_32?(); end

  def mswin64_31_33?(); end

  def mswin64_31_34?(); end

  def mswin64_31_3?(); end

  def mswin64_31_40?(); end

  def mswin64_31_4?(); end

  def mswin64_32?(); end

  def mswin64_32_18?(); end

  def mswin64_32_19?(); end

  def mswin64_32_1?(); end

  def mswin64_32_20?(); end

  def mswin64_32_21?(); end

  def mswin64_32_22?(); end

  def mswin64_32_23?(); end

  def mswin64_32_24?(); end

  def mswin64_32_25?(); end

  def mswin64_32_26?(); end

  def mswin64_32_27?(); end

  def mswin64_32_2?(); end

  def mswin64_32_30?(); end

  def mswin64_32_31?(); end

  def mswin64_32_32?(); end

  def mswin64_32_33?(); end

  def mswin64_32_34?(); end

  def mswin64_32_3?(); end

  def mswin64_32_40?(); end

  def mswin64_32_4?(); end

  def mswin64_33?(); end

  def mswin64_33_18?(); end

  def mswin64_33_19?(); end

  def mswin64_33_1?(); end

  def mswin64_33_20?(); end

  def mswin64_33_21?(); end

  def mswin64_33_22?(); end

  def mswin64_33_23?(); end

  def mswin64_33_24?(); end

  def mswin64_33_25?(); end

  def mswin64_33_26?(); end

  def mswin64_33_27?(); end

  def mswin64_33_2?(); end

  def mswin64_33_30?(); end

  def mswin64_33_31?(); end

  def mswin64_33_32?(); end

  def mswin64_33_33?(); end

  def mswin64_33_34?(); end

  def mswin64_33_3?(); end

  def mswin64_33_40?(); end

  def mswin64_33_4?(); end

  def mswin64_34?(); end

  def mswin64_34_18?(); end

  def mswin64_34_19?(); end

  def mswin64_34_1?(); end

  def mswin64_34_20?(); end

  def mswin64_34_21?(); end

  def mswin64_34_22?(); end

  def mswin64_34_23?(); end

  def mswin64_34_24?(); end

  def mswin64_34_25?(); end

  def mswin64_34_26?(); end

  def mswin64_34_27?(); end

  def mswin64_34_2?(); end

  def mswin64_34_30?(); end

  def mswin64_34_31?(); end

  def mswin64_34_32?(); end

  def mswin64_34_33?(); end

  def mswin64_34_34?(); end

  def mswin64_34_3?(); end

  def mswin64_34_40?(); end

  def mswin64_34_4?(); end

  def mswin64_3?(); end

  def mswin64_40?(); end

  def mswin64_40_18?(); end

  def mswin64_40_19?(); end

  def mswin64_40_1?(); end

  def mswin64_40_20?(); end

  def mswin64_40_21?(); end

  def mswin64_40_22?(); end

  def mswin64_40_23?(); end

  def mswin64_40_24?(); end

  def mswin64_40_25?(); end

  def mswin64_40_26?(); end

  def mswin64_40_27?(); end

  def mswin64_40_2?(); end

  def mswin64_40_30?(); end

  def mswin64_40_31?(); end

  def mswin64_40_32?(); end

  def mswin64_40_33?(); end

  def mswin64_40_34?(); end

  def mswin64_40_3?(); end

  def mswin64_40_40?(); end

  def mswin64_40_4?(); end

  def mswin64_4?(); end

  def mswin_18_18?(); end

  def mswin_18_19?(); end

  def mswin_18_1?(); end

  def mswin_18_20?(); end

  def mswin_18_21?(); end

  def mswin_18_22?(); end

  def mswin_18_23?(); end

  def mswin_18_24?(); end

  def mswin_18_25?(); end

  def mswin_18_26?(); end

  def mswin_18_27?(); end

  def mswin_18_2?(); end

  def mswin_18_30?(); end

  def mswin_18_31?(); end

  def mswin_18_32?(); end

  def mswin_18_33?(); end

  def mswin_18_34?(); end

  def mswin_18_3?(); end

  def mswin_18_40?(); end

  def mswin_18_4?(); end

  def mswin_19_18?(); end

  def mswin_19_19?(); end

  def mswin_19_1?(); end

  def mswin_19_20?(); end

  def mswin_19_21?(); end

  def mswin_19_22?(); end

  def mswin_19_23?(); end

  def mswin_19_24?(); end

  def mswin_19_25?(); end

  def mswin_19_26?(); end

  def mswin_19_27?(); end

  def mswin_19_2?(); end

  def mswin_19_30?(); end

  def mswin_19_31?(); end

  def mswin_19_32?(); end

  def mswin_19_33?(); end

  def mswin_19_34?(); end

  def mswin_19_3?(); end

  def mswin_19_40?(); end

  def mswin_19_4?(); end

  def mswin_20_18?(); end

  def mswin_20_19?(); end

  def mswin_20_1?(); end

  def mswin_20_20?(); end

  def mswin_20_21?(); end

  def mswin_20_22?(); end

  def mswin_20_23?(); end

  def mswin_20_24?(); end

  def mswin_20_25?(); end

  def mswin_20_26?(); end

  def mswin_20_27?(); end

  def mswin_20_2?(); end

  def mswin_20_30?(); end

  def mswin_20_31?(); end

  def mswin_20_32?(); end

  def mswin_20_33?(); end

  def mswin_20_34?(); end

  def mswin_20_3?(); end

  def mswin_20_40?(); end

  def mswin_20_4?(); end

  def mswin_21_18?(); end

  def mswin_21_19?(); end

  def mswin_21_1?(); end

  def mswin_21_20?(); end

  def mswin_21_21?(); end

  def mswin_21_22?(); end

  def mswin_21_23?(); end

  def mswin_21_24?(); end

  def mswin_21_25?(); end

  def mswin_21_26?(); end

  def mswin_21_27?(); end

  def mswin_21_2?(); end

  def mswin_21_30?(); end

  def mswin_21_31?(); end

  def mswin_21_32?(); end

  def mswin_21_33?(); end

  def mswin_21_34?(); end

  def mswin_21_3?(); end

  def mswin_21_40?(); end

  def mswin_21_4?(); end

  def mswin_22_18?(); end

  def mswin_22_19?(); end

  def mswin_22_1?(); end

  def mswin_22_20?(); end

  def mswin_22_21?(); end

  def mswin_22_22?(); end

  def mswin_22_23?(); end

  def mswin_22_24?(); end

  def mswin_22_25?(); end

  def mswin_22_26?(); end

  def mswin_22_27?(); end

  def mswin_22_2?(); end

  def mswin_22_30?(); end

  def mswin_22_31?(); end

  def mswin_22_32?(); end

  def mswin_22_33?(); end

  def mswin_22_34?(); end

  def mswin_22_3?(); end

  def mswin_22_40?(); end

  def mswin_22_4?(); end

  def mswin_23_18?(); end

  def mswin_23_19?(); end

  def mswin_23_1?(); end

  def mswin_23_20?(); end

  def mswin_23_21?(); end

  def mswin_23_22?(); end

  def mswin_23_23?(); end

  def mswin_23_24?(); end

  def mswin_23_25?(); end

  def mswin_23_26?(); end

  def mswin_23_27?(); end

  def mswin_23_2?(); end

  def mswin_23_30?(); end

  def mswin_23_31?(); end

  def mswin_23_32?(); end

  def mswin_23_33?(); end

  def mswin_23_34?(); end

  def mswin_23_3?(); end

  def mswin_23_40?(); end

  def mswin_23_4?(); end

  def mswin_24_18?(); end

  def mswin_24_19?(); end

  def mswin_24_1?(); end

  def mswin_24_20?(); end

  def mswin_24_21?(); end

  def mswin_24_22?(); end

  def mswin_24_23?(); end

  def mswin_24_24?(); end

  def mswin_24_25?(); end

  def mswin_24_26?(); end

  def mswin_24_27?(); end

  def mswin_24_2?(); end

  def mswin_24_30?(); end

  def mswin_24_31?(); end

  def mswin_24_32?(); end

  def mswin_24_33?(); end

  def mswin_24_34?(); end

  def mswin_24_3?(); end

  def mswin_24_40?(); end

  def mswin_24_4?(); end

  def mswin_25_18?(); end

  def mswin_25_19?(); end

  def mswin_25_1?(); end

  def mswin_25_20?(); end

  def mswin_25_21?(); end

  def mswin_25_22?(); end

  def mswin_25_23?(); end

  def mswin_25_24?(); end

  def mswin_25_25?(); end

  def mswin_25_26?(); end

  def mswin_25_27?(); end

  def mswin_25_2?(); end

  def mswin_25_30?(); end

  def mswin_25_31?(); end

  def mswin_25_32?(); end

  def mswin_25_33?(); end

  def mswin_25_34?(); end

  def mswin_25_3?(); end

  def mswin_25_40?(); end

  def mswin_25_4?(); end

  def mswin_26_18?(); end

  def mswin_26_19?(); end

  def mswin_26_1?(); end

  def mswin_26_20?(); end

  def mswin_26_21?(); end

  def mswin_26_22?(); end

  def mswin_26_23?(); end

  def mswin_26_24?(); end

  def mswin_26_25?(); end

  def mswin_26_26?(); end

  def mswin_26_27?(); end

  def mswin_26_2?(); end

  def mswin_26_30?(); end

  def mswin_26_31?(); end

  def mswin_26_32?(); end

  def mswin_26_33?(); end

  def mswin_26_34?(); end

  def mswin_26_3?(); end

  def mswin_26_40?(); end

  def mswin_26_4?(); end

  def mswin_27_18?(); end

  def mswin_27_19?(); end

  def mswin_27_1?(); end

  def mswin_27_20?(); end

  def mswin_27_21?(); end

  def mswin_27_22?(); end

  def mswin_27_23?(); end

  def mswin_27_24?(); end

  def mswin_27_25?(); end

  def mswin_27_26?(); end

  def mswin_27_27?(); end

  def mswin_27_2?(); end

  def mswin_27_30?(); end

  def mswin_27_31?(); end

  def mswin_27_32?(); end

  def mswin_27_33?(); end

  def mswin_27_34?(); end

  def mswin_27_3?(); end

  def mswin_27_40?(); end

  def mswin_27_4?(); end

  def mswin_30?(); end

  def mswin_30_18?(); end

  def mswin_30_19?(); end

  def mswin_30_1?(); end

  def mswin_30_20?(); end

  def mswin_30_21?(); end

  def mswin_30_22?(); end

  def mswin_30_23?(); end

  def mswin_30_24?(); end

  def mswin_30_25?(); end

  def mswin_30_26?(); end

  def mswin_30_27?(); end

  def mswin_30_2?(); end

  def mswin_30_30?(); end

  def mswin_30_31?(); end

  def mswin_30_32?(); end

  def mswin_30_33?(); end

  def mswin_30_34?(); end

  def mswin_30_3?(); end

  def mswin_30_40?(); end

  def mswin_30_4?(); end

  def mswin_31?(); end

  def mswin_31_18?(); end

  def mswin_31_19?(); end

  def mswin_31_1?(); end

  def mswin_31_20?(); end

  def mswin_31_21?(); end

  def mswin_31_22?(); end

  def mswin_31_23?(); end

  def mswin_31_24?(); end

  def mswin_31_25?(); end

  def mswin_31_26?(); end

  def mswin_31_27?(); end

  def mswin_31_2?(); end

  def mswin_31_30?(); end

  def mswin_31_31?(); end

  def mswin_31_32?(); end

  def mswin_31_33?(); end

  def mswin_31_34?(); end

  def mswin_31_3?(); end

  def mswin_31_40?(); end

  def mswin_31_4?(); end

  def mswin_32?(); end

  def mswin_32_18?(); end

  def mswin_32_19?(); end

  def mswin_32_1?(); end

  def mswin_32_20?(); end

  def mswin_32_21?(); end

  def mswin_32_22?(); end

  def mswin_32_23?(); end

  def mswin_32_24?(); end

  def mswin_32_25?(); end

  def mswin_32_26?(); end

  def mswin_32_27?(); end

  def mswin_32_2?(); end

  def mswin_32_30?(); end

  def mswin_32_31?(); end

  def mswin_32_32?(); end

  def mswin_32_33?(); end

  def mswin_32_34?(); end

  def mswin_32_3?(); end

  def mswin_32_40?(); end

  def mswin_32_4?(); end

  def mswin_33?(); end

  def mswin_33_18?(); end

  def mswin_33_19?(); end

  def mswin_33_1?(); end

  def mswin_33_20?(); end

  def mswin_33_21?(); end

  def mswin_33_22?(); end

  def mswin_33_23?(); end

  def mswin_33_24?(); end

  def mswin_33_25?(); end

  def mswin_33_26?(); end

  def mswin_33_27?(); end

  def mswin_33_2?(); end

  def mswin_33_30?(); end

  def mswin_33_31?(); end

  def mswin_33_32?(); end

  def mswin_33_33?(); end

  def mswin_33_34?(); end

  def mswin_33_3?(); end

  def mswin_33_40?(); end

  def mswin_33_4?(); end

  def mswin_34?(); end

  def mswin_34_18?(); end

  def mswin_34_19?(); end

  def mswin_34_1?(); end

  def mswin_34_20?(); end

  def mswin_34_21?(); end

  def mswin_34_22?(); end

  def mswin_34_23?(); end

  def mswin_34_24?(); end

  def mswin_34_25?(); end

  def mswin_34_26?(); end

  def mswin_34_27?(); end

  def mswin_34_2?(); end

  def mswin_34_30?(); end

  def mswin_34_31?(); end

  def mswin_34_32?(); end

  def mswin_34_33?(); end

  def mswin_34_34?(); end

  def mswin_34_3?(); end

  def mswin_34_40?(); end

  def mswin_34_4?(); end

  def mswin_3?(); end

  def mswin_40?(); end

  def mswin_40_18?(); end

  def mswin_40_19?(); end

  def mswin_40_1?(); end

  def mswin_40_20?(); end

  def mswin_40_21?(); end

  def mswin_40_22?(); end

  def mswin_40_23?(); end

  def mswin_40_24?(); end

  def mswin_40_25?(); end

  def mswin_40_26?(); end

  def mswin_40_27?(); end

  def mswin_40_2?(); end

  def mswin_40_30?(); end

  def mswin_40_31?(); end

  def mswin_40_32?(); end

  def mswin_40_33?(); end

  def mswin_40_34?(); end

  def mswin_40_3?(); end

  def mswin_40_40?(); end

  def mswin_40_4?(); end

  def mswin_4?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_34?(); end

  def on_3?(); end

  def on_40?(); end

  def on_4?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_34?(); end

  def rbx_3?(); end

  def rbx_40?(); end

  def rbx_4?(); end

  def ruby_18_18?(); end

  def ruby_18_19?(); end

  def ruby_18_1?(); end

  def ruby_18_20?(); end

  def ruby_18_21?(); end

  def ruby_18_22?(); end

  def ruby_18_23?(); end

  def ruby_18_24?(); end

  def ruby_18_25?(); end

  def ruby_18_26?(); end

  def ruby_18_27?(); end

  def ruby_18_2?(); end

  def ruby_18_30?(); end

  def ruby_18_31?(); end

  def ruby_18_32?(); end

  def ruby_18_33?(); end

  def ruby_18_34?(); end

  def ruby_18_3?(); end

  def ruby_18_40?(); end

  def ruby_18_4?(); end

  def ruby_19_18?(); end

  def ruby_19_19?(); end

  def ruby_19_1?(); end

  def ruby_19_20?(); end

  def ruby_19_21?(); end

  def ruby_19_22?(); end

  def ruby_19_23?(); end

  def ruby_19_24?(); end

  def ruby_19_25?(); end

  def ruby_19_26?(); end

  def ruby_19_27?(); end

  def ruby_19_2?(); end

  def ruby_19_30?(); end

  def ruby_19_31?(); end

  def ruby_19_32?(); end

  def ruby_19_33?(); end

  def ruby_19_34?(); end

  def ruby_19_3?(); end

  def ruby_19_40?(); end

  def ruby_19_4?(); end

  def ruby_20_18?(); end

  def ruby_20_19?(); end

  def ruby_20_1?(); end

  def ruby_20_20?(); end

  def ruby_20_21?(); end

  def ruby_20_22?(); end

  def ruby_20_23?(); end

  def ruby_20_24?(); end

  def ruby_20_25?(); end

  def ruby_20_26?(); end

  def ruby_20_27?(); end

  def ruby_20_2?(); end

  def ruby_20_30?(); end

  def ruby_20_31?(); end

  def ruby_20_32?(); end

  def ruby_20_33?(); end

  def ruby_20_34?(); end

  def ruby_20_3?(); end

  def ruby_20_40?(); end

  def ruby_20_4?(); end

  def ruby_21_18?(); end

  def ruby_21_19?(); end

  def ruby_21_1?(); end

  def ruby_21_20?(); end

  def ruby_21_21?(); end

  def ruby_21_22?(); end

  def ruby_21_23?(); end

  def ruby_21_24?(); end

  def ruby_21_25?(); end

  def ruby_21_26?(); end

  def ruby_21_27?(); end

  def ruby_21_2?(); end

  def ruby_21_30?(); end

  def ruby_21_31?(); end

  def ruby_21_32?(); end

  def ruby_21_33?(); end

  def ruby_21_34?(); end

  def ruby_21_3?(); end

  def ruby_21_40?(); end

  def ruby_21_4?(); end

  def ruby_22_18?(); end

  def ruby_22_19?(); end

  def ruby_22_1?(); end

  def ruby_22_20?(); end

  def ruby_22_21?(); end

  def ruby_22_22?(); end

  def ruby_22_23?(); end

  def ruby_22_24?(); end

  def ruby_22_25?(); end

  def ruby_22_26?(); end

  def ruby_22_27?(); end

  def ruby_22_2?(); end

  def ruby_22_30?(); end

  def ruby_22_31?(); end

  def ruby_22_32?(); end

  def ruby_22_33?(); end

  def ruby_22_34?(); end

  def ruby_22_3?(); end

  def ruby_22_40?(); end

  def ruby_22_4?(); end

  def ruby_23_18?(); end

  def ruby_23_19?(); end

  def ruby_23_1?(); end

  def ruby_23_20?(); end

  def ruby_23_21?(); end

  def ruby_23_22?(); end

  def ruby_23_23?(); end

  def ruby_23_24?(); end

  def ruby_23_25?(); end

  def ruby_23_26?(); end

  def ruby_23_27?(); end

  def ruby_23_2?(); end

  def ruby_23_30?(); end

  def ruby_23_31?(); end

  def ruby_23_32?(); end

  def ruby_23_33?(); end

  def ruby_23_34?(); end

  def ruby_23_3?(); end

  def ruby_23_40?(); end

  def ruby_23_4?(); end

  def ruby_24_18?(); end

  def ruby_24_19?(); end

  def ruby_24_1?(); end

  def ruby_24_20?(); end

  def ruby_24_21?(); end

  def ruby_24_22?(); end

  def ruby_24_23?(); end

  def ruby_24_24?(); end

  def ruby_24_25?(); end

  def ruby_24_26?(); end

  def ruby_24_27?(); end

  def ruby_24_2?(); end

  def ruby_24_30?(); end

  def ruby_24_31?(); end

  def ruby_24_32?(); end

  def ruby_24_33?(); end

  def ruby_24_34?(); end

  def ruby_24_3?(); end

  def ruby_24_40?(); end

  def ruby_24_4?(); end

  def ruby_25_18?(); end

  def ruby_25_19?(); end

  def ruby_25_1?(); end

  def ruby_25_20?(); end

  def ruby_25_21?(); end

  def ruby_25_22?(); end

  def ruby_25_23?(); end

  def ruby_25_24?(); end

  def ruby_25_25?(); end

  def ruby_25_26?(); end

  def ruby_25_27?(); end

  def ruby_25_2?(); end

  def ruby_25_30?(); end

  def ruby_25_31?(); end

  def ruby_25_32?(); end

  def ruby_25_33?(); end

  def ruby_25_34?(); end

  def ruby_25_3?(); end

  def ruby_25_40?(); end

  def ruby_25_4?(); end

  def ruby_26_18?(); end

  def ruby_26_19?(); end

  def ruby_26_1?(); end

  def ruby_26_20?(); end

  def ruby_26_21?(); end

  def ruby_26_22?(); end

  def ruby_26_23?(); end

  def ruby_26_24?(); end

  def ruby_26_25?(); end

  def ruby_26_26?(); end

  def ruby_26_27?(); end

  def ruby_26_2?(); end

  def ruby_26_30?(); end

  def ruby_26_31?(); end

  def ruby_26_32?(); end

  def ruby_26_33?(); end

  def ruby_26_34?(); end

  def ruby_26_3?(); end

  def ruby_26_40?(); end

  def ruby_26_4?(); end

  def ruby_27_18?(); end

  def ruby_27_19?(); end

  def ruby_27_1?(); end

  def ruby_27_20?(); end

  def ruby_27_21?(); end

  def ruby_27_22?(); end

  def ruby_27_23?(); end

  def ruby_27_24?(); end

  def ruby_27_25?(); end

  def ruby_27_26?(); end

  def ruby_27_27?(); end

  def ruby_27_2?(); end

  def ruby_27_30?(); end

  def ruby_27_31?(); end

  def ruby_27_32?(); end

  def ruby_27_33?(); end

  def ruby_27_34?(); end

  def ruby_27_3?(); end

  def ruby_27_40?(); end

  def ruby_27_4?(); end

  def ruby_30?(); end

  def ruby_30_18?(); end

  def ruby_30_19?(); end

  def ruby_30_1?(); end

  def ruby_30_20?(); end

  def ruby_30_21?(); end

  def ruby_30_22?(); end

  def ruby_30_23?(); end

  def ruby_30_24?(); end

  def ruby_30_25?(); end

  def ruby_30_26?(); end

  def ruby_30_27?(); end

  def ruby_30_2?(); end

  def ruby_30_30?(); end

  def ruby_30_31?(); end

  def ruby_30_32?(); end

  def ruby_30_33?(); end

  def ruby_30_34?(); end

  def ruby_30_3?(); end

  def ruby_30_40?(); end

  def ruby_30_4?(); end

  def ruby_31?(); end

  def ruby_31_18?(); end

  def ruby_31_19?(); end

  def ruby_31_1?(); end

  def ruby_31_20?(); end

  def ruby_31_21?(); end

  def ruby_31_22?(); end

  def ruby_31_23?(); end

  def ruby_31_24?(); end

  def ruby_31_25?(); end

  def ruby_31_26?(); end

  def ruby_31_27?(); end

  def ruby_31_2?(); end

  def ruby_31_30?(); end

  def ruby_31_31?(); end

  def ruby_31_32?(); end

  def ruby_31_33?(); end

  def ruby_31_34?(); end

  def ruby_31_3?(); end

  def ruby_31_40?(); end

  def ruby_31_4?(); end

  def ruby_32?(); end

  def ruby_32_18?(); end

  def ruby_32_19?(); end

  def ruby_32_1?(); end

  def ruby_32_20?(); end

  def ruby_32_21?(); end

  def ruby_32_22?(); end

  def ruby_32_23?(); end

  def ruby_32_24?(); end

  def ruby_32_25?(); end

  def ruby_32_26?(); end

  def ruby_32_27?(); end

  def ruby_32_2?(); end

  def ruby_32_30?(); end

  def ruby_32_31?(); end

  def ruby_32_32?(); end

  def ruby_32_33?(); end

  def ruby_32_34?(); end

  def ruby_32_3?(); end

  def ruby_32_40?(); end

  def ruby_32_4?(); end

  def ruby_33?(); end

  def ruby_33_18?(); end

  def ruby_33_19?(); end

  def ruby_33_1?(); end

  def ruby_33_20?(); end

  def ruby_33_21?(); end

  def ruby_33_22?(); end

  def ruby_33_23?(); end

  def ruby_33_24?(); end

  def ruby_33_25?(); end

  def ruby_33_26?(); end

  def ruby_33_27?(); end

  def ruby_33_2?(); end

  def ruby_33_30?(); end

  def ruby_33_31?(); end

  def ruby_33_32?(); end

  def ruby_33_33?(); end

  def ruby_33_34?(); end

  def ruby_33_3?(); end

  def ruby_33_40?(); end

  def ruby_33_4?(); end

  def ruby_34?(); end

  def ruby_34_18?(); end

  def ruby_34_19?(); end

  def ruby_34_1?(); end

  def ruby_34_20?(); end

  def ruby_34_21?(); end

  def ruby_34_22?(); end

  def ruby_34_23?(); end

  def ruby_34_24?(); end

  def ruby_34_25?(); end

  def ruby_34_26?(); end

  def ruby_34_27?(); end

  def ruby_34_2?(); end

  def ruby_34_30?(); end

  def ruby_34_31?(); end

  def ruby_34_32?(); end

  def ruby_34_33?(); end

  def ruby_34_34?(); end

  def ruby_34_3?(); end

  def ruby_34_40?(); end

  def ruby_34_4?(); end

  def ruby_3?(); end

  def ruby_40?(); end

  def ruby_40_18?(); end

  def ruby_40_19?(); end

  def ruby_40_1?(); end

  def ruby_40_20?(); end

  def ruby_40_21?(); end

  def ruby_40_22?(); end

  def ruby_40_23?(); end

  def ruby_40_24?(); end

  def ruby_40_25?(); end

  def ruby_40_26?(); end

  def ruby_40_27?(); end

  def ruby_40_2?(); end

  def ruby_40_30?(); end

  def ruby_40_31?(); end

  def ruby_40_32?(); end

  def ruby_40_33?(); end

  def ruby_40_34?(); end

  def ruby_40_3?(); end

  def ruby_40_40?(); end

  def ruby_40_4?(); end

  def ruby_4?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_34?(); end

  def truffleruby_3?(); end

  def truffleruby_40?(); end

  def truffleruby_4?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_18_18?(); end

  def windows_18_19?(); end

  def windows_18_1?(); end

  def windows_18_20?(); end

  def windows_18_21?(); end

  def windows_18_22?(); end

  def windows_18_23?(); end

  def windows_18_24?(); end

  def windows_18_25?(); end

  def windows_18_26?(); end

  def windows_18_27?(); end

  def windows_18_2?(); end

  def windows_18_30?(); end

  def windows_18_31?(); end

  def windows_18_32?(); end

  def windows_18_33?(); end

  def windows_18_34?(); end

  def windows_18_3?(); end

  def windows_18_40?(); end

  def windows_18_4?(); end

  def windows_19?(); end

  def windows_19_18?(); end

  def windows_19_19?(); end

  def windows_19_1?(); end

  def windows_19_20?(); end

  def windows_19_21?(); end

  def windows_19_22?(); end

  def windows_19_23?(); end

  def windows_19_24?(); end

  def windows_19_25?(); end

  def windows_19_26?(); end

  def windows_19_27?(); end

  def windows_19_2?(); end

  def windows_19_30?(); end

  def windows_19_31?(); end

  def windows_19_32?(); end

  def windows_19_33?(); end

  def windows_19_34?(); end

  def windows_19_3?(); end

  def windows_19_40?(); end

  def windows_19_4?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_20_18?(); end

  def windows_20_19?(); end

  def windows_20_1?(); end

  def windows_20_20?(); end

  def windows_20_21?(); end

  def windows_20_22?(); end

  def windows_20_23?(); end

  def windows_20_24?(); end

  def windows_20_25?(); end

  def windows_20_26?(); end

  def windows_20_27?(); end

  def windows_20_2?(); end

  def windows_20_30?(); end

  def windows_20_31?(); end

  def windows_20_32?(); end

  def windows_20_33?(); end

  def windows_20_34?(); end

  def windows_20_3?(); end

  def windows_20_40?(); end

  def windows_20_4?(); end

  def windows_21?(); end

  def windows_21_18?(); end

  def windows_21_19?(); end

  def windows_21_1?(); end

  def windows_21_20?(); end

  def windows_21_21?(); end

  def windows_21_22?(); end

  def windows_21_23?(); end

  def windows_21_24?(); end

  def windows_21_25?(); end

  def windows_21_26?(); end

  def windows_21_27?(); end

  def windows_21_2?(); end

  def windows_21_30?(); end

  def windows_21_31?(); end

  def windows_21_32?(); end

  def windows_21_33?(); end

  def windows_21_34?(); end

  def windows_21_3?(); end

  def windows_21_40?(); end

  def windows_21_4?(); end

  def windows_22?(); end

  def windows_22_18?(); end

  def windows_22_19?(); end

  def windows_22_1?(); end

  def windows_22_20?(); end

  def windows_22_21?(); end

  def windows_22_22?(); end

  def windows_22_23?(); end

  def windows_22_24?(); end

  def windows_22_25?(); end

  def windows_22_26?(); end

  def windows_22_27?(); end

  def windows_22_2?(); end

  def windows_22_30?(); end

  def windows_22_31?(); end

  def windows_22_32?(); end

  def windows_22_33?(); end

  def windows_22_34?(); end

  def windows_22_3?(); end

  def windows_22_40?(); end

  def windows_22_4?(); end

  def windows_23?(); end

  def windows_23_18?(); end

  def windows_23_19?(); end

  def windows_23_1?(); end

  def windows_23_20?(); end

  def windows_23_21?(); end

  def windows_23_22?(); end

  def windows_23_23?(); end

  def windows_23_24?(); end

  def windows_23_25?(); end

  def windows_23_26?(); end

  def windows_23_27?(); end

  def windows_23_2?(); end

  def windows_23_30?(); end

  def windows_23_31?(); end

  def windows_23_32?(); end

  def windows_23_33?(); end

  def windows_23_34?(); end

  def windows_23_3?(); end

  def windows_23_40?(); end

  def windows_23_4?(); end

  def windows_24?(); end

  def windows_24_18?(); end

  def windows_24_19?(); end

  def windows_24_1?(); end

  def windows_24_20?(); end

  def windows_24_21?(); end

  def windows_24_22?(); end

  def windows_24_23?(); end

  def windows_24_24?(); end

  def windows_24_25?(); end

  def windows_24_26?(); end

  def windows_24_27?(); end

  def windows_24_2?(); end

  def windows_24_30?(); end

  def windows_24_31?(); end

  def windows_24_32?(); end

  def windows_24_33?(); end

  def windows_24_34?(); end

  def windows_24_3?(); end

  def windows_24_40?(); end

  def windows_24_4?(); end

  def windows_25?(); end

  def windows_25_18?(); end

  def windows_25_19?(); end

  def windows_25_1?(); end

  def windows_25_20?(); end

  def windows_25_21?(); end

  def windows_25_22?(); end

  def windows_25_23?(); end

  def windows_25_24?(); end

  def windows_25_25?(); end

  def windows_25_26?(); end

  def windows_25_27?(); end

  def windows_25_2?(); end

  def windows_25_30?(); end

  def windows_25_31?(); end

  def windows_25_32?(); end

  def windows_25_33?(); end

  def windows_25_34?(); end

  def windows_25_3?(); end

  def windows_25_40?(); end

  def windows_25_4?(); end

  def windows_26?(); end

  def windows_26_18?(); end

  def windows_26_19?(); end

  def windows_26_1?(); end

  def windows_26_20?(); end

  def windows_26_21?(); end

  def windows_26_22?(); end

  def windows_26_23?(); end

  def windows_26_24?(); end

  def windows_26_25?(); end

  def windows_26_26?(); end

  def windows_26_27?(); end

  def windows_26_2?(); end

  def windows_26_30?(); end

  def windows_26_31?(); end

  def windows_26_32?(); end

  def windows_26_33?(); end

  def windows_26_34?(); end

  def windows_26_3?(); end

  def windows_26_40?(); end

  def windows_26_4?(); end

  def windows_27?(); end

  def windows_27_18?(); end

  def windows_27_19?(); end

  def windows_27_1?(); end

  def windows_27_20?(); end

  def windows_27_21?(); end

  def windows_27_22?(); end

  def windows_27_23?(); end

  def windows_27_24?(); end

  def windows_27_25?(); end

  def windows_27_26?(); end

  def windows_27_27?(); end

  def windows_27_2?(); end

  def windows_27_30?(); end

  def windows_27_31?(); end

  def windows_27_32?(); end

  def windows_27_33?(); end

  def windows_27_34?(); end

  def windows_27_3?(); end

  def windows_27_40?(); end

  def windows_27_4?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_30_18?(); end

  def windows_30_19?(); end

  def windows_30_1?(); end

  def windows_30_20?(); end

  def windows_30_21?(); end

  def windows_30_22?(); end

  def windows_30_23?(); end

  def windows_30_24?(); end

  def windows_30_25?(); end

  def windows_30_26?(); end

  def windows_30_27?(); end

  def windows_30_2?(); end

  def windows_30_30?(); end

  def windows_30_31?(); end

  def windows_30_32?(); end

  def windows_30_33?(); end

  def windows_30_34?(); end

  def windows_30_3?(); end

  def windows_30_40?(); end

  def windows_30_4?(); end

  def windows_31?(); end

  def windows_31_18?(); end

  def windows_31_19?(); end

  def windows_31_1?(); end

  def windows_31_20?(); end

  def windows_31_21?(); end

  def windows_31_22?(); end

  def windows_31_23?(); end

  def windows_31_24?(); end

  def windows_31_25?(); end

  def windows_31_26?(); end

  def windows_31_27?(); end

  def windows_31_2?(); end

  def windows_31_30?(); end

  def windows_31_31?(); end

  def windows_31_32?(); end

  def windows_31_33?(); end

  def windows_31_34?(); end

  def windows_31_3?(); end

  def windows_31_40?(); end

  def windows_31_4?(); end

  def windows_32?(); end

  def windows_32_18?(); end

  def windows_32_19?(); end

  def windows_32_1?(); end

  def windows_32_20?(); end

  def windows_32_21?(); end

  def windows_32_22?(); end

  def windows_32_23?(); end

  def windows_32_24?(); end

  def windows_32_25?(); end

  def windows_32_26?(); end

  def windows_32_27?(); end

  def windows_32_2?(); end

  def windows_32_30?(); end

  def windows_32_31?(); end

  def windows_32_32?(); end

  def windows_32_33?(); end

  def windows_32_34?(); end

  def windows_32_3?(); end

  def windows_32_40?(); end

  def windows_32_4?(); end

  def windows_33?(); end

  def windows_33_18?(); end

  def windows_33_19?(); end

  def windows_33_1?(); end

  def windows_33_20?(); end

  def windows_33_21?(); end

  def windows_33_22?(); end

  def windows_33_23?(); end

  def windows_33_24?(); end

  def windows_33_25?(); end

  def windows_33_26?(); end

  def windows_33_27?(); end

  def windows_33_2?(); end

  def windows_33_30?(); end

  def windows_33_31?(); end

  def windows_33_32?(); end

  def windows_33_33?(); end

  def windows_33_34?(); end

  def windows_33_3?(); end

  def windows_33_40?(); end

  def windows_33_4?(); end

  def windows_34?(); end

  def windows_34_18?(); end

  def windows_34_19?(); end

  def windows_34_1?(); end

  def windows_34_20?(); end

  def windows_34_21?(); end

  def windows_34_22?(); end

  def windows_34_23?(); end

  def windows_34_24?(); end

  def windows_34_25?(); end

  def windows_34_26?(); end

  def windows_34_27?(); end

  def windows_34_2?(); end

  def windows_34_30?(); end

  def windows_34_31?(); end

  def windows_34_32?(); end

  def windows_34_33?(); end

  def windows_34_34?(); end

  def windows_34_3?(); end

  def windows_34_40?(); end

  def windows_34_4?(); end

  def windows_3?(); end

  def windows_40?(); end

  def windows_40_18?(); end

  def windows_40_19?(); end

  def windows_40_1?(); end

  def windows_40_20?(); end

  def windows_40_21?(); end

  def windows_40_22?(); end

  def windows_40_23?(); end

  def windows_40_24?(); end

  def windows_40_25?(); end

  def windows_40_26?(); end

  def windows_40_27?(); end

  def windows_40_2?(); end

  def windows_40_30?(); end

  def windows_40_31?(); end

  def windows_40_32?(); end

  def windows_40_33?(); end

  def windows_40_34?(); end

  def windows_40_3?(); end

  def windows_40_40?(); end

  def windows_40_4?(); end

  def windows_4?(); end

  def x64_mingw_20_18?(); end

  def x64_mingw_20_19?(); end

  def x64_mingw_20_1?(); end

  def x64_mingw_20_20?(); end

  def x64_mingw_20_21?(); end

  def x64_mingw_20_22?(); end

  def x64_mingw_20_23?(); end

  def x64_mingw_20_24?(); end

  def x64_mingw_20_25?(); end

  def x64_mingw_20_26?(); end

  def x64_mingw_20_27?(); end

  def x64_mingw_20_2?(); end

  def x64_mingw_20_30?(); end

  def x64_mingw_20_31?(); end

  def x64_mingw_20_32?(); end

  def x64_mingw_20_33?(); end

  def x64_mingw_20_34?(); end

  def x64_mingw_20_3?(); end

  def x64_mingw_20_40?(); end

  def x64_mingw_20_4?(); end

  def x64_mingw_21_18?(); end

  def x64_mingw_21_19?(); end

  def x64_mingw_21_1?(); end

  def x64_mingw_21_20?(); end

  def x64_mingw_21_21?(); end

  def x64_mingw_21_22?(); end

  def x64_mingw_21_23?(); end

  def x64_mingw_21_24?(); end

  def x64_mingw_21_25?(); end

  def x64_mingw_21_26?(); end

  def x64_mingw_21_27?(); end

  def x64_mingw_21_2?(); end

  def x64_mingw_21_30?(); end

  def x64_mingw_21_31?(); end

  def x64_mingw_21_32?(); end

  def x64_mingw_21_33?(); end

  def x64_mingw_21_34?(); end

  def x64_mingw_21_3?(); end

  def x64_mingw_21_40?(); end

  def x64_mingw_21_4?(); end

  def x64_mingw_22_18?(); end

  def x64_mingw_22_19?(); end

  def x64_mingw_22_1?(); end

  def x64_mingw_22_20?(); end

  def x64_mingw_22_21?(); end

  def x64_mingw_22_22?(); end

  def x64_mingw_22_23?(); end

  def x64_mingw_22_24?(); end

  def x64_mingw_22_25?(); end

  def x64_mingw_22_26?(); end

  def x64_mingw_22_27?(); end

  def x64_mingw_22_2?(); end

  def x64_mingw_22_30?(); end

  def x64_mingw_22_31?(); end

  def x64_mingw_22_32?(); end

  def x64_mingw_22_33?(); end

  def x64_mingw_22_34?(); end

  def x64_mingw_22_3?(); end

  def x64_mingw_22_40?(); end

  def x64_mingw_22_4?(); end

  def x64_mingw_23_18?(); end

  def x64_mingw_23_19?(); end

  def x64_mingw_23_1?(); end

  def x64_mingw_23_20?(); end

  def x64_mingw_23_21?(); end

  def x64_mingw_23_22?(); end

  def x64_mingw_23_23?(); end

  def x64_mingw_23_24?(); end

  def x64_mingw_23_25?(); end

  def x64_mingw_23_26?(); end

  def x64_mingw_23_27?(); end

  def x64_mingw_23_2?(); end

  def x64_mingw_23_30?(); end

  def x64_mingw_23_31?(); end

  def x64_mingw_23_32?(); end

  def x64_mingw_23_33?(); end

  def x64_mingw_23_34?(); end

  def x64_mingw_23_3?(); end

  def x64_mingw_23_40?(); end

  def x64_mingw_23_4?(); end

  def x64_mingw_24_18?(); end

  def x64_mingw_24_19?(); end

  def x64_mingw_24_1?(); end

  def x64_mingw_24_20?(); end

  def x64_mingw_24_21?(); end

  def x64_mingw_24_22?(); end

  def x64_mingw_24_23?(); end

  def x64_mingw_24_24?(); end

  def x64_mingw_24_25?(); end

  def x64_mingw_24_26?(); end

  def x64_mingw_24_27?(); end

  def x64_mingw_24_2?(); end

  def x64_mingw_24_30?(); end

  def x64_mingw_24_31?(); end

  def x64_mingw_24_32?(); end

  def x64_mingw_24_33?(); end

  def x64_mingw_24_34?(); end

  def x64_mingw_24_3?(); end

  def x64_mingw_24_40?(); end

  def x64_mingw_24_4?(); end

  def x64_mingw_25_18?(); end

  def x64_mingw_25_19?(); end

  def x64_mingw_25_1?(); end

  def x64_mingw_25_20?(); end

  def x64_mingw_25_21?(); end

  def x64_mingw_25_22?(); end

  def x64_mingw_25_23?(); end

  def x64_mingw_25_24?(); end

  def x64_mingw_25_25?(); end

  def x64_mingw_25_26?(); end

  def x64_mingw_25_27?(); end

  def x64_mingw_25_2?(); end

  def x64_mingw_25_30?(); end

  def x64_mingw_25_31?(); end

  def x64_mingw_25_32?(); end

  def x64_mingw_25_33?(); end

  def x64_mingw_25_34?(); end

  def x64_mingw_25_3?(); end

  def x64_mingw_25_40?(); end

  def x64_mingw_25_4?(); end

  def x64_mingw_26_18?(); end

  def x64_mingw_26_19?(); end

  def x64_mingw_26_1?(); end

  def x64_mingw_26_20?(); end

  def x64_mingw_26_21?(); end

  def x64_mingw_26_22?(); end

  def x64_mingw_26_23?(); end

  def x64_mingw_26_24?(); end

  def x64_mingw_26_25?(); end

  def x64_mingw_26_26?(); end

  def x64_mingw_26_27?(); end

  def x64_mingw_26_2?(); end

  def x64_mingw_26_30?(); end

  def x64_mingw_26_31?(); end

  def x64_mingw_26_32?(); end

  def x64_mingw_26_33?(); end

  def x64_mingw_26_34?(); end

  def x64_mingw_26_3?(); end

  def x64_mingw_26_40?(); end

  def x64_mingw_26_4?(); end

  def x64_mingw_27_18?(); end

  def x64_mingw_27_19?(); end

  def x64_mingw_27_1?(); end

  def x64_mingw_27_20?(); end

  def x64_mingw_27_21?(); end

  def x64_mingw_27_22?(); end

  def x64_mingw_27_23?(); end

  def x64_mingw_27_24?(); end

  def x64_mingw_27_25?(); end

  def x64_mingw_27_26?(); end

  def x64_mingw_27_27?(); end

  def x64_mingw_27_2?(); end

  def x64_mingw_27_30?(); end

  def x64_mingw_27_31?(); end

  def x64_mingw_27_32?(); end

  def x64_mingw_27_33?(); end

  def x64_mingw_27_34?(); end

  def x64_mingw_27_3?(); end

  def x64_mingw_27_40?(); end

  def x64_mingw_27_4?(); end

  def x64_mingw_30?(); end

  def x64_mingw_30_18?(); end

  def x64_mingw_30_19?(); end

  def x64_mingw_30_1?(); end

  def x64_mingw_30_20?(); end

  def x64_mingw_30_21?(); end

  def x64_mingw_30_22?(); end

  def x64_mingw_30_23?(); end

  def x64_mingw_30_24?(); end

  def x64_mingw_30_25?(); end

  def x64_mingw_30_26?(); end

  def x64_mingw_30_27?(); end

  def x64_mingw_30_2?(); end

  def x64_mingw_30_30?(); end

  def x64_mingw_30_31?(); end

  def x64_mingw_30_32?(); end

  def x64_mingw_30_33?(); end

  def x64_mingw_30_34?(); end

  def x64_mingw_30_3?(); end

  def x64_mingw_30_40?(); end

  def x64_mingw_30_4?(); end

  def x64_mingw_31?(); end

  def x64_mingw_31_18?(); end

  def x64_mingw_31_19?(); end

  def x64_mingw_31_1?(); end

  def x64_mingw_31_20?(); end

  def x64_mingw_31_21?(); end

  def x64_mingw_31_22?(); end

  def x64_mingw_31_23?(); end

  def x64_mingw_31_24?(); end

  def x64_mingw_31_25?(); end

  def x64_mingw_31_26?(); end

  def x64_mingw_31_27?(); end

  def x64_mingw_31_2?(); end

  def x64_mingw_31_30?(); end

  def x64_mingw_31_31?(); end

  def x64_mingw_31_32?(); end

  def x64_mingw_31_33?(); end

  def x64_mingw_31_34?(); end

  def x64_mingw_31_3?(); end

  def x64_mingw_31_40?(); end

  def x64_mingw_31_4?(); end

  def x64_mingw_32?(); end

  def x64_mingw_32_18?(); end

  def x64_mingw_32_19?(); end

  def x64_mingw_32_1?(); end

  def x64_mingw_32_20?(); end

  def x64_mingw_32_21?(); end

  def x64_mingw_32_22?(); end

  def x64_mingw_32_23?(); end

  def x64_mingw_32_24?(); end

  def x64_mingw_32_25?(); end

  def x64_mingw_32_26?(); end

  def x64_mingw_32_27?(); end

  def x64_mingw_32_2?(); end

  def x64_mingw_32_30?(); end

  def x64_mingw_32_31?(); end

  def x64_mingw_32_32?(); end

  def x64_mingw_32_33?(); end

  def x64_mingw_32_34?(); end

  def x64_mingw_32_3?(); end

  def x64_mingw_32_40?(); end

  def x64_mingw_32_4?(); end

  def x64_mingw_33?(); end

  def x64_mingw_33_18?(); end

  def x64_mingw_33_19?(); end

  def x64_mingw_33_1?(); end

  def x64_mingw_33_20?(); end

  def x64_mingw_33_21?(); end

  def x64_mingw_33_22?(); end

  def x64_mingw_33_23?(); end

  def x64_mingw_33_24?(); end

  def x64_mingw_33_25?(); end

  def x64_mingw_33_26?(); end

  def x64_mingw_33_27?(); end

  def x64_mingw_33_2?(); end

  def x64_mingw_33_30?(); end

  def x64_mingw_33_31?(); end

  def x64_mingw_33_32?(); end

  def x64_mingw_33_33?(); end

  def x64_mingw_33_34?(); end

  def x64_mingw_33_3?(); end

  def x64_mingw_33_40?(); end

  def x64_mingw_33_4?(); end

  def x64_mingw_34?(); end

  def x64_mingw_34_18?(); end

  def x64_mingw_34_19?(); end

  def x64_mingw_34_1?(); end

  def x64_mingw_34_20?(); end

  def x64_mingw_34_21?(); end

  def x64_mingw_34_22?(); end

  def x64_mingw_34_23?(); end

  def x64_mingw_34_24?(); end

  def x64_mingw_34_25?(); end

  def x64_mingw_34_26?(); end

  def x64_mingw_34_27?(); end

  def x64_mingw_34_2?(); end

  def x64_mingw_34_30?(); end

  def x64_mingw_34_31?(); end

  def x64_mingw_34_32?(); end

  def x64_mingw_34_33?(); end

  def x64_mingw_34_34?(); end

  def x64_mingw_34_3?(); end

  def x64_mingw_34_40?(); end

  def x64_mingw_34_4?(); end

  def x64_mingw_3?(); end

  def x64_mingw_40?(); end

  def x64_mingw_40_18?(); end

  def x64_mingw_40_19?(); end

  def x64_mingw_40_1?(); end

  def x64_mingw_40_20?(); end

  def x64_mingw_40_21?(); end

  def x64_mingw_40_22?(); end

  def x64_mingw_40_23?(); end

  def x64_mingw_40_24?(); end

  def x64_mingw_40_25?(); end

  def x64_mingw_40_26?(); end

  def x64_mingw_40_27?(); end

  def x64_mingw_40_2?(); end

  def x64_mingw_40_30?(); end

  def x64_mingw_40_31?(); end

  def x64_mingw_40_32?(); end

  def x64_mingw_40_33?(); end

  def x64_mingw_40_34?(); end

  def x64_mingw_40_3?(); end

  def x64_mingw_40_40?(); end

  def x64_mingw_40_4?(); end

  def x64_mingw_4?(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
end

class Bundler::Definition
  def add_checksums(); end

  def bundler_version_to_lock(); end

  def check!(); end

  def current_locked_dependencies(); end

  def deleted_deps(); end

  def dependencies_for(groups); end

  def filter_relevant(dependencies); end

  def locked_checksums(); end

  def locked_dependencies(); end

  def lockfile=(lockfile); end

  def new_deps(); end

  def no_resolve_needed?(); end

  def normalize_platforms(); end

  def prefer_local!(); end

  def relevant_deps?(dep); end

  def remotely!(); end

  def requested_dependencies(); end

  def setup_domain!(options=T.unsafe(nil)); end

  def sources(); end

  def with_cache!(); end

  def write_lock(file, preserve_unknown_sections); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def env(); end

  def expanded_platforms(); end

  def gemfile_dep?(); end

  def gemspec_dev_dep?(); end

  def git(); end

  def github(); end

  def glob(); end

  def path(); end

  def ref(); end

  def should_include(); end
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end

  def gemfile(); end

  def lockfile(file); end

  def lockfile_path(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
  GITLAB_MERGE_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
  def locked_platform(); end

  def locked_platform=(locked_platform); end
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.from_env(); end
end

class Bundler::FeatureFlag
  def deprecated_major?(target_major_version); end

  def removed_major?(target_major_version); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def api_fetcher?(); end

  def fetch_spec(spec); end

  def gem_remote_fetcher(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationForbiddenError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationForbiddenError
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def gem_remote_fetcher(); end

  def initialize(downloader, remote, display_uri, gem_remote_fetcher); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
  HTTP_NON_RETRYABLE_ERRORS = ::T.let(nil, ::T.untyped)
  HTTP_RETRYABLE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
  def default_force_ruby_platform(); end
end

module Bundler::ForcePlatform
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Bundler::GemVersionPromoter
  def filter_versions(package, specs); end

  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::IncorrectLockfileDependencies
  def initialize(spec); end

  def spec(); end

  def status_code(); end
end

class Bundler::IncorrectLockfileDependencies
end

class Bundler::Index
  include ::Enumerable
  def add(spec); end

  def duplicates(); end

  def merge!(other); end

  def subset?(other); end
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::InsecureInstallPathError
  def initialize(name, path); end

  def status_code(); end
end

class Bundler::InsecureInstallPathError
end

class Bundler::Installer
  def definition(); end
end

class Bundler::InvalidArgumentError
  def status_code(); end
end

class Bundler::InvalidArgumentError
end

class Bundler::LazySpecification
  include ::Bundler::MatchMetadata
  include ::Bundler::ForcePlatform
  def dependencies=(dependencies); end

  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform!(); end

  def force_ruby_platform=(force_ruby_platform); end

  def incomplete?(); end

  def lock_name(); end

  def materialization(); end

  def materialize_for_cache(); end

  def materialize_for_installation(); end

  def materialized_for_installation(); end

  def missing?(); end

  def most_specific_locked_platform(); end

  def most_specific_locked_platform=(most_specific_locked_platform); end

  def name_tuple(); end

  def replace_source_with!(gemfile_source); end

  def required_ruby_version(); end

  def required_ruby_version=(required_ruby_version); end

  def required_rubygems_version(); end

  def required_rubygems_version=(required_rubygems_version); end

  def runtime_dependencies(); end

  def source_changed?(); end
end

class Bundler::LazySpecification
  def self.from_spec(s); end
end

class Bundler::LockfileParser
  def checksums(); end

  def may_include_redundant_platform_specific_gems?(); end

  def most_specific_locked_platform(); end
  CHECKSUMS = ::T.let(nil, ::T.untyped)
end

class Bundler::LockfileParser::Position
  def advance!(string); end

  def column(); end

  def initialize(line, column); end

  def line(); end
end

class Bundler::LockfileParser::Position
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def expanded_dependencies(); end

  def matches_current_metadata?(); end

  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end

  def metadata_dependency(name, requirement); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchPlatform
  def installable_on_platform?(target_platform); end
end

module Bundler::MatchPlatform
  def self.generic_local_platform_is_ruby?(); end

  def self.select_all_platform_match(specs, platform, force_ruby: T.unsafe(nil), prefer_locked: T.unsafe(nil)); end

  def self.select_best_local_platform_match(specs, force_ruby: T.unsafe(nil)); end

  def self.select_best_platform_match(specs, platform, force_ruby: T.unsafe(nil), prefer_locked: T.unsafe(nil)); end
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::Materialization
  def complete?(); end

  def completely_missing_specs(); end

  def dependencies(); end

  def incomplete_specs(); end

  def initialize(dep, platform, candidates:); end

  def materialized_spec(); end

  def partially_missing_specs(); end

  def specs(); end
end

class Bundler::Materialization
end

class Bundler::OperationNotPermittedError
end

class Bundler::OperationNotPermittedError
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def checksum_store(); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_REQUIRE = ::T.let(nil, ::T.untyped)
  GEM_AFTER_REQUIRE_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_REQUIRE = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_REQUIRE_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_in_plugin_root?(name); end

  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Path
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Path
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.from_lock(locked_opts); end

  def self.list(); end

  def self.loaded?(plugin); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil), &block); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::ReadOnlyFileSystemError
end

class Bundler::ReadOnlyFileSystemError
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
  def insecurely_materialized?(); end

  def locked_platform(); end

  def locked_platform=(locked_platform); end

  def runtime_dependencies(); end
end

class Bundler::RemovedError
  def status_code(); end
end

class Bundler::RemovedError
end

class Bundler::Resolver
  def all_versions_for(package); end

  def bundler_pinned_to_current_version?(); end

  def default_bundler_source(); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_incomplete!(incomplete_specs); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def sort_versions_by_preferred(package, versions); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def include_remote_specs(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def locked_specs(); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def initialize(version, group: T.unsafe(nil), priority: T.unsafe(nil)); end

  def prerelease?(); end

  def priority(); end

  def segments(); end

  def to_specs(package, most_specific_locked_platform); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def consider_remote_versions!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), prefer_local: T.unsafe(nil), dependency: T.unsafe(nil), new_platforms: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platform_specs(specs); end

  def platforms(); end

  def prefer_local?(); end

  def prerelease_specified?(); end

  def root?(); end

  def top_level?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def merge(other); end

  def sorted_spec_names(); end

  def specs(); end
end

class Bundler::Resolver::Strategy
  def initialize(source); end

  def next_package_and_version(unsatisfied); end
end

class Bundler::Resolver::Strategy
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  def normalize_ruby_file(filename); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def all_specs(); end

  def default_specs(); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def installed_specs(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def set_target_rbconfig(path); end

  def stub_rubygems(specs); end
end

module Bundler::SafeMarshal
  ALLOWED_CLASSES = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  PROC = ::T.let(nil, ::T.untyped)
end

module Bundler::SafeMarshal
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  FALLBACK_TIMEOUT_URI_OPTION = ::T.let(nil, ::T.untyped)
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end

  def self.key_to_s(key); end
end

module Bundler::SharedHelpers
  def bundle_bin_path(); end

  def checksum_for_file(path, digest); end

  def feature_deprecated!(message); end

  def feature_removed!(message); end

  def gemspec_path(); end

  def relative_gemfile_path(); end

  def relative_lockfile_path(); end

  def relative_path_to(destination, from: T.unsafe(nil)); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def checksum_store(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def prefer_local!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Gemspec
  def checksum_store=(checksum_store); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end

  def migrate_cache(custom_path=T.unsafe(nil), local: T.unsafe(nil)); end

  def uri_with_specifiers(specifiers); end
end

class Bundler::Source::Path
  def to_gemfile(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def default_specs(); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def local_only?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_fetchers(); end

  def remote_names(); end

  def remotes=(remotes); end

  def to_gemfile(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local!(); end

  def local_mode?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end

  def prefer_local!(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def add_extra_platforms!(platforms); end

  def add_originally_invalid_platforms!(platforms, originally_invalid_platforms); end

  def delete(specs); end

  def delete_by_name(name); end

  def incomplete_for_platform?(deps, platform); end

  def incomplete_specs(); end

  def incomplete_specs_for_platform(deps, platform); end

  def insecurely_materialized_specs(); end

  def missing_specs(); end

  def missing_specs_for(deps); end

  def names(); end

  def normalize_platforms!(deps, platforms); end

  def partially_missing_specs(); end

  def remove_invalid_platforms!(deps, platforms, skips: T.unsafe(nil)); end

  def specs_with_additional_variants_from(other); end

  def valid?(s); end

  def validate_deps(s); end

  def version_for(name); end
end

class Bundler::StubSpecification
  def activated?(); end

  def base_dir=(path); end

  def checksum(); end

  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def ignored?(); end

  def manually_installed?(); end

  def require_paths(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def gsub_file!(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def content(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def replacement_present?(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def enum_to_s(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def print_default(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

class Bundler::Thor::AtLeastOneRequiredArgumentError
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, wrap_long_description, usage, options=T.unsafe(nil), options_relation=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def method_at_least_one_option_names(); end

  def method_exclusive_option_names(); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def slice(*keys); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::ExclusiveArgumentError
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  def self.banner(); end

  def self.command_exists?(command_name); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def aliases_for_usage(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_at_least_one!(); end

  def check_exclusive!(); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil), relations=T.unsafe(nil)); end

  def names_to_switch_names(names=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  def self.at_least_one(*args, &block); end

  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_exists?(command_name); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.exclusive(*args, &block); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_at_least_one(*args, &block); end

  def self.method_at_least_one_option_names(); end

  def self.method_exclusive(*args, &block); end

  def self.method_exclusive_option_names(); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.print_at_least_one_required_options(shell, command=T.unsafe(nil)); end

  def self.print_exclusive_options(shell, command=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.sort_commands!(list); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(msg); end

  def output_stream(); end

  def output_stream=(symbol); end

  def progress(&blk); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
  OUTPUT_STREAMS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def output_stream(); end

  def output_stream=(_symbol); end

  def progress(); end

  def warn?(); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

class Bundler::Worker
  def deq(); end

  def enq(obj); end

  def initialize(size, name, func); end

  def name(); end

  def stop(); end
  POISON = ::T.let(nil, ::T.untyped)
end

class Bundler::Worker::WrappedException
  def exception(); end

  def initialize(exn); end
end

class Bundler::Worker::WrappedException
end

class Bundler::Worker
end

module Bundler
  def self.auto_install(); end

  def self.auto_switch(); end

  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.find_executable(path); end

  def self.gem_version(); end

  def self.generic_local_platform(); end

  def self.original_exec(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.simulated_version(); end

  def self.unbundle_env!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.verbose_version(); end
end

module CGI::Escape
  def escape_uri_component(arg); end

  def unescape_uri_component(*arg); end
end

module CGI::Util
  def escape_uri_component(arg); end

  def unescape_uri_component(*arg); end
end

class Class
  def any_instance(); end
end

module Cucumber
  BINARY = ::T.let(nil, ::T.untyped)
  IRONRUBY = ::T.let(nil, ::T.untyped)
  JRUBY = ::T.let(nil, ::T.untyped)
  LIBDIR = ::T.let(nil, ::T.untyped)
  OS_X = ::T.let(nil, ::T.untyped)
  RUBY_1_9 = ::T.let(nil, ::T.untyped)
  RUBY_2_0 = ::T.let(nil, ::T.untyped)
  RUBY_BINARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
  WINDOWS_MRI = ::T.let(nil, ::T.untyped)
end

class Cucumber::Ambiguous
  def initialize(step_name, step_definitions, used_guess); end
end

class Cucumber::Ambiguous
end

class Cucumber::AmbiguousStepMatch
  def activate(test_step); end

  def initialize(error); end
end

class Cucumber::AmbiguousStepMatch
end

module Cucumber::CiEnvironment
  CI_ENVIRONMENTS_PATH = ::T.let(nil, ::T.untyped)
end

module Cucumber::CiEnvironment::VariableExpression
  def evaluate(expression, env); end

  def get_value(variable, env); end
end

module Cucumber::CiEnvironment::VariableExpression
end

module Cucumber::CiEnvironment
  extend ::Cucumber::CiEnvironment::VariableExpression
  def self.detect(ci_environment, env); end

  def self.detect_ci_environment(env); end

  def self.detect_git(ci_environment, env); end

  def self.detect_revision(ci_environment, env); end

  def self.remove_userinfo_from_url(value); end
end

module Cucumber::Cli
end

class Cucumber::Cli::Configuration
  include ::Cucumber::Constantize
  def dry_run?(); end

  def expand?(); end

  def fail_fast?(); end

  def filters(); end

  def formats(); end

  def guess?(); end

  def initialize(out_stream=T.unsafe(nil), error_stream=T.unsafe(nil)); end

  def name_regexps(); end

  def out_stream(); end

  def parse!(args); end

  def paths(); end

  def randomize?(); end

  def retry_attempts(); end

  def seed(); end

  def snippet_type(); end

  def strict(); end

  def tag_expressions(); end

  def tag_limits(); end

  def to_hash(); end

  def verbose?(); end

  def wip?(); end
end

class Cucumber::Cli::Configuration::LogFormatter
  def call(_severity, _time, _progname, msg); end
end

class Cucumber::Cli::Configuration::LogFormatter
end

class Cucumber::Cli::Configuration
end

class Cucumber::Cli::Main
  def configuration(); end

  def execute!(existing_runtime=T.unsafe(nil)); end

  def initialize(args, out=T.unsafe(nil), err=T.unsafe(nil), kernel=T.unsafe(nil)); end
end

class Cucumber::Cli::Main
  def self.execute(args); end
end

class Cucumber::Cli::Options
  def [](key); end

  def []=(key, value); end

  def check_formatter_stream_conflicts(); end

  def custom_profiles(); end

  def expanded_args(); end

  def filters(); end

  def initialize(out_stream=T.unsafe(nil), error_stream=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def parse!(args); end

  def profiles(); end

  def to_hash(); end
  BUILTIN_FORMATS = ::T.let(nil, ::T.untyped)
  CUCUMBER_PUBLISH_URL = ::T.let(nil, ::T.untyped)
  FAIL_FAST_FLAG = ::T.let(nil, ::T.untyped)
  FORMAT_HELP = ::T.let(nil, ::T.untyped)
  FORMAT_HELP_MSG = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  NO_PROFILE_LONG_FLAG = ::T.let(nil, ::T.untyped)
  NO_PROFILE_SHORT_FLAG = ::T.let(nil, ::T.untyped)
  OPTIONS_WITH_ARGS = ::T.let(nil, ::T.untyped)
  ORDER_TYPES = ::T.let(nil, ::T.untyped)
  PROFILE_LONG_FLAG = ::T.let(nil, ::T.untyped)
  PROFILE_SHORT_FLAG = ::T.let(nil, ::T.untyped)
  RETRY_FLAG = ::T.let(nil, ::T.untyped)
  RETRY_TOTAL_FLAG = ::T.let(nil, ::T.untyped)
  TAG_LIMIT_MATCHER = ::T.let(nil, ::T.untyped)
end

class Cucumber::Cli::Options
  def self.parse(args, out_stream, error_stream, options=T.unsafe(nil)); end
end

class Cucumber::Cli::ProfileLoader
  def args_from(profile); end

  def cucumber_yml_defined?(); end

  def profile?(profile); end
end

class Cucumber::Cli::ProfileLoader
end

class Cucumber::Cli::ProfileNotFound
end

class Cucumber::Cli::ProfileNotFound
end

class Cucumber::Cli::ProfilesNotDefinedError
end

class Cucumber::Cli::ProfilesNotDefinedError
end

class Cucumber::Cli::RerunFile
  def features(); end

  def initialize(path); end

  def path(); end
end

class Cucumber::Cli::RerunFile
  def self.can_read?(path); end

  def self.real_path(path); end
end

class Cucumber::Cli::YmlLoadError
end

class Cucumber::Cli::YmlLoadError
end

module Cucumber::Cli
end

class Cucumber::Configuration
  include ::Cucumber::Constantize
  def all_files_to_load(); end

  def autoload_code_paths(); end

  def custom_profiles(); end

  def dry_run?(); end

  def duration?(); end

  def error_stream(); end

  def event_bus(); end

  def expand?(); end

  def fail_fast?(); end

  def feature_dirs(); end

  def feature_files(); end

  def filters(); end

  def formats(); end

  def formatter_class(format); end

  def formatter_factories(); end

  def guess?(); end

  def id_generator(); end

  def initialize(user_options=T.unsafe(nil)); end

  def name_regexps(); end

  def notify(message, *args); end

  def on_event(*args, **arg, &block); end

  def out_stream(); end

  def paths(); end

  def profiles(); end

  def publish_enabled?(); end

  def publish_quiet?(); end

  def randomize?(); end

  def register_snippet_generator(generator); end

  def retry_attempts(); end

  def retry_total_tests(); end

  def seed(); end

  def skip_profile_information?(); end

  def snippet_generators(); end

  def snippet_type(); end

  def snippets?(); end

  def source?(); end

  def step_defs_to_load(); end

  def strict(); end

  def support_to_load(); end

  def tag_expressions(); end

  def tag_limits(); end

  def to_hash(); end

  def wip?(); end

  def with_options(new_options); end
end

class Cucumber::Configuration
  extend ::Forwardable
  def self.default(); end
end

module Cucumber::Constantize
  def constantize(camel_cased_word); end

  def underscore(camel_cased_word); end
end

module Cucumber::Constantize
end

module Cucumber::Core
  def compile(gherkin_documents, last_receiver, filters=T.unsafe(nil), event_bus=T.unsafe(nil)); end

  def execute(gherkin_documents, filters=T.unsafe(nil), event_bus=T.unsafe(nil)); end
end

class Cucumber::Core::Compiler
  def done(); end

  def initialize(receiver, gherkin_query, event_bus=T.unsafe(nil)); end

  def pickle(pickle); end
end

class Cucumber::Core::Compiler
end

class Cucumber::Core::Event
end

class Cucumber::Core::Event
  def self.event_id(); end

  def self.new(*events); end
end

class Cucumber::Core::EventBus
  def broadcast(event); end

  def event_types(); end

  def initialize(registry=T.unsafe(nil)); end

  def method_missing(event_id, *arg); end

  def on(event_id, handler_object=T.unsafe(nil), &handler_proc); end
end

class Cucumber::Core::EventBus
end

module Cucumber::Core::Events
end

class Cucumber::Core::Events::Envelope
end

class Cucumber::Core::Events::Envelope
end

class Cucumber::Core::Events::GherkinSourceParsed
end

class Cucumber::Core::Events::GherkinSourceParsed
end

class Cucumber::Core::Events::TestCaseCreated
end

class Cucumber::Core::Events::TestCaseCreated
end

class Cucumber::Core::Events::TestCaseFinished
end

class Cucumber::Core::Events::TestCaseFinished
end

class Cucumber::Core::Events::TestCaseStarted
end

class Cucumber::Core::Events::TestCaseStarted
end

class Cucumber::Core::Events::TestStepCreated
end

class Cucumber::Core::Events::TestStepCreated
end

class Cucumber::Core::Events::TestStepFinished
end

class Cucumber::Core::Events::TestStepFinished
end

class Cucumber::Core::Events::TestStepStarted
end

class Cucumber::Core::Events::TestStepStarted
end

module Cucumber::Core::Events
  def self.build_registry(*types); end

  def self.registry(); end
end

module Cucumber::Core::Filter
end

module Cucumber::Core::Filter
  def self.new(*attributes, &block); end
end

module Cucumber::Core::Gherkin
end

class Cucumber::Core::Gherkin::Document
  def ==(other); end

  def body(); end

  def initialize(uri, body, language=T.unsafe(nil)); end

  def language(); end

  def uri(); end
end

class Cucumber::Core::Gherkin::Document
end

class Cucumber::Core::Gherkin::ParseError
end

class Cucumber::Core::Gherkin::ParseError
end

class Cucumber::Core::Gherkin::Parser
  def document(document); end

  def done(); end

  def gherkin_options(document); end

  def initialize(receiver, event_bus, gherkin_query); end
end

class Cucumber::Core::Gherkin::Parser
end

module Cucumber::Core::Gherkin
end

module Cucumber::Core::Report
end

class Cucumber::Core::Report::Summary
  def initialize(event_bus); end

  def ok?(strict: T.unsafe(nil)); end

  def test_cases(); end

  def test_steps(); end
end

class Cucumber::Core::Report::Summary
end

module Cucumber::Core::Report
end

module Cucumber::Core::Test
end

module Cucumber::Core::Test::Action
end

class Cucumber::Core::Test::Action::Defined
  def execute(*arg); end

  def initialize(location=T.unsafe(nil), &block); end

  def location(); end

  def skip(*arg); end
end

class Cucumber::Core::Test::Action::Defined
end

class Cucumber::Core::Test::Action::Undefined
  def execute(*arg); end

  def initialize(source_location); end

  def location(); end

  def skip(*arg); end
end

class Cucumber::Core::Test::Action::Undefined
end

class Cucumber::Core::Test::Action::Unskippable
end

class Cucumber::Core::Test::Action::Unskippable
end

module Cucumber::Core::Test::Action
end

class Cucumber::Core::Test::AroundHook
  def describe_to(visitor, *arg, &arg1); end

  def execute(*_args, &continue); end

  def hook?(); end

  def initialize(&block); end
end

class Cucumber::Core::Test::AroundHook
end

class Cucumber::Core::Test::Case
  def ==(other); end

  def around_hooks(); end

  def describe_to(visitor, *args); end

  def eql?(other); end

  def id(); end

  def initialize(id, name, test_steps, location, parent_locations, tags, language, around_hooks=T.unsafe(nil)); end

  def language(); end

  def location(); end

  def match_locations?(queried_locations); end

  def match_name?(name_regexp); end

  def match_tags?(*expressions); end

  def matching_locations(); end

  def name(); end

  def parent_locations(); end

  def step_count(); end

  def tags(); end

  def test_steps(); end

  def with_around_hooks(around_hooks); end

  def with_steps(test_steps); end
end

class Cucumber::Core::Test::Case
end

class Cucumber::Core::Test::DataTable
  def ==(other); end

  def data_table?(); end

  def describe_to(visitor, *arg); end

  def doc_string?(); end

  def initialize(rows); end

  def lines_count(); end

  def map(&block); end

  def raw(); end

  def to_step_definition_arg(); end

  def transpose(); end
end

class Cucumber::Core::Test::DataTable
end

class Cucumber::Core::Test::DocString
  def ==(other); end

  def content(); end

  def content_type(); end

  def data_table?(); end

  def describe_to(visitor, *arg); end

  def doc_string?(); end

  def initialize(content, content_type); end

  def inspect(); end

  def lines_count(); end

  def map(); end

  def to_step_definition_arg(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::Core::Test::DocString
end

class Cucumber::Core::Test::EmptyMultilineArgument
  def data_table?(); end

  def describe_to(*arg); end

  def doc_string?(); end

  def lines_count(); end

  def map(); end
end

class Cucumber::Core::Test::EmptyMultilineArgument
end

module Cucumber::Core::Test::HasLocation
  def attributes(); end

  def comments(); end

  def file(); end

  def file_colon_line(); end

  def line(); end

  def location(); end

  def multiline_arg(); end

  def tags(); end
end

module Cucumber::Core::Test::HasLocation
end

class Cucumber::Core::Test::HookStep
  def initialize(id, text, location, action); end
end

class Cucumber::Core::Test::HookStep
end

class Cucumber::Core::Test::IncompatibleLocations
end

class Cucumber::Core::Test::IncompatibleLocations
end

module Cucumber::Core::Test::Location
end

class Cucumber::Core::Test::Location::Lines
  def +(other); end

  def data(); end

  def data=(_); end

  def first(); end

  def include?(other); end

  def initialize(raw_data); end

  def max(); end

  def min(); end

  def range?(); end
end

class Cucumber::Core::Test::Location::Lines
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Cucumber::Core::Test::Location::Precise
  def file(); end

  def file=(_); end

  def include?(other_lines); end

  def line(); end

  def lines(); end

  def lines=(_); end

  def match?(other); end

  def merge(multiline_arg); end

  def on_line(new_line); end

  def to_str(); end
end

class Cucumber::Core::Test::Location::Precise
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Cucumber::Core::Test::Location::Wildcard
  def file(); end

  def file=(_); end

  def include?(_lines); end

  def match?(other); end
end

class Cucumber::Core::Test::Location::Wildcard
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Cucumber::Core::Test::Location
  def self.from_file_colon_line(file_colon_line); end

  def self.from_source_location(file, line, *_args); end

  def self.new(file, raw_lines=T.unsafe(nil)); end

  def self.of_caller(additional_depth=T.unsafe(nil)); end
end

class Cucumber::Core::Test::LocationsFilter
end

class Cucumber::Core::Test::LocationsFilter
end

class Cucumber::Core::Test::NameFilter
end

class Cucumber::Core::Test::NameFilter
end

module Cucumber::Core::Test::Result
  STRICT_AFFECTED_TYPES = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Cucumber::Core::Test::Result::Duration
  include ::Cucumber::Messages::Helpers::TimeConversion
  def initialize(nanoseconds); end

  def nanoseconds(); end

  def seconds_to_duration(seconds_float); end

  def to_message_duration(); end
end

class Cucumber::Core::Test::Result::Duration
end

class Cucumber::Core::Test::Result::Failed
  def describe_to(visitor, *arg); end

  def duration(); end

  def exception(); end

  def initialize(duration, exception); end

  def ok?(*arg); end

  def to_message(); end

  def with_appended_backtrace(step); end

  def with_duration(new_duration); end

  def with_filtered_backtrace(filter); end
end

class Cucumber::Core::Test::Result::Failed
  def self.ok?(*arg); end
end

class Cucumber::Core::Test::Result::Flaky
end

class Cucumber::Core::Test::Result::Flaky
  def self.ok?(strict: T.unsafe(nil)); end
end

class Cucumber::Core::Test::Result::Passed
  def describe_to(visitor, *arg); end

  def duration(); end

  def duration=(duration); end

  def initialize(duration); end

  def ok?(*arg); end

  def to_message(); end

  def with_appended_backtrace(_step); end

  def with_filtered_backtrace(_filter); end
end

class Cucumber::Core::Test::Result::Passed
  def self.ok?(*arg); end
end

class Cucumber::Core::Test::Result::Pending
  def describe_to(visitor, *arg); end

  def to_message(); end
end

class Cucumber::Core::Test::Result::Pending
  def self.ok?(strict: T.unsafe(nil)); end
end

class Cucumber::Core::Test::Result::Raisable
  def duration(); end

  def initialize(message=T.unsafe(nil), duration=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def ok?(strict: T.unsafe(nil)); end

  def with_appended_backtrace(step); end

  def with_duration(new_duration); end

  def with_filtered_backtrace(filter); end

  def with_message(new_message); end
end

class Cucumber::Core::Test::Result::Raisable
end

class Cucumber::Core::Test::Result::Skipped
  def describe_to(visitor, *arg); end

  def to_message(); end
end

class Cucumber::Core::Test::Result::Skipped
  def self.ok?(*arg); end
end

class Cucumber::Core::Test::Result::StrictConfiguration
  def initialize(strict_types=T.unsafe(nil)); end

  def merge!(other); end

  def set?(type); end

  def set_strict(setting, type=T.unsafe(nil)); end

  def settings=(settings); end

  def strict?(type=T.unsafe(nil)); end
end

class Cucumber::Core::Test::Result::StrictConfiguration
end

class Cucumber::Core::Test::Result::Summary
  def decrement_failed(); end

  def duration(duration); end

  def durations(); end

  def exception(exception); end

  def exceptions(); end

  def method_missing(name, *_args); end

  def ok?(strict: T.unsafe(nil)); end

  def total(for_status=T.unsafe(nil)); end
end

class Cucumber::Core::Test::Result::Summary
end

class Cucumber::Core::Test::Result::Undefined
  def describe_to(visitor, *arg); end

  def to_message(); end
end

class Cucumber::Core::Test::Result::Undefined
  def self.ok?(strict: T.unsafe(nil)); end
end

class Cucumber::Core::Test::Result::Unknown
  def describe_to(_visitor, *_args); end

  def to_message(); end

  def with_filtered_backtrace(_filter); end
end

class Cucumber::Core::Test::Result::Unknown
end

class Cucumber::Core::Test::Result::UnknownDuration
  def nanoseconds(); end

  def to_message_duration(); end
end

class Cucumber::Core::Test::Result::UnknownDuration
end

module Cucumber::Core::Test::Result
  def self.ok?(type, strict: T.unsafe(nil)); end

  def self.query_methods(result_type); end
end

class Cucumber::Core::Test::Runner
  def around_hook(hook, &arg); end

  def done(); end

  def initialize(event_bus); end

  def test_case(test_case, &descend); end

  def test_step(test_step); end
end

class Cucumber::Core::Test::Runner::RunningTestCase
  def duration(_step_duration, _step_result); end

  def exception(_step_exception, _step_result); end

  def execute(test_step, &arg); end

  def failed(step_result); end

  def passed(step_result); end

  def pending(_message, step_result); end

  def result(); end

  def skipped(step_result); end

  def undefined(step_result); end
end

module Cucumber::Core::Test::Runner::RunningTestCase::Status
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Base
  def execute(test_step, monitor, &arg); end

  def initialize(step_result); end

  def result(); end
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Base
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Failing
  def execute(test_step, monitor); end

  def result(duration); end
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Failing
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Passing
  def result(duration); end
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Passing
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Pending
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Pending
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Skipping
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Skipping
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Unknown
  def result(_duration); end
end

class Cucumber::Core::Test::Runner::RunningTestCase::Status::Unknown
end

module Cucumber::Core::Test::Runner::RunningTestCase::Status
end

class Cucumber::Core::Test::Runner::RunningTestCase
end

class Cucumber::Core::Test::Runner
end

class Cucumber::Core::Test::Step
  def action_location(); end

  def backtrace_line(); end

  def describe_to(visitor, *arg); end

  def execute(*arg); end

  def hook?(); end

  def id(); end

  def initialize(id, text, location, multiline_arg=T.unsafe(nil), action=T.unsafe(nil)); end

  def location(); end

  def matching_locations(); end

  def multiline_arg(); end

  def skip(*arg); end

  def text(); end

  def with_action(action_location=T.unsafe(nil), &arg); end
end

class Cucumber::Core::Test::Step
end

class Cucumber::Core::Test::Tag
  include ::Cucumber::Core::Test::HasLocation
  def initialize(location, name); end

  def name(); end
end

class Cucumber::Core::Test::Tag
end

class Cucumber::Core::Test::TagFilter
end

class Cucumber::Core::Test::TagFilter::TestCases
  def <<(test_case); end

  def with_tag_name(tag_name); end
end

class Cucumber::Core::Test::TagFilter::TestCases
end

class Cucumber::Core::Test::TagFilter
end

class Cucumber::Core::Test::Timer
  def duration(); end

  def nsec(); end

  def sec(); end

  def start(); end
end

module Cucumber::Core::Test::Timer::MonotonicTime
end

module Cucumber::Core::Test::Timer::MonotonicTime
  def self.time_in_nanoseconds(); end
end

class Cucumber::Core::Test::Timer
end

module Cucumber::Core::Test
end

module Cucumber::Core
end

module Cucumber::CucumberExpressions
  ALTERNATION_CHARACTER = ::T.let(nil, ::T.untyped)
  BEGIN_OPTIONAL_CHARACTER = ::T.let(nil, ::T.untyped)
  BEGIN_PARAMETER_CHARACTER = ::T.let(nil, ::T.untyped)
  END_OPTIONAL_CHARACTER = ::T.let(nil, ::T.untyped)
  END_PARAMETER_CHARACTER = ::T.let(nil, ::T.untyped)
  ESCAPE_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::AlternationNotAllowedInOptional
  def initialize(expression, current); end
end

class Cucumber::CucumberExpressions::AlternationNotAllowedInOptional
end

class Cucumber::CucumberExpressions::AlternativeMayNotBeEmpty
  def initialize(node, expression); end
end

class Cucumber::CucumberExpressions::AlternativeMayNotBeEmpty
end

class Cucumber::CucumberExpressions::AlternativeMayNotExclusivelyContainOptionals
  def initialize(node, expression); end
end

class Cucumber::CucumberExpressions::AlternativeMayNotExclusivelyContainOptionals
end

class Cucumber::CucumberExpressions::AmbiguousParameterTypeError
  def initialize(parameter_type_regexp, expression_regexp, parameter_types, generated_expressions); end
end

class Cucumber::CucumberExpressions::AmbiguousParameterTypeError
end

class Cucumber::CucumberExpressions::Argument
  def group(); end

  def initialize(group, parameter_type); end

  def parameter_type(); end

  def value(self_obj=T.unsafe(nil)); end
end

class Cucumber::CucumberExpressions::Argument
  def self.build(tree_regexp, text, parameter_types); end
end

class Cucumber::CucumberExpressions::CantEscape
  def initialize(expression, index); end
end

class Cucumber::CucumberExpressions::CantEscape
end

class Cucumber::CucumberExpressions::CombinatorialGeneratedExpressionFactory
  def generate_expressions(); end

  def generate_permutations(generated_expressions, depth, current_parameter_types); end

  def initialize(expression_template, parameter_type_combinations); end
  MAX_EXPRESSIONS = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::CombinatorialGeneratedExpressionFactory
end

class Cucumber::CucumberExpressions::CucumberExpression
  def initialize(expression, parameter_type_registry); end

  def match(text); end

  def regexp(); end

  def source(); end
  ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::CucumberExpression
end

class Cucumber::CucumberExpressions::CucumberExpressionError
  def build_message(index, expression, pointer, problem, solution); end

  def point_at(index); end

  def point_at_located(node); end
end

class Cucumber::CucumberExpressions::CucumberExpressionError
end

class Cucumber::CucumberExpressions::CucumberExpressionGenerator
  def generate_expressions(text); end

  def initialize(parameter_type_registry); end
end

class Cucumber::CucumberExpressions::CucumberExpressionGenerator
end

class Cucumber::CucumberExpressions::CucumberExpressionParser
  def parse(expression); end
end

class Cucumber::CucumberExpressions::CucumberExpressionParser
end

class Cucumber::CucumberExpressions::CucumberExpressionTokenizer
  def tokenize(expression); end
end

class Cucumber::CucumberExpressions::CucumberExpressionTokenizer
end

class Cucumber::CucumberExpressions::GeneratedExpression
  def initialize(expression_template, parameters_types); end

  def parameter_names(); end

  def parameter_types(); end

  def source(); end
end

class Cucumber::CucumberExpressions::GeneratedExpression
end

class Cucumber::CucumberExpressions::Group
  def children(); end

  def end(); end

  def initialize(value, start, _end, children); end

  def start(); end

  def value(); end

  def values(); end
end

class Cucumber::CucumberExpressions::Group
end

class Cucumber::CucumberExpressions::GroupBuilder
  def add(group_builder); end

  def build(match, group_indices); end

  def capturing?(); end

  def children(); end

  def move_children_to(group_builder); end

  def set_non_capturing!(); end

  def source(); end

  def source=(source); end
end

class Cucumber::CucumberExpressions::GroupBuilder
end

class Cucumber::CucumberExpressions::InvalidParameterTypeName
  def initialize(type_name); end
end

class Cucumber::CucumberExpressions::InvalidParameterTypeName
end

class Cucumber::CucumberExpressions::InvalidParameterTypeNameInNode
  def initialize(expression, token); end
end

class Cucumber::CucumberExpressions::InvalidParameterTypeNameInNode
end

class Cucumber::CucumberExpressions::MissingEndToken
  def initialize(expression, begin_token, end_token, current); end
end

class Cucumber::CucumberExpressions::MissingEndToken
end

class Cucumber::CucumberExpressions::Node
  def end(); end

  def initialize(type, nodes, token, start, ending); end

  def nodes(); end

  def start(); end

  def text(); end

  def to_hash(); end

  def token(); end

  def type(); end
end

class Cucumber::CucumberExpressions::Node
end

module Cucumber::CucumberExpressions::NodeType
  ALTERNATION = ::T.let(nil, ::T.untyped)
  ALTERNATIVE = ::T.let(nil, ::T.untyped)
  EXPRESSION = ::T.let(nil, ::T.untyped)
  OPTIONAL = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module Cucumber::CucumberExpressions::NodeType
end

class Cucumber::CucumberExpressions::OptionalIsNotAllowedInOptional
  def initialize(node, expression); end
end

class Cucumber::CucumberExpressions::OptionalIsNotAllowedInOptional
end

class Cucumber::CucumberExpressions::OptionalMayNotBeEmpty
  def initialize(node, expression); end
end

class Cucumber::CucumberExpressions::OptionalMayNotBeEmpty
end

class Cucumber::CucumberExpressions::ParameterIsNotAllowedInOptional
  def initialize(node, expression); end
end

class Cucumber::CucumberExpressions::ParameterIsNotAllowedInOptional
end

class Cucumber::CucumberExpressions::ParameterType
  def initialize(name, regexp, type, transformer, use_for_snippets, prefer_for_regexp_match); end

  def name(); end

  def prefer_for_regexp_match(); end

  def regexps(); end

  def transform(self_obj, group_values); end

  def transformer(); end

  def type(); end

  def use_for_snippets(); end
  ILLEGAL_PARAMETER_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  UNESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::ParameterType
  def self.check_parameter_type_name(type_name); end

  def self.is_valid_parameter_type_name(type_name); end
end

class Cucumber::CucumberExpressions::ParameterTypeMatcher
  def advance_to(new_match_position); end

  def find(); end

  def full_word?(); end

  def group(); end

  def initialize(parameter_type, regexp, text, match_position=T.unsafe(nil)); end

  def parameter_type(); end

  def start(); end
end

class Cucumber::CucumberExpressions::ParameterTypeMatcher
end

class Cucumber::CucumberExpressions::ParameterTypeRegistry
  def define_parameter_type(parameter_type); end

  def lookup_by_regexp(parameter_type_regexp, expression_regexp, text); end

  def lookup_by_type_name(name); end

  def parameter_types(); end
  ANONYMOUS_REGEXP = ::T.let(nil, ::T.untyped)
  FLOAT_REGEXP = ::T.let(nil, ::T.untyped)
  INTEGER_REGEXPS = ::T.let(nil, ::T.untyped)
  STRING_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_REGEXP = ::T.let(nil, ::T.untyped)
end

class Cucumber::CucumberExpressions::ParameterTypeRegistry
end

class Cucumber::CucumberExpressions::RegularExpression
  def initialize(expression_regexp, parameter_type_registry); end

  def match(text); end

  def regexp(); end

  def source(); end
end

class Cucumber::CucumberExpressions::RegularExpression
end

class Cucumber::CucumberExpressions::TheEndOfLineCannotBeEscaped
  def initialize(expression); end
end

class Cucumber::CucumberExpressions::TheEndOfLineCannotBeEscaped
end

class Cucumber::CucumberExpressions::Token
  def end(); end

  def initialize(type, text, start, ending); end

  def start(); end

  def text(); end

  def to_hash(); end

  def type(); end
end

class Cucumber::CucumberExpressions::Token
  def self.can_escape(codepoint); end

  def self.is_escape_character(codepoint); end

  def self.purpose_of(token); end

  def self.symbol_of(token); end

  def self.type_of(codepoint); end
end

module Cucumber::CucumberExpressions::TokenType
  ALTERNATION = ::T.let(nil, ::T.untyped)
  BEGIN_OPTIONAL = ::T.let(nil, ::T.untyped)
  BEGIN_PARAMETER = ::T.let(nil, ::T.untyped)
  END_OF_LINE = ::T.let(nil, ::T.untyped)
  END_OPTIONAL = ::T.let(nil, ::T.untyped)
  END_PARAMETER = ::T.let(nil, ::T.untyped)
  START_OF_LINE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WHITE_SPACE = ::T.let(nil, ::T.untyped)
end

module Cucumber::CucumberExpressions::TokenType
end

class Cucumber::CucumberExpressions::TreeRegexp
  def group_builder(); end

  def initialize(regexp); end

  def match(s); end

  def regexp(); end
end

class Cucumber::CucumberExpressions::TreeRegexp
end

class Cucumber::CucumberExpressions::UndefinedParameterTypeError
  def initialize(node, expression, undefined_parameter_type_name); end

  def undefined_parameter_type_name(); end
end

class Cucumber::CucumberExpressions::UndefinedParameterTypeError
end

module Cucumber::CucumberExpressions
end

module Cucumber::Events
end

class Cucumber::Events::Envelope
end

class Cucumber::Events::Envelope
end

class Cucumber::Events::GherkinSourceParsed
end

class Cucumber::Events::GherkinSourceParsed
end

class Cucumber::Events::GherkinSourceRead
end

class Cucumber::Events::GherkinSourceRead
end

class Cucumber::Events::HookTestStepCreated
end

class Cucumber::Events::HookTestStepCreated
end

class Cucumber::Events::StepActivated
end

class Cucumber::Events::StepActivated
end

class Cucumber::Events::StepDefinitionRegistered
end

class Cucumber::Events::StepDefinitionRegistered
end

class Cucumber::Events::TestCaseCreated
end

class Cucumber::Events::TestCaseCreated
end

class Cucumber::Events::TestCaseFinished
end

class Cucumber::Events::TestCaseFinished
end

class Cucumber::Events::TestCaseReady
end

class Cucumber::Events::TestCaseReady
end

class Cucumber::Events::TestCaseStarted
end

class Cucumber::Events::TestCaseStarted
end

class Cucumber::Events::TestRunFinished
end

class Cucumber::Events::TestRunFinished
end

class Cucumber::Events::TestRunStarted
end

class Cucumber::Events::TestRunStarted
end

class Cucumber::Events::TestStepCreated
end

class Cucumber::Events::TestStepCreated
end

class Cucumber::Events::TestStepFinished
end

class Cucumber::Events::TestStepFinished
end

class Cucumber::Events::TestStepStarted
end

class Cucumber::Events::TestStepStarted
end

class Cucumber::Events::UndefinedParameterType
end

class Cucumber::Events::UndefinedParameterType
end

module Cucumber::Events
  def self.make_event_bus(); end

  def self.registry(); end
end

class Cucumber::FeatureFolderNotFoundException
  def initialize(path); end
end

class Cucumber::FeatureFolderNotFoundException
end

class Cucumber::FileException
  def initialize(original_exception, path); end

  def path(); end
end

class Cucumber::FileException
end

class Cucumber::FileNotFoundException
end

class Cucumber::FileNotFoundException
end

class Cucumber::FileSpecs
  def files(); end

  def initialize(file_specs); end

  def locations(); end
  FILE_COLON_LINE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::FileSpecs::FileSpec
  def file(); end

  def initialize(spec); end

  def locations(); end
end

class Cucumber::FileSpecs::FileSpec
end

class Cucumber::FileSpecs
end

module Cucumber::Filters
end

class Cucumber::Filters::ActivateSteps
end

class Cucumber::Filters::ActivateSteps::CaseFilter
  def initialize(test_case, step_match_search, configuration); end

  def test_case(); end
end

class Cucumber::Filters::ActivateSteps::CaseFilter::FindMatch
  def initialize(step_match_search, configuration, test_step); end

  def result(); end
end

class Cucumber::Filters::ActivateSteps::CaseFilter::FindMatch
end

class Cucumber::Filters::ActivateSteps::CaseFilter
end

class Cucumber::Filters::ActivateSteps
end

class Cucumber::Filters::ApplyAfterHooks
end

class Cucumber::Filters::ApplyAfterHooks
end

class Cucumber::Filters::ApplyAfterStepHooks
end

class Cucumber::Filters::ApplyAfterStepHooks
end

class Cucumber::Filters::ApplyAroundHooks
end

class Cucumber::Filters::ApplyAroundHooks
end

class Cucumber::Filters::ApplyBeforeHooks
end

class Cucumber::Filters::ApplyBeforeHooks
end

class Cucumber::Filters::BroadcastTestCaseReadyEvent
end

class Cucumber::Filters::BroadcastTestCaseReadyEvent
end

class Cucumber::Filters::BroadcastTestRunStartedEvent
  def initialize(config, receiver=T.unsafe(nil)); end
end

class Cucumber::Filters::BroadcastTestRunStartedEvent
end

class Cucumber::Filters::GatedReceiver
  def done(); end

  def initialize(receiver); end

  def test_case(test_case); end
end

class Cucumber::Filters::GatedReceiver
end

class Cucumber::Filters::PrepareWorld
end

class Cucumber::Filters::PrepareWorld::CaseFilter
  def initialize(runtime, original_test_case); end

  def test_case(); end
end

class Cucumber::Filters::PrepareWorld::CaseFilter
end

class Cucumber::Filters::PrepareWorld
end

class Cucumber::Filters::Quit
  def done(); end

  def initialize(receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::Quit
end

class Cucumber::Filters::Randomizer
  def done(); end

  def initialize(seed, receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::Randomizer
end

class Cucumber::Filters::Retry
  def initialize(*_args); end
end

class Cucumber::Filters::Retry
end

class Cucumber::Filters::TagLimitExceededError
  def initialize(*limit_breaches); end
end

class Cucumber::Filters::TagLimitExceededError
end

class Cucumber::Filters::TagLimits
  def done(); end

  def initialize(tag_limits, receiver=T.unsafe(nil)); end

  def test_case(test_case); end

  def with_receiver(receiver); end
end

class Cucumber::Filters::TagLimits::TestCaseIndex
  def add(test_case); end

  def count_by_tag_name(tag_name); end

  def locations_of_tag_name(tag_name); end
end

class Cucumber::Filters::TagLimits::TestCaseIndex
end

class Cucumber::Filters::TagLimits::Verifier
  def initialize(tag_limits); end

  def verify!(test_case_index); end
end

class Cucumber::Filters::TagLimits::Verifier::Breach
  def initialize(tag_name, limit, locations); end
  INDENT = ::T.let(nil, ::T.untyped)
end

class Cucumber::Filters::TagLimits::Verifier::Breach
end

class Cucumber::Filters::TagLimits::Verifier
end

class Cucumber::Filters::TagLimits
end

module Cucumber::Filters
end

module Cucumber::FixRuby21Bug9285
  def message(); end
end

module Cucumber::FixRuby21Bug9285
end

module Cucumber::Formatter
end

module Cucumber::Formatter::ANSIColor
  include ::Cucumber::Term::ANSIColor
  def comment(text=T.unsafe(nil), &proc); end

  def comment_param(text=T.unsafe(nil), &proc); end

  def cukes(amount); end

  def failed(text=T.unsafe(nil), &proc); end

  def failed_param(text=T.unsafe(nil), &proc); end

  def flaky(text=T.unsafe(nil), &proc); end

  def flaky_param(text=T.unsafe(nil), &proc); end

  def green_cukes(amount); end

  def outline(text=T.unsafe(nil), &proc); end

  def outline_param(text=T.unsafe(nil), &proc); end

  def passed(text=T.unsafe(nil), &proc); end

  def passed_param(text=T.unsafe(nil), &proc); end

  def pending(text=T.unsafe(nil), &proc); end

  def pending_param(text=T.unsafe(nil), &proc); end

  def red_cukes(amount); end

  def skipped(text=T.unsafe(nil), &proc); end

  def skipped_param(text=T.unsafe(nil), &proc); end

  def tag(text=T.unsafe(nil), &proc); end

  def tag_param(text=T.unsafe(nil), &proc); end

  def undefined(text=T.unsafe(nil), &proc); end

  def undefined_param(text=T.unsafe(nil), &proc); end

  def yellow_cukes(amount); end
  ALIASES = ::T.let(nil, ::T.untyped)
end

module Cucumber::Formatter::ANSIColor
  def self.apply_custom_colors(colors); end
end

module Cucumber::Formatter::Console
  include ::Cucumber::Formatter::Duration
  def attach(src, media_type, filename); end

  def collect_snippet_data(test_step, ast_lookup); end

  def collect_undefined_parameter_type_names(undefined_parameter_type); end

  def do_print_passing_wip(passed_messages); end

  def do_print_profile_information(profiles); end

  def do_print_snippets(snippet_text_proc); end

  def do_print_undefined_parameter_type_snippet(type_name); end

  def exception_message_string(exception, indent_amount); end

  def format_step(keyword, step_match, status, source_indent); end

  def format_string(input, status); end

  def indent(string, padding); end

  def linebreaks(msg, max); end

  def print_element_messages(element_messages, status, kind); end

  def print_elements(elements, status, kind); end

  def print_exception(exception, status, indent); end

  def print_passing_wip(config, passed_test_cases, ast_lookup); end

  def print_profile_information(); end

  def print_snippets(options); end

  def print_statistics(duration, config, counts, issues); end
  FORMATS = ::T.let(nil, ::T.untyped)
end

class Cucumber::Formatter::Console::SnippetData
  def actual_keyword(); end

  def initialize(actual_keyword, step); end

  def step(); end
end

class Cucumber::Formatter::Console::SnippetData
end

module Cucumber::Formatter::Console
  extend ::Cucumber::Formatter::ANSIColor
  extend ::Cucumber::Term::ANSIColor
end

class Cucumber::Formatter::CurlOptionParser
end

class Cucumber::Formatter::CurlOptionParser
  def self.parse(options); end

  def self.parse_header(header_arg); end

  def self.remove_arg_for(args, arg); end
end

module Cucumber::Formatter::Duration
  def format_duration(seconds); end
end

module Cucumber::Formatter::Duration
end

class Cucumber::Formatter::FailFast
  def initialize(configuration); end
end

class Cucumber::Formatter::FailFast
end

class Cucumber::Formatter::Fanout
  def initialize(recipients); end

  def method_missing(message, *args); end
end

class Cucumber::Formatter::Fanout
end

class Cucumber::Formatter::HTTPIO
end

class Cucumber::Formatter::HTTPIO
  def self.open(url, https_verify_mode=T.unsafe(nil), reporter=T.unsafe(nil)); end
end

class Cucumber::Formatter::IOHTTPBuffer
  def close(); end

  def closed?(); end

  def flush(); end

  def headers(); end

  def initialize(uri, method, headers=T.unsafe(nil), https_verify_mode=T.unsafe(nil), reporter=T.unsafe(nil)); end

  def method(); end

  def uri(); end

  def write(data); end
end

class Cucumber::Formatter::IOHTTPBuffer
end

class Cucumber::Formatter::IgnoreMissingMessages
  def initialize(receiver); end

  def method_missing(message, *args); end
end

class Cucumber::Formatter::IgnoreMissingMessages
end

module Cucumber::Formatter::Io
end

module Cucumber::Formatter::Io::ClassMethods
  def new(*args, &block); end
end

module Cucumber::Formatter::Io::ClassMethods
end

module Cucumber::Formatter::Io
  def self.ensure_dir(path, name); end

  def self.ensure_file(path, name); end

  def self.ensure_io(path_or_url_or_io, error_stream); end

  def self.included(formatter_class); end

  def self.io?(path_or_url_or_io); end

  def self.url?(path_or_url_or_io); end
end

class Cucumber::Formatter::NoReporter
  def report(_banner); end
end

class Cucumber::Formatter::NoReporter
end

class Cucumber::Formatter::PublishBannerPrinter
  include ::Cucumber::Term::Banner
  def display_publish_ad(io); end

  def highlight(text); end

  def initialize(configuration); end

  def link(text); end

  def pre(text); end
end

class Cucumber::Formatter::PublishBannerPrinter
end

class Cucumber::Formatter::URLReporter
  def initialize(io); end

  def report(banner); end
end

class Cucumber::Formatter::URLReporter
end

module Cucumber::Formatter
end

module Cucumber::Gherkin
end

class Cucumber::Gherkin::DataTableParser
  def feature_header(); end

  def gherkin_options(); end

  def initialize(builder); end

  def parse(text); end
end

class Cucumber::Gherkin::DataTableParser
end

module Cucumber::Gherkin::Formatter
end

module Cucumber::Gherkin::Formatter::AnsiEscapes
  def comments(); end

  def comments_arg(); end

  def executing(); end

  def executing_arg(); end

  def failed(); end

  def failed_arg(); end

  def outline(); end

  def outline_arg(); end

  def passed(); end

  def passed_arg(); end

  def pending(); end

  def pending_arg(); end

  def reset(); end

  def skipped(); end

  def skipped_arg(); end

  def tag(); end

  def tag_arg(); end

  def undefined(); end

  def undefined_arg(); end

  def up(amount); end
  ALIASES = ::T.let(nil, ::T.untyped)
  COLORS = ::T.let(nil, ::T.untyped)
end

module Cucumber::Gherkin::Formatter::AnsiEscapes
end

module Cucumber::Gherkin::Formatter::Escaping
  def escape_cell(sym); end
end

module Cucumber::Gherkin::Formatter::Escaping
end

module Cucumber::Gherkin::Formatter
end

module Cucumber::Gherkin::I18n
end

module Cucumber::Gherkin::I18n
  def self.code_keyword_for(gherkin_keyword); end

  def self.code_keywords_for(gherkin_keywords); end
end

class Cucumber::Gherkin::StepsParser
  def feature_header(dialect); end

  def gherkin_options(); end

  def initialize(builder, language); end

  def parse(text); end
end

class Cucumber::Gherkin::StepsParser
end

module Cucumber::Gherkin
end

module Cucumber::Glue
end

class Cucumber::Glue::ArityMismatchError
end

class Cucumber::Glue::ArityMismatchError
end

module Cucumber::Glue::Dsl
  def A(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def AN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aber(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ac(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Adott(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def After(*tag_expressions, name: T.unsafe(nil), &proc); end

  def AfterAll(name: T.unsafe(nil), &proc); end

  def AfterStep(*tag_expressions, name: T.unsafe(nil), &proc); end

  def Agus(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Akkor(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Alavez(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ale(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aleshores(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ali(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Allgitout(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Allora(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Alors(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Als(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ama(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amennyiben(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amikor(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Amma(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ampak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def An(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ananging(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ancaq(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def And(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Angenommen(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Anrhegediga(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ansin(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Antonces(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Apabila(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Around(*tag_expressions, name: T.unsafe(nil), &proc); end

  def Ataktie(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atesa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atie(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Atunci(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ats(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Avast(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Aye(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Azrove(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def BUT(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bagi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Banjur(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Before(*tag_expressions, name: T.unsafe(nil), &proc); end

  def BeforeAll(name: T.unsafe(nil), &proc); end

  def Belgilangan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bet(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bila(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bit(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Blimey(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Buh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def But(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ButattheendofthedayIreckon(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bsealf(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bsealfa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Bsealfe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cal(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cand(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ce(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cho(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ciricw(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ciricwa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ciricwe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Comehellorhighwater(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcsgo(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcsgur(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcsnach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cuirigcsnr(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Cnd(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def DEN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def DaHghubejlu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadas(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadena(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dadeno(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dado(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dados(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daes(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daos(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Data(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Date(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datefiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datfiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dati(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Datfiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dau(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daus(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Daifiind(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def De(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dengan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Denyousegotta(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diasumsikan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diberi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diketahui(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Diyelimki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Do(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donc(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Donitao(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Dun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Duota(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Du(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def E(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ed(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Eeldades(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ef(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def En(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entao(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entonces(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ento(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Entn(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ents(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Epi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Et(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonn(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonne(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnes(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonnque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etantdonns(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Etque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Eerki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Fakat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Fixinto(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gangway(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gdy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegebensei(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegebenseien(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegeven(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gegewe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Gitt(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Given(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Givet(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Givun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ha(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Hm(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def I(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ICANHAZ(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def In(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def InstallPlugin(name: T.unsafe(nil), &proc); end

  def Ir(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Itsjustunbelievable(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ja(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jeli(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jeeli(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Jika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kad(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kadar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kai(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kaj(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kdy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kemudian(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ketika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ke(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Khi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kiedy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ko(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Koga(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Komence(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kui(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kuid(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Kun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Le(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lesaa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Letgoandhaul(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Logo(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lorsqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lorsque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def L(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Lsaa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ma(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mais(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maisqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maisque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Majd(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Majc(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Maka(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Manawa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mas(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Men(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Menawa(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Mutta(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nalika(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nalikaning(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nanging(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nhng(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Niin(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Njuk(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def No(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuaira(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairba(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairnach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nuairnr(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nr(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nr(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Nvaxtki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Och(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Og(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ohalda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Oletetaan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ond(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Onda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Oraz(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ozaman(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ParameterType(options); end

  def Pero(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Peru(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Per(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Podano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pokia(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pokud(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Potem(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Potom(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Privzeto(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Pryd(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quand(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quando(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Quickoutofthechute(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachant(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachantqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sachantque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Se(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sed(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Si(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Siis(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sipoze(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def SipozeKe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Sipozeke(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Soit(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Stel(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def S(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tad(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tada(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tak(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Takrat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tapi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ter(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tetapi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tha(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Thathe(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Then(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Thurh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Th(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Toda(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Togash(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tooright(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Tutaqki(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ukoliko(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Un(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Und(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ve(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Vendar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Verilir(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def V(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def V(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def WEN(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wanneer(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def WellnowholdonIllyouwhat(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wenn(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def When(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def World(*world_modules, **namespaced_world_modules, &proc); end

  def Wtedy(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Wun(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Y(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Ya(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yeahnah(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yknow(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Yna(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Youseknowlikewhen(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Youseknowwhenyousegot(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadan(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadani(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadano(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadate(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadati(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zadato(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zakadajc(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zakadajce(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zapredpokladu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zapedpokladu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zaradi(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def Zatim(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def a(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ach(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def an(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def awer(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def dann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ej(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ghunoblu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def if_nil(value, default); end

  def latlh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def m(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def qaSDI(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def register_rb_step_definition(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ugeholl(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def vaj(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def wann(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def s(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonn(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonne(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonnes(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonnqu(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonnque(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def tantdonns(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def a(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ae(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def urh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def a(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def ae(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def egar(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def urh(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def e(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def i(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def gr(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def i(regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end

  def (regexp, symbol=T.unsafe(nil), options=T.unsafe(nil), &proc); end
end

module Cucumber::Glue::Dsl
  def self.alias_adverb(adverb); end

  def self.build_rb_world_factory(world_modules, namespaced_world_modules, proc); end

  def self.define_parameter_type(parameter_type); end

  def self.rb_language=(rb_language); end

  def self.register_rb_hook(type, tag_names, proc, name: T.unsafe(nil)); end

  def self.register_rb_step_definition(regexp, proc_or_sym, options=T.unsafe(nil)); end
end

class Cucumber::Glue::Hook
  def id(); end

  def initialize(id, registry, tag_expressions, proc, name: T.unsafe(nil)); end

  def invoke(pseudo_method, arguments, &block); end

  def location(); end

  def name(); end

  def tag_expressions(); end

  def to_envelope(type); end
end

class Cucumber::Glue::Hook
end

class Cucumber::Glue::InvokeInWorld
  INSTANCE_EXEC_OFFSET = ::T.let(nil, ::T.untyped)
end

class Cucumber::Glue::InvokeInWorld
  def self.cucumber_compatible_arity?(args, block); end

  def self.cucumber_instance_exec_in(world, check_arity, pseudo_method, *args, &block); end

  def self.cucumber_run_with_backtrace_filtering(pseudo_method); end

  def self.replace_instance_exec_invocation_line!(backtrace, instance_exec_invocation_line, pseudo_method); end
end

class Cucumber::Glue::MultipleWorld
  def initialize(first_proc, second_proc); end
end

class Cucumber::Glue::MultipleWorld
end

class Cucumber::Glue::NilWorld
  def initialize(); end
end

class Cucumber::Glue::NilWorld
end

module Cucumber::Glue::ProtoWorld
  def ask(question, timeout_seconds=T.unsafe(nil)); end

  def attach(file, media_type=T.unsafe(nil), filename=T.unsafe(nil)); end

  def inspect(); end

  def log(*messages); end

  def pending(message=T.unsafe(nil)); end

  def skip_this_scenario(message=T.unsafe(nil)); end

  def step(name, raw_multiline_arg=T.unsafe(nil)); end

  def steps(steps_text); end

  def table(text_or_table); end

  def to_s(); end
end

Cucumber::Glue::ProtoWorld::AnsiEscapes = Cucumber::Gherkin::Formatter::AnsiEscapes

module Cucumber::Glue::ProtoWorld
  def self.for(runtime, language); end
end

class Cucumber::Glue::RegistryAndMore
  def add_hook(type, hook); end

  def after_all(); end

  def before_all(); end

  def begin_scenario(test_case); end

  def build_rb_world_factory(world_modules, namespaced_world_modules, proc); end

  def clear_hooks(); end

  def create_expression(string_or_regexp); end

  def current_world(); end

  def define_parameter_type(parameter_type); end

  def end_scenario(); end

  def hooks_for(type, scenario); end

  def initialize(runtime, configuration); end

  def install_plugin(configuration, registry); end

  def load_code_file(code_file); end

  def register_rb_hook(type, tag_expressions, proc, name: T.unsafe(nil)); end

  def register_rb_step_definition(string_or_regexp, proc_or_sym, options); end

  def step_definitions(); end

  def step_matches(name_to_match); end
end

class Cucumber::Glue::RegistryAndMore
  def self.cli_snippet_type_options(); end
end

class Cucumber::Glue::RegistryWrapper
  def create_expression(string_or_regexp); end

  def current_world(); end

  def initialize(registry); end
end

class Cucumber::Glue::RegistryWrapper
end

module Cucumber::Glue::Snippet
  ARGUMENT_PATTERNS = ::T.let(nil, ::T.untyped)
  SNIPPET_TYPES = ::T.let(nil, ::T.untyped)
end

class Cucumber::Glue::Snippet::BaseSnippet
  def initialize(cucumber_expression_generator, code_keyword, step_name, multiline_argument); end

  def step(); end
end

class Cucumber::Glue::Snippet::BaseSnippet
  def self.cli_option_string(type, cucumber_expression_generator); end
end

class Cucumber::Glue::Snippet::Classic
  def typed_pattern(); end
end

class Cucumber::Glue::Snippet::Classic
  def self.description(); end
end

class Cucumber::Glue::Snippet::CucumberExpression
  def parameters(expr); end

  def typed_pattern(); end
end

class Cucumber::Glue::Snippet::CucumberExpression
  def self.description(); end
end

class Cucumber::Glue::Snippet::Generator
  def call(code_keyword, step_name, multiline_arg, snippet_type); end

  def initialize(cucumber_expression_generator); end

  def typed_snippet_class(type); end
end

class Cucumber::Glue::Snippet::Generator
  def self.register_on(configuration); end
end

module Cucumber::Glue::Snippet::MultilineArgumentSnippet
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::Builder
  def data_table(table, *_args); end

  def doc_string(*_args); end

  def result(); end
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::Builder
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DataTable
  def append_block_parameter_to(array); end

  def comment(); end

  def initialize(table); end
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DataTable
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DocString
  def append_block_parameter_to(array); end

  def comment(); end
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::DocString
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::None
  def append_block_parameter_to(array); end

  def comment(); end
end

class Cucumber::Glue::Snippet::MultilineArgumentSnippet::None
end

module Cucumber::Glue::Snippet::MultilineArgumentSnippet
  def self.new(multiline_argument); end
end

class Cucumber::Glue::Snippet::Percent
  def typed_pattern(); end
end

class Cucumber::Glue::Snippet::Percent
  def self.description(); end
end

class Cucumber::Glue::Snippet::Regexp
  def typed_pattern(); end
end

class Cucumber::Glue::Snippet::Regexp
  def self.description(); end
end

module Cucumber::Glue::Snippet
end

class Cucumber::Glue::StepDefinition
  def ==(other); end

  def arguments_from(step_name); end

  def backtrace_line(); end

  def expression(); end

  def expression_type(); end

  def file(); end

  def file_colon_line(); end

  def id(); end

  def initialize(id, registry, expression, proc); end

  def invoke(args); end

  def location(); end

  def registry(); end

  def to_envelope(); end

  def to_hash(); end
end

class Cucumber::Glue::StepDefinition::MissingProc
end

class Cucumber::Glue::StepDefinition::MissingProc
end

class Cucumber::Glue::StepDefinition
  def self.new(id, registry, string_or_regexp, proc_or_sym, options); end
end

class Cucumber::Glue::WorldFactory
  def create_world(); end

  def initialize(proc); end

  def raise_nil_world(); end
end

class Cucumber::Glue::WorldFactory
end

module Cucumber::Glue
  def self.backtrace_line(proc, name); end
end

module Cucumber::Hooks
end

class Cucumber::Hooks::AfterHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::AfterHook
end

class Cucumber::Hooks::AfterStepHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::AfterStepHook
end

class Cucumber::Hooks::BeforeHook
  def describe_to(visitor, *args); end

  def initialize(location); end

  def location(); end

  def match_locations?(queried_locations); end

  def text(); end
end

class Cucumber::Hooks::BeforeHook
end

module Cucumber::Hooks
  def self.after_hook(id, location, &block); end

  def self.after_step_hook(id, test_step, location, &block); end

  def self.around_hook(&block); end

  def self.before_hook(id, location, &block); end
end

module Cucumber::LoadPath
end

module Cucumber::LoadPath
  def self.add_dirs(*dirs); end
end

module Cucumber::Messages
  VERSION = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::Attachment
  def body(); end

  def content_encoding(); end

  def file_name(); end

  def initialize(body: T.unsafe(nil), content_encoding: T.unsafe(nil), file_name: T.unsafe(nil), media_type: T.unsafe(nil), source: T.unsafe(nil), test_case_started_id: T.unsafe(nil), test_step_id: T.unsafe(nil), url: T.unsafe(nil), test_run_started_id: T.unsafe(nil), test_run_hook_started_id: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def media_type(); end

  def source(); end

  def test_case_started_id(); end

  def test_run_hook_started_id(); end

  def test_run_started_id(); end

  def test_step_id(); end

  def timestamp(); end

  def url(); end
end

class Cucumber::Messages::Attachment
  def self.from_h(hash); end
end

class Cucumber::Messages::AttachmentContentEncoding
  BASE64 = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::AttachmentContentEncoding
end

class Cucumber::Messages::Background
  def description(); end

  def id(); end

  def initialize(location: T.unsafe(nil), keyword: T.unsafe(nil), name: T.unsafe(nil), description: T.unsafe(nil), steps: T.unsafe(nil), id: T.unsafe(nil)); end

  def keyword(); end

  def location(); end

  def name(); end

  def steps(); end
end

class Cucumber::Messages::Background
  def self.from_h(hash); end
end

class Cucumber::Messages::Ci
  def build_number(); end

  def git(); end

  def initialize(name: T.unsafe(nil), url: T.unsafe(nil), build_number: T.unsafe(nil), git: T.unsafe(nil)); end

  def name(); end

  def url(); end
end

class Cucumber::Messages::Ci
  def self.from_h(hash); end
end

class Cucumber::Messages::Comment
  def initialize(location: T.unsafe(nil), text: T.unsafe(nil)); end

  def location(); end

  def text(); end
end

class Cucumber::Messages::Comment
  def self.from_h(hash); end
end

class Cucumber::Messages::DataTable
  def initialize(location: T.unsafe(nil), rows: T.unsafe(nil)); end

  def location(); end

  def rows(); end
end

class Cucumber::Messages::DataTable
  def self.from_h(hash); end
end

class Cucumber::Messages::DocString
  def content(); end

  def delimiter(); end

  def initialize(location: T.unsafe(nil), media_type: T.unsafe(nil), content: T.unsafe(nil), delimiter: T.unsafe(nil)); end

  def location(); end

  def media_type(); end
end

class Cucumber::Messages::DocString
  def self.from_h(hash); end
end

class Cucumber::Messages::Duration
  def initialize(seconds: T.unsafe(nil), nanos: T.unsafe(nil)); end

  def nanos(); end

  def seconds(); end
end

class Cucumber::Messages::Duration
  def self.from_h(hash); end
end

class Cucumber::Messages::Envelope
  def attachment(); end

  def external_attachment(); end

  def gherkin_document(); end

  def hook(); end

  def initialize(attachment: T.unsafe(nil), external_attachment: T.unsafe(nil), gherkin_document: T.unsafe(nil), hook: T.unsafe(nil), meta: T.unsafe(nil), parameter_type: T.unsafe(nil), parse_error: T.unsafe(nil), pickle: T.unsafe(nil), suggestion: T.unsafe(nil), source: T.unsafe(nil), step_definition: T.unsafe(nil), test_case: T.unsafe(nil), test_case_finished: T.unsafe(nil), test_case_started: T.unsafe(nil), test_run_finished: T.unsafe(nil), test_run_started: T.unsafe(nil), test_step_finished: T.unsafe(nil), test_step_started: T.unsafe(nil), test_run_hook_started: T.unsafe(nil), test_run_hook_finished: T.unsafe(nil), undefined_parameter_type: T.unsafe(nil)); end

  def meta(); end

  def parameter_type(); end

  def parse_error(); end

  def pickle(); end

  def source(); end

  def step_definition(); end

  def suggestion(); end

  def test_case(); end

  def test_case_finished(); end

  def test_case_started(); end

  def test_run_finished(); end

  def test_run_hook_finished(); end

  def test_run_hook_started(); end

  def test_run_started(); end

  def test_step_finished(); end

  def test_step_started(); end

  def undefined_parameter_type(); end
end

class Cucumber::Messages::Envelope
  def self.from_h(hash); end
end

class Cucumber::Messages::Examples
  def description(); end

  def id(); end

  def initialize(location: T.unsafe(nil), tags: T.unsafe(nil), keyword: T.unsafe(nil), name: T.unsafe(nil), description: T.unsafe(nil), table_header: T.unsafe(nil), table_body: T.unsafe(nil), id: T.unsafe(nil)); end

  def keyword(); end

  def location(); end

  def name(); end

  def table_body(); end

  def table_header(); end

  def tags(); end
end

class Cucumber::Messages::Examples
  def self.from_h(hash); end
end

class Cucumber::Messages::Exception
  def initialize(type: T.unsafe(nil), message: T.unsafe(nil), stack_trace: T.unsafe(nil)); end

  def message(); end

  def stack_trace(); end

  def type(); end
end

class Cucumber::Messages::Exception
  def self.from_h(hash); end
end

class Cucumber::Messages::ExternalAttachment
  def initialize(url: T.unsafe(nil), media_type: T.unsafe(nil), test_case_started_id: T.unsafe(nil), test_step_id: T.unsafe(nil), test_run_hook_started_id: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def media_type(); end

  def test_case_started_id(); end

  def test_run_hook_started_id(); end

  def test_step_id(); end

  def timestamp(); end

  def url(); end
end

class Cucumber::Messages::ExternalAttachment
  def self.from_h(hash); end
end

class Cucumber::Messages::Feature
  def children(); end

  def description(); end

  def initialize(location: T.unsafe(nil), tags: T.unsafe(nil), language: T.unsafe(nil), keyword: T.unsafe(nil), name: T.unsafe(nil), description: T.unsafe(nil), children: T.unsafe(nil)); end

  def keyword(); end

  def language(); end

  def location(); end

  def name(); end

  def tags(); end
end

class Cucumber::Messages::Feature
  def self.from_h(hash); end
end

class Cucumber::Messages::FeatureChild
  def background(); end

  def initialize(rule: T.unsafe(nil), background: T.unsafe(nil), scenario: T.unsafe(nil)); end

  def rule(); end

  def scenario(); end
end

class Cucumber::Messages::FeatureChild
  def self.from_h(hash); end
end

class Cucumber::Messages::GherkinDocument
  def comments(); end

  def feature(); end

  def initialize(uri: T.unsafe(nil), feature: T.unsafe(nil), comments: T.unsafe(nil)); end

  def uri(); end
end

class Cucumber::Messages::GherkinDocument
  def self.from_h(hash); end
end

class Cucumber::Messages::Git
  def branch(); end

  def initialize(remote: T.unsafe(nil), revision: T.unsafe(nil), branch: T.unsafe(nil), tag: T.unsafe(nil)); end

  def remote(); end

  def revision(); end

  def tag(); end
end

class Cucumber::Messages::Git
  def self.from_h(hash); end
end

class Cucumber::Messages::Group
  def children(); end

  def initialize(children: T.unsafe(nil), start: T.unsafe(nil), value: T.unsafe(nil)); end

  def start(); end

  def value(); end
end

class Cucumber::Messages::Group
  def self.from_h(hash); end
end

module Cucumber::Messages::Helpers
end

module Cucumber::Messages::Helpers::IdGenerator
end

class Cucumber::Messages::Helpers::IdGenerator::Incrementing
  def new_id(); end
end

class Cucumber::Messages::Helpers::IdGenerator::Incrementing
end

class Cucumber::Messages::Helpers::IdGenerator::UUID
  def new_id(); end
end

class Cucumber::Messages::Helpers::IdGenerator::UUID
end

module Cucumber::Messages::Helpers::IdGenerator
end

class Cucumber::Messages::Helpers::NdjsonToMessageEnumerator
  def initialize(io); end
end

class Cucumber::Messages::Helpers::NdjsonToMessageEnumerator
end

module Cucumber::Messages::Helpers::TestStepResultComparator
  def test_step_result_rankings(); end
end

module Cucumber::Messages::Helpers::TestStepResultComparator
end

module Cucumber::Messages::Helpers::TimeConversion
  def time_to_timestamp(time); end

  def timestamp_to_time(timestamp); end
  NANOSECONDS_PER_SECOND = ::T.let(nil, ::T.untyped)
end

module Cucumber::Messages::Helpers::TimeConversion
end

module Cucumber::Messages::Helpers
end

class Cucumber::Messages::Hook
  def id(); end

  def initialize(id: T.unsafe(nil), name: T.unsafe(nil), source_reference: T.unsafe(nil), tag_expression: T.unsafe(nil), type: T.unsafe(nil)); end

  def name(); end

  def source_reference(); end

  def tag_expression(); end

  def type(); end
end

class Cucumber::Messages::Hook
  def self.from_h(hash); end
end

class Cucumber::Messages::HookType
  AFTER_TEST_CASE = ::T.let(nil, ::T.untyped)
  AFTER_TEST_RUN = ::T.let(nil, ::T.untyped)
  AFTER_TEST_STEP = ::T.let(nil, ::T.untyped)
  BEFORE_TEST_CASE = ::T.let(nil, ::T.untyped)
  BEFORE_TEST_RUN = ::T.let(nil, ::T.untyped)
  BEFORE_TEST_STEP = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::HookType
end

class Cucumber::Messages::JavaMethod
  def class_name(); end

  def initialize(class_name: T.unsafe(nil), method_name: T.unsafe(nil), method_parameter_types: T.unsafe(nil)); end

  def method_name(); end

  def method_parameter_types(); end
end

class Cucumber::Messages::JavaMethod
  def self.from_h(hash); end
end

class Cucumber::Messages::JavaStackTraceElement
  def class_name(); end

  def file_name(); end

  def initialize(class_name: T.unsafe(nil), file_name: T.unsafe(nil), method_name: T.unsafe(nil)); end

  def method_name(); end
end

class Cucumber::Messages::JavaStackTraceElement
  def self.from_h(hash); end
end

class Cucumber::Messages::Location
  def column(); end

  def initialize(line: T.unsafe(nil), column: T.unsafe(nil)); end

  def line(); end
end

class Cucumber::Messages::Location
  def self.from_h(hash); end
end

class Cucumber::Messages::Message
  def to_h(camelize: T.unsafe(nil), reject_nil_values: T.unsafe(nil)); end

  def to_json(*_args); end
end

class Cucumber::Messages::Message
  def self.camelize(term); end

  def self.from_json(json_string); end
end

class Cucumber::Messages::Meta
  def ci(); end

  def cpu(); end

  def implementation(); end

  def initialize(protocol_version: T.unsafe(nil), implementation: T.unsafe(nil), runtime: T.unsafe(nil), os: T.unsafe(nil), cpu: T.unsafe(nil), ci: T.unsafe(nil)); end

  def os(); end

  def protocol_version(); end

  def runtime(); end
end

class Cucumber::Messages::Meta
  def self.from_h(hash); end
end

class Cucumber::Messages::ParameterType
  def id(); end

  def initialize(name: T.unsafe(nil), regular_expressions: T.unsafe(nil), prefer_for_regular_expression_match: T.unsafe(nil), use_for_snippets: T.unsafe(nil), id: T.unsafe(nil), source_reference: T.unsafe(nil)); end

  def name(); end

  def prefer_for_regular_expression_match(); end

  def regular_expressions(); end

  def source_reference(); end

  def use_for_snippets(); end
end

class Cucumber::Messages::ParameterType
  def self.from_h(hash); end
end

class Cucumber::Messages::ParseError
  def initialize(source: T.unsafe(nil), message: T.unsafe(nil)); end

  def message(); end

  def source(); end
end

class Cucumber::Messages::ParseError
  def self.from_h(hash); end
end

class Cucumber::Messages::Pickle
  def ast_node_ids(); end

  def id(); end

  def initialize(id: T.unsafe(nil), uri: T.unsafe(nil), location: T.unsafe(nil), name: T.unsafe(nil), language: T.unsafe(nil), steps: T.unsafe(nil), tags: T.unsafe(nil), ast_node_ids: T.unsafe(nil)); end

  def language(); end

  def location(); end

  def name(); end

  def steps(); end

  def tags(); end

  def uri(); end
end

class Cucumber::Messages::Pickle
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleDocString
  def content(); end

  def initialize(media_type: T.unsafe(nil), content: T.unsafe(nil)); end

  def media_type(); end
end

class Cucumber::Messages::PickleDocString
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleStep
  def argument(); end

  def ast_node_ids(); end

  def id(); end

  def initialize(argument: T.unsafe(nil), ast_node_ids: T.unsafe(nil), id: T.unsafe(nil), type: T.unsafe(nil), text: T.unsafe(nil)); end

  def text(); end

  def type(); end
end

class Cucumber::Messages::PickleStep
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleStepArgument
  def data_table(); end

  def doc_string(); end

  def initialize(doc_string: T.unsafe(nil), data_table: T.unsafe(nil)); end
end

class Cucumber::Messages::PickleStepArgument
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleStepType
  ACTION = ::T.let(nil, ::T.untyped)
  CONTEXT = ::T.let(nil, ::T.untyped)
  OUTCOME = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::PickleStepType
end

class Cucumber::Messages::PickleTable
  def initialize(rows: T.unsafe(nil)); end

  def rows(); end
end

class Cucumber::Messages::PickleTable
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleTableCell
  def initialize(value: T.unsafe(nil)); end

  def value(); end
end

class Cucumber::Messages::PickleTableCell
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleTableRow
  def cells(); end

  def initialize(cells: T.unsafe(nil)); end
end

class Cucumber::Messages::PickleTableRow
  def self.from_h(hash); end
end

class Cucumber::Messages::PickleTag
  def ast_node_id(); end

  def initialize(name: T.unsafe(nil), ast_node_id: T.unsafe(nil)); end

  def name(); end
end

class Cucumber::Messages::PickleTag
  def self.from_h(hash); end
end

class Cucumber::Messages::Product
  def initialize(name: T.unsafe(nil), version: T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Cucumber::Messages::Product
  def self.from_h(hash); end
end

class Cucumber::Messages::Rule
  def children(); end

  def description(); end

  def id(); end

  def initialize(location: T.unsafe(nil), tags: T.unsafe(nil), keyword: T.unsafe(nil), name: T.unsafe(nil), description: T.unsafe(nil), children: T.unsafe(nil), id: T.unsafe(nil)); end

  def keyword(); end

  def location(); end

  def name(); end

  def tags(); end
end

class Cucumber::Messages::Rule
  def self.from_h(hash); end
end

class Cucumber::Messages::RuleChild
  def background(); end

  def initialize(background: T.unsafe(nil), scenario: T.unsafe(nil)); end

  def scenario(); end
end

class Cucumber::Messages::RuleChild
  def self.from_h(hash); end
end

class Cucumber::Messages::Scenario
  def description(); end

  def examples(); end

  def id(); end

  def initialize(location: T.unsafe(nil), tags: T.unsafe(nil), keyword: T.unsafe(nil), name: T.unsafe(nil), description: T.unsafe(nil), steps: T.unsafe(nil), examples: T.unsafe(nil), id: T.unsafe(nil)); end

  def keyword(); end

  def location(); end

  def name(); end

  def steps(); end

  def tags(); end
end

class Cucumber::Messages::Scenario
  def self.from_h(hash); end
end

class Cucumber::Messages::Snippet
  def code(); end

  def initialize(language: T.unsafe(nil), code: T.unsafe(nil)); end

  def language(); end
end

class Cucumber::Messages::Snippet
  def self.from_h(hash); end
end

class Cucumber::Messages::Source
  def data(); end

  def initialize(uri: T.unsafe(nil), data: T.unsafe(nil), media_type: T.unsafe(nil)); end

  def media_type(); end

  def uri(); end
end

class Cucumber::Messages::Source
  def self.from_h(hash); end
end

class Cucumber::Messages::SourceMediaType
  TEXT_X_CUCUMBER_GHERKIN_MARKDOWN = ::T.let(nil, ::T.untyped)
  TEXT_X_CUCUMBER_GHERKIN_PLAIN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::SourceMediaType
end

class Cucumber::Messages::SourceReference
  def initialize(uri: T.unsafe(nil), java_method: T.unsafe(nil), java_stack_trace_element: T.unsafe(nil), location: T.unsafe(nil)); end

  def java_method(); end

  def java_stack_trace_element(); end

  def location(); end

  def uri(); end
end

class Cucumber::Messages::SourceReference
  def self.from_h(hash); end
end

class Cucumber::Messages::Step
  def data_table(); end

  def doc_string(); end

  def id(); end

  def initialize(location: T.unsafe(nil), keyword: T.unsafe(nil), keyword_type: T.unsafe(nil), text: T.unsafe(nil), doc_string: T.unsafe(nil), data_table: T.unsafe(nil), id: T.unsafe(nil)); end

  def keyword(); end

  def keyword_type(); end

  def location(); end

  def text(); end
end

class Cucumber::Messages::Step
  def self.from_h(hash); end
end

class Cucumber::Messages::StepDefinition
  def id(); end

  def initialize(id: T.unsafe(nil), pattern: T.unsafe(nil), source_reference: T.unsafe(nil)); end

  def pattern(); end

  def source_reference(); end
end

class Cucumber::Messages::StepDefinition
  def self.from_h(hash); end
end

class Cucumber::Messages::StepDefinitionPattern
  def initialize(source: T.unsafe(nil), type: T.unsafe(nil)); end

  def source(); end

  def type(); end
end

class Cucumber::Messages::StepDefinitionPattern
  def self.from_h(hash); end
end

class Cucumber::Messages::StepDefinitionPatternType
  CUCUMBER_EXPRESSION = ::T.let(nil, ::T.untyped)
  REGULAR_EXPRESSION = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::StepDefinitionPatternType
end

class Cucumber::Messages::StepKeywordType
  ACTION = ::T.let(nil, ::T.untyped)
  CONJUNCTION = ::T.let(nil, ::T.untyped)
  CONTEXT = ::T.let(nil, ::T.untyped)
  OUTCOME = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::StepKeywordType
end

class Cucumber::Messages::StepMatchArgument
  def group(); end

  def initialize(group: T.unsafe(nil), parameter_type_name: T.unsafe(nil)); end

  def parameter_type_name(); end
end

class Cucumber::Messages::StepMatchArgument
  def self.from_h(hash); end
end

class Cucumber::Messages::StepMatchArgumentsList
  def initialize(step_match_arguments: T.unsafe(nil)); end

  def step_match_arguments(); end
end

class Cucumber::Messages::StepMatchArgumentsList
  def self.from_h(hash); end
end

class Cucumber::Messages::Suggestion
  def id(); end

  def initialize(id: T.unsafe(nil), pickle_step_id: T.unsafe(nil), snippets: T.unsafe(nil)); end

  def pickle_step_id(); end

  def snippets(); end
end

class Cucumber::Messages::Suggestion
  def self.from_h(hash); end
end

class Cucumber::Messages::TableCell
  def initialize(location: T.unsafe(nil), value: T.unsafe(nil)); end

  def location(); end

  def value(); end
end

class Cucumber::Messages::TableCell
  def self.from_h(hash); end
end

class Cucumber::Messages::TableRow
  def cells(); end

  def id(); end

  def initialize(location: T.unsafe(nil), cells: T.unsafe(nil), id: T.unsafe(nil)); end

  def location(); end
end

class Cucumber::Messages::TableRow
  def self.from_h(hash); end
end

class Cucumber::Messages::Tag
  def id(); end

  def initialize(location: T.unsafe(nil), name: T.unsafe(nil), id: T.unsafe(nil)); end

  def location(); end

  def name(); end
end

class Cucumber::Messages::Tag
  def self.from_h(hash); end
end

class Cucumber::Messages::TestCase
  def id(); end

  def initialize(id: T.unsafe(nil), pickle_id: T.unsafe(nil), test_steps: T.unsafe(nil), test_run_started_id: T.unsafe(nil)); end

  def pickle_id(); end

  def test_run_started_id(); end

  def test_steps(); end
end

class Cucumber::Messages::TestCase
  def self.from_h(hash); end
end

class Cucumber::Messages::TestCaseFinished
  def initialize(test_case_started_id: T.unsafe(nil), timestamp: T.unsafe(nil), will_be_retried: T.unsafe(nil)); end

  def test_case_started_id(); end

  def timestamp(); end

  def will_be_retried(); end
end

class Cucumber::Messages::TestCaseFinished
  def self.from_h(hash); end
end

class Cucumber::Messages::TestCaseStarted
  def attempt(); end

  def id(); end

  def initialize(attempt: T.unsafe(nil), id: T.unsafe(nil), test_case_id: T.unsafe(nil), worker_id: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def test_case_id(); end

  def timestamp(); end

  def worker_id(); end
end

class Cucumber::Messages::TestCaseStarted
  def self.from_h(hash); end
end

class Cucumber::Messages::TestRunFinished
  def exception(); end

  def initialize(message: T.unsafe(nil), success: T.unsafe(nil), timestamp: T.unsafe(nil), exception: T.unsafe(nil), test_run_started_id: T.unsafe(nil)); end

  def message(); end

  def success(); end

  def test_run_started_id(); end

  def timestamp(); end
end

class Cucumber::Messages::TestRunFinished
  def self.from_h(hash); end
end

class Cucumber::Messages::TestRunHookFinished
  def initialize(test_run_hook_started_id: T.unsafe(nil), result: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def result(); end

  def test_run_hook_started_id(); end

  def timestamp(); end
end

class Cucumber::Messages::TestRunHookFinished
  def self.from_h(hash); end
end

class Cucumber::Messages::TestRunHookStarted
  def hook_id(); end

  def id(); end

  def initialize(id: T.unsafe(nil), test_run_started_id: T.unsafe(nil), hook_id: T.unsafe(nil), worker_id: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def test_run_started_id(); end

  def timestamp(); end

  def worker_id(); end
end

class Cucumber::Messages::TestRunHookStarted
  def self.from_h(hash); end
end

class Cucumber::Messages::TestRunStarted
  def id(); end

  def initialize(timestamp: T.unsafe(nil), id: T.unsafe(nil)); end

  def timestamp(); end
end

class Cucumber::Messages::TestRunStarted
  def self.from_h(hash); end
end

class Cucumber::Messages::TestStep
  def hook_id(); end

  def id(); end

  def initialize(hook_id: T.unsafe(nil), id: T.unsafe(nil), pickle_step_id: T.unsafe(nil), step_definition_ids: T.unsafe(nil), step_match_arguments_lists: T.unsafe(nil)); end

  def pickle_step_id(); end

  def step_definition_ids(); end

  def step_match_arguments_lists(); end
end

class Cucumber::Messages::TestStep
  def self.from_h(hash); end
end

class Cucumber::Messages::TestStepFinished
  def initialize(test_case_started_id: T.unsafe(nil), test_step_id: T.unsafe(nil), test_step_result: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def test_case_started_id(); end

  def test_step_id(); end

  def test_step_result(); end

  def timestamp(); end
end

class Cucumber::Messages::TestStepFinished
  def self.from_h(hash); end
end

class Cucumber::Messages::TestStepResult
  def duration(); end

  def exception(); end

  def initialize(duration: T.unsafe(nil), message: T.unsafe(nil), status: T.unsafe(nil), exception: T.unsafe(nil)); end

  def message(); end

  def status(); end
end

class Cucumber::Messages::TestStepResult
  def self.from_h(hash); end
end

class Cucumber::Messages::TestStepResultStatus
  AMBIGUOUS = ::T.let(nil, ::T.untyped)
  FAILED = ::T.let(nil, ::T.untyped)
  PASSED = ::T.let(nil, ::T.untyped)
  PENDING = ::T.let(nil, ::T.untyped)
  SKIPPED = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Messages::TestStepResultStatus
end

class Cucumber::Messages::TestStepStarted
  def initialize(test_case_started_id: T.unsafe(nil), test_step_id: T.unsafe(nil), timestamp: T.unsafe(nil)); end

  def test_case_started_id(); end

  def test_step_id(); end

  def timestamp(); end
end

class Cucumber::Messages::TestStepStarted
  def self.from_h(hash); end
end

class Cucumber::Messages::Timestamp
  def initialize(seconds: T.unsafe(nil), nanos: T.unsafe(nil)); end

  def nanos(); end

  def seconds(); end
end

class Cucumber::Messages::Timestamp
  def self.from_h(hash); end
end

class Cucumber::Messages::UndefinedParameterType
  def expression(); end

  def initialize(expression: T.unsafe(nil), name: T.unsafe(nil)); end

  def name(); end
end

class Cucumber::Messages::UndefinedParameterType
  def self.from_h(hash); end
end

module Cucumber::Messages
end

module Cucumber::MultilineArgument
end

class Cucumber::MultilineArgument::DataTable
  def append_to(array); end

  def build_hashes(); end

  def cell_matrix(); end

  def cells_rows(); end

  def cells_to_hash(cells); end

  def clear_cache!(); end

  def col_width(col); end

  def column_names(); end

  def columns(); end

  def convert_columns!(); end

  def convert_headers!(); end

  def create_cell_matrix(ast_table); end

  def describe_to(visitor, *args); end

  def diff!(other_table, options=T.unsafe(nil)); end

  def each_cells_row(&proc); end

  def ensure_table(table_or_array); end

  def file(); end

  def file=(file); end

  def hashes(); end

  def header_cell(col); end

  def headers(); end

  def index(cells); end

  def initialize(data, conversion_procs=T.unsafe(nil), header_mappings=T.unsafe(nil), header_conversion_proc=T.unsafe(nil)); end

  def location(); end

  def map_column(column_name, strict: T.unsafe(nil), &conversion_proc); end

  def map_headers(mappings=T.unsafe(nil), &block); end

  def match(pattern); end

  def raw(); end

  def rows(); end

  def rows_hash(); end

  def symbolic_hashes(); end

  def symbolize_key(key); end

  def text?(text); end

  def to_hash(); end

  def to_json(*args); end

  def to_s(options=T.unsafe(nil)); end

  def to_step_definition_arg(); end

  def transpose(); end

  def verify_column(column_name); end

  def verify_table_width(width); end
  NULL_CONVERSIONS = ::T.let(nil, ::T.untyped)
end

class Cucumber::MultilineArgument::DataTable::Builder
  def eof(); end

  def row(row); end

  def rows(); end
end

class Cucumber::MultilineArgument::DataTable::Builder
end

class Cucumber::MultilineArgument::DataTable::Cell
  def ==(other); end

  def eql?(other); end

  def initialize(value, table, line); end

  def inspect!(); end

  def line(); end

  def status(); end

  def status=(status); end

  def table(); end

  def to_sexp(); end

  def value(); end

  def value=(value); end
end

class Cucumber::MultilineArgument::DataTable::Cell
end

class Cucumber::MultilineArgument::DataTable::Cells
  include ::Enumerable
  include ::Cucumber::Gherkin::Formatter::Escaping
  def [](index); end

  def accept(visitor); end

  def dom_id(); end

  def each(&proc); end

  def exception(); end

  def initialize(table, cells); end

  def line(); end

  def to_hash(); end

  def to_sexp(); end

  def value(index); end
end

class Cucumber::MultilineArgument::DataTable::Cells
end

class Cucumber::MultilineArgument::DataTable::DataTablePrinter
  include ::Cucumber::Gherkin::Formatter::Escaping
  def initialize(data_table, indentation, prefixes); end
end

class Cucumber::MultilineArgument::DataTable::DataTablePrinter
end

class Cucumber::MultilineArgument::DataTable::Different
  def initialize(table); end

  def table(); end
end

class Cucumber::MultilineArgument::DataTable::Different
end

class Cucumber::MultilineArgument::DataTable::SurplusCell
  def ==(_other); end
end

class Cucumber::MultilineArgument::DataTable::SurplusCell
end

class Cucumber::MultilineArgument::DataTable
  def self.default_arg_name(); end

  def self.from(data); end
end

class Cucumber::MultilineArgument::DocString
  def append_to(array); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::MultilineArgument::DocString
end

class Cucumber::MultilineArgument::None
  def append_to(array); end

  def describe_to(visitor); end
end

class Cucumber::MultilineArgument::None
end

module Cucumber::MultilineArgument
  def self.from(argument, location=T.unsafe(nil), content_type=T.unsafe(nil)); end

  def self.from_core(node); end
end

class Cucumber::NoStepMatch
  def activate(test_step); end

  def backtrace_line(); end

  def file_colon_line(); end

  def format_args(*_args); end

  def initialize(step, name); end

  def location(); end

  def name(); end

  def step_arguments(); end

  def step_definition(); end

  def text_length(); end
end

class Cucumber::NoStepMatch
end

class Cucumber::Pending
end

class Cucumber::Pending
end

class Cucumber::ProjectInitializer
  def run(); end
end

class Cucumber::ProjectInitializer
end

module Cucumber::RunningTestCase
end

class Cucumber::RunningTestCase::TestCase
  def accept_hook?(hook); end

  def exception(); end

  def failed?(); end

  def initialize(test_case, result=T.unsafe(nil)); end

  def passed?(); end

  def source_tag_names(); end

  def status(); end

  def with_result(result); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::RunningTestCase::TestCase
end

module Cucumber::RunningTestCase
  def self.new(test_case); end
end

class Cucumber::Runtime
  include ::Cucumber::Core
  include ::Cucumber::Formatter::Duration
  include ::Cucumber::Runtime::UserInterface
  def begin_scenario(test_case); end

  def configuration(); end

  def configure(new_configuration); end

  def doc_string(string_without_triple_quotes, content_type=T.unsafe(nil), _line_offset=T.unsafe(nil)); end

  def dry_run?(); end

  def end_scenario(_scenario); end

  def failure?(); end

  def features_paths(); end

  def initialize(configuration=T.unsafe(nil)); end

  def results(); end

  def run!(); end

  def support_code(); end

  def unmatched_step_definitions(); end
end

class Cucumber::Runtime::AfterHooks
  def apply_to(test_case); end

  def initialize(id_generator, hooks, scenario, event_bus); end
end

class Cucumber::Runtime::AfterHooks
end

class Cucumber::Runtime::BeforeHooks
  def apply_to(test_case); end

  def initialize(id_generator, hooks, scenario, event_bus); end
end

class Cucumber::Runtime::BeforeHooks
end

class Cucumber::Runtime::ForProgrammingLanguages
  def ask(*args, **arg, &block); end

  def attach(*args, **arg, &block); end

  def embed(*args, **arg, &block); end

  def features_paths(*args, **arg, &block); end

  def initialize(support_code, user_interface); end

  def invoke_dynamic_step(*args, **arg, &block); end

  def invoke_dynamic_steps(*args, **arg, &block); end

  def puts(*args, **arg, &block); end

  def step_match(*args, **arg, &block); end

  def support_code(); end
end

class Cucumber::Runtime::ForProgrammingLanguages
  extend ::Forwardable
end

class Cucumber::Runtime::MetaMessageBuilder
end

class Cucumber::Runtime::MetaMessageBuilder
  def self.build_meta_message(env=T.unsafe(nil)); end
end

class Cucumber::Runtime::NormalisedEncodingFile
  def initialize(path); end

  def read(); end
  COMMENT_OR_EMPTY_LINE_PATTERN = ::T.let(nil, ::T.untyped)
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
end

class Cucumber::Runtime::NormalisedEncodingFile
  def self.read(path); end
end

class Cucumber::Runtime::StepHooks
  def apply(test_steps); end

  def initialize(id_generator, hooks, event_bus); end
end

class Cucumber::Runtime::StepHooks
end

class Cucumber::Runtime::SupportCode
  include ::Cucumber::Constantize
  def apply_after_hooks(test_case); end

  def apply_before_hooks(test_case); end

  def configure(new_configuration); end

  def find_after_step_hooks(test_case); end

  def find_around_hooks(test_case); end

  def fire_hook(name, *args); end

  def initialize(user_interface, configuration=T.unsafe(nil)); end

  def invoke_dynamic_step(step_name, multiline_argument, _location=T.unsafe(nil)); end

  def invoke_dynamic_steps(steps_text, iso_code, _location); end

  def load_files!(files); end

  def load_files_from_paths(paths); end

  def registry(); end

  def step_definitions(); end

  def unmatched_step_definitions(); end
end

class Cucumber::Runtime::SupportCode::StepInvoker
  def initialize(support_code); end

  def multiline_arg(step, location); end

  def step(step); end

  def steps(steps); end
end

class Cucumber::Runtime::SupportCode::StepInvoker
end

class Cucumber::Runtime::SupportCode
end

module Cucumber::Runtime::UserInterface
  def ask(question, timeout_seconds); end

  def attach(src, media_type, filename); end

  def visitor=(visitor); end
end

module Cucumber::Runtime::UserInterface
end

class Cucumber::Runtime
end

class Cucumber::SkippingStepMatch
  def activate(test_step); end
end

class Cucumber::SkippingStepMatch
end

class Cucumber::StepDefinitionLight
  def eql?(other); end

  def initialize(regexp_source, location); end

  def location(); end

  def regexp_source(); end
end

class Cucumber::StepDefinitionLight
end

class Cucumber::StepDefinitions
  def initialize(configuration=T.unsafe(nil)); end

  def to_json(obj=T.unsafe(nil)); end
end

class Cucumber::StepDefinitions
end

class Cucumber::StepMatch
  def activate(test_step); end

  def args(); end

  def backtrace_line(); end

  def file_colon_line(); end

  def format_args(format=T.unsafe(nil), &proc); end

  def initialize(step_definition, step_name, step_arguments); end

  def invoke(multiline_arg); end

  def location(); end

  def replace_arguments(string, step_arguments, format); end

  def step_arguments(); end

  def step_definition(); end

  def text_length(); end
end

class Cucumber::StepMatch
end

module Cucumber::StepMatchSearch
end

class Cucumber::StepMatchSearch::AssertUnambiguousMatch
  def call(step_name); end

  def initialize(search, configuration); end
end

class Cucumber::StepMatchSearch::AssertUnambiguousMatch
end

class Cucumber::StepMatchSearch::AttemptToGuessAmbiguousMatch
  def call(step_name); end

  def initialize(search); end
end

class Cucumber::StepMatchSearch::AttemptToGuessAmbiguousMatch
end

class Cucumber::StepMatchSearch::CachesStepMatch
  def call(step_name); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Cucumber::StepMatchSearch::CachesStepMatch
end

module Cucumber::StepMatchSearch
  def self.new(search, configuration); end
end

class Cucumber::TagExcess
  def initialize(messages); end
end

class Cucumber::TagExcess
end

module Cucumber::TagExpressions
end

class Cucumber::TagExpressions::And
  def evaluate(variables); end

  def initialize(left, right); end
end

class Cucumber::TagExpressions::And
end

class Cucumber::TagExpressions::Literal
  def evaluate(variables); end

  def initialize(value); end
end

class Cucumber::TagExpressions::Literal
end

class Cucumber::TagExpressions::Not
  def evaluate(variables); end

  def initialize(expression); end
end

class Cucumber::TagExpressions::Not
end

class Cucumber::TagExpressions::Or
  def evaluate(variables); end

  def initialize(left, right); end
end

class Cucumber::TagExpressions::Or
end

class Cucumber::TagExpressions::Parser
  def parse(infix_expression); end
end

class Cucumber::TagExpressions::Parser
end

class Cucumber::TagExpressions::True
  def evaluate(_variables); end
end

class Cucumber::TagExpressions::True
end

module Cucumber::TagExpressions
end

module Cucumber::Term
end

module Cucumber::Term::ANSIColor
  def attributes(); end

  def black(text=T.unsafe(nil), &block); end

  def blink(text=T.unsafe(nil), &block); end

  def blue(text=T.unsafe(nil), &block); end

  def bold(text=T.unsafe(nil), &block); end

  def clear(text=T.unsafe(nil), &block); end

  def concealed(text=T.unsafe(nil), &block); end

  def cyan(text=T.unsafe(nil), &block); end

  def dark(text=T.unsafe(nil), &block); end

  def green(text=T.unsafe(nil), &block); end

  def grey(text=T.unsafe(nil), &block); end

  def italic(text=T.unsafe(nil), &block); end

  def magenta(text=T.unsafe(nil), &block); end

  def negative(text=T.unsafe(nil), &block); end

  def on_black(text=T.unsafe(nil), &block); end

  def on_blue(text=T.unsafe(nil), &block); end

  def on_cyan(text=T.unsafe(nil), &block); end

  def on_green(text=T.unsafe(nil), &block); end

  def on_magenta(text=T.unsafe(nil), &block); end

  def on_red(text=T.unsafe(nil), &block); end

  def on_white(text=T.unsafe(nil), &block); end

  def on_yellow(text=T.unsafe(nil), &block); end

  def rapid_blink(text=T.unsafe(nil), &block); end

  def red(text=T.unsafe(nil), &block); end

  def reset(text=T.unsafe(nil), &block); end

  def strikethrough(text=T.unsafe(nil), &block); end

  def uncolored(text=T.unsafe(nil)); end

  def underline(text=T.unsafe(nil), &block); end

  def underscore(text=T.unsafe(nil), &block); end

  def white(text=T.unsafe(nil), &block); end

  def yellow(text=T.unsafe(nil), &block); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NAMES = ::T.let(nil, ::T.untyped)
  COLORED_REGEXP = ::T.let(nil, ::T.untyped)
end

module Cucumber::Term::ANSIColor
  def self.coloring(); end

  def self.coloring=(coloring); end

  def self.coloring?(); end

  def self.included(klass); end
end

module Cucumber::Term::Banner
  def display_banner(lines, io, border_modifiers=T.unsafe(nil)); end
end

module Cucumber::Term::Banner
end

module Cucumber::Term
end

class Cucumber::Undefined
end

class Cucumber::Undefined
  def self.from(result, step_name); end

  def self.with_prefix(step_name); end
end

class Cucumber::UndefinedDynamicStep
  def initialize(step_name); end
end

class Cucumber::UndefinedDynamicStep
end

module Cucumber
  def self.deprecate(message, method, remove_after_version); end

  def self.file_mode(mode, encoding=T.unsafe(nil)); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.use_full_backtrace(); end

  def self.use_full_backtrace=(use_full_backtrace); end

  def self.use_legacy_autoloader(); end

  def self.use_legacy_autoloader=(value); end

  def self.wants_to_quit(); end

  def self.wants_to_quit=(wants_to_quit); end
end

module DRb
  DRB_OBJECT_SPACE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.make_pool(); end

  def self.open(remote_uri); end

  def self.stop_pool(); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

class DRb::DRbObjectSpace
  include ::MonitorMixin
  def initialize(); end

  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbObjectSpace
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end
end

class DRb::DRbServer::InvokeMethod
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

class DRb::DRbServer
  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

class DRb::ThreadObject
  include ::MonitorMixin
  def _execute(); end

  def alive?(); end

  def initialize(&blk); end

  def kill(); end

  def method_missing(msg, *arg, &blk); end
end

class DRb::ThreadObject
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  def deconstruct_keys(arg); end

  def infinite?(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DateTime
  def self.new(*arg); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Diff
end

module Diff::LCS
  def diff(other, callbacks=T.unsafe(nil), &block); end

  def lcs(other, &block); end

  def patch(patchset); end

  def patch!(patchset); end

  def patch_me(patchset); end

  def sdiff(other, callbacks=T.unsafe(nil), &block); end

  def traverse_balanced(other, callbacks=T.unsafe(nil), &block); end

  def traverse_sequences(other, callbacks=T.unsafe(nil), &block); end

  def unpatch(patchset); end

  def unpatch!(patchset); end

  def unpatch_me(patchset); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Diff::LCS::BalancedCallbacks = Diff::LCS::DefaultCallbacks

class Diff::LCS::Change
  include ::Comparable
  def ==(other); end

  def action(); end

  def adding?(); end

  def changed?(); end

  def deleting?(); end

  def element(); end

  def finished_a?(); end

  def finished_b?(); end

  def initialize(*args); end

  def inspect(*_args); end

  def position(); end

  def to_a(); end

  def to_ary(); end

  def unchanged?(); end
  VALID_ACTIONS = ::T.let(nil, ::T.untyped)
end

Diff::LCS::Change::IntClass = Integer

class Diff::LCS::Change
  def self.from_a(arr); end

  def self.valid_action?(action); end
end

class Diff::LCS::ContextChange
  def new_element(); end

  def new_position(); end

  def old_element(); end

  def old_position(); end
end

class Diff::LCS::ContextChange
  def self.simplify(event); end
end

class Diff::LCS::ContextDiffCallbacks
  def change(event); end
end

class Diff::LCS::ContextDiffCallbacks
end

class Diff::LCS::DefaultCallbacks
end

class Diff::LCS::DefaultCallbacks
  def self.change(event); end

  def self.discard_a(event); end

  def self.discard_b(event); end

  def self.match(event); end
end

class Diff::LCS::DiffCallbacks
  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def finish(); end

  def match(_event); end
end

class Diff::LCS::DiffCallbacks
end

module Diff::LCS::Internals
end

module Diff::LCS::Internals
  def self.analyze_patchset(patchset, depth=T.unsafe(nil)); end

  def self.intuit_diff_direction(src, patchset, limit=T.unsafe(nil)); end

  def self.lcs(a, b); end
end

class Diff::LCS::SDiffCallbacks
  def change(event); end

  def diffs(); end

  def discard_a(event); end

  def discard_b(event); end

  def match(event); end
end

class Diff::LCS::SDiffCallbacks
end

Diff::LCS::SequenceCallbacks = Diff::LCS::DefaultCallbacks

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.callbacks_for(callbacks); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.unpatch!(src, patchset); end
end

module Diff
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def chdir(); end

  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  TMPDIR_CANDIDATES = ::T.let(nil, ::T.untyped)
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.fchdir(arg); end

  def self.for_fd(arg); end
end

module Docile
  VERSION = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
  def backtrace(); end

  def backtrace_locations(); end
  FILTER_PATTERN = ::T.let(nil, ::T.untyped)
end

module Docile::BacktraceFilter
end

class Docile::ChainingFallbackContextProxy
end

class Docile::ChainingFallbackContextProxy
end

module Docile::Execution
end

module Docile::Execution
  def self.exec_in_proxy_context(dsl, proxy_type, *args, **arg, &block); end
end

class Docile::FallbackContextProxy
  def initialize(receiver, fallback); end

  def method_missing(method, *args, **arg, &block); end
  NON_FALLBACK_METHODS = ::T.let(nil, ::T.untyped)
  NON_PROXIED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
  NON_PROXIED_METHODS = ::T.let(nil, ::T.untyped)
end

class Docile::FallbackContextProxy
end

module Docile
  extend ::Docile::Execution
  def self.dsl_eval(dsl, *args, **arg, &block); end

  def self.dsl_eval_immutable(dsl, *args, **arg, &block); end

  def self.dsl_eval_with_block_return(dsl, *args, **arg, &block); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Escape
end

module ERB::Escape
  def self.html_escape(arg); end
end

module ERB::Util
  include ::ERB::Escape
end

class Encoding
  def _dump(*arg); end
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def compact(); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADARCH = Errno::NOERROR

Errno::EBADEXEC = Errno::NOERROR

Errno::EBADMACHO = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDEVERR = Errno::NOERROR

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ELAST = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOPOLICY = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::EPWROFF = Errno::NOERROR

Errno::EQFULL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

Errno::ESHLIBVERS = Errno::NOERROR

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

class ErrorHighlight::DefaultFormatter
  MIN_SNIPPET_WIDTH = ::T.let(nil, ::T.untyped)
end

class ErrorHighlight::DefaultFormatter
  def self.max_snippet_width(); end

  def self.max_snippet_width=(width); end

  def self.terminal_width(); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid=(_); end

  def mem=(_); end

  def name=(_); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class FFI::AbstractMemory
  def [](arg); end

  def __copy_from__(arg, arg1); end

  def clear(); end

  def get(arg, arg1); end

  def get_array_of_char(arg, arg1); end

  def get_array_of_double(arg, arg1); end

  def get_array_of_float(arg, arg1); end

  def get_array_of_float32(arg, arg1); end

  def get_array_of_float64(arg, arg1); end

  def get_array_of_int(arg, arg1); end

  def get_array_of_int16(arg, arg1); end

  def get_array_of_int32(arg, arg1); end

  def get_array_of_int64(arg, arg1); end

  def get_array_of_int8(arg, arg1); end

  def get_array_of_long(arg, arg1); end

  def get_array_of_long_long(arg, arg1); end

  def get_array_of_pointer(arg, arg1); end

  def get_array_of_short(arg, arg1); end

  def get_array_of_string(*arg); end

  def get_array_of_uchar(arg, arg1); end

  def get_array_of_uint(arg, arg1); end

  def get_array_of_uint16(arg, arg1); end

  def get_array_of_uint32(arg, arg1); end

  def get_array_of_uint64(arg, arg1); end

  def get_array_of_uint8(arg, arg1); end

  def get_array_of_ulong(arg, arg1); end

  def get_array_of_ulong_long(arg, arg1); end

  def get_array_of_ushort(arg, arg1); end

  def get_bytes(arg, arg1); end

  def get_char(arg); end

  def get_double(arg); end

  def get_float(arg); end

  def get_float32(arg); end

  def get_float64(arg); end

  def get_int(arg); end

  def get_int16(arg); end

  def get_int32(arg); end

  def get_int64(arg); end

  def get_int8(arg); end

  def get_long(arg); end

  def get_long_long(arg); end

  def get_pointer(arg); end

  def get_short(arg); end

  def get_string(*arg); end

  def get_uchar(arg); end

  def get_uint(arg); end

  def get_uint16(arg); end

  def get_uint32(arg); end

  def get_uint64(arg); end

  def get_uint8(arg); end

  def get_ulong(arg); end

  def get_ulong_long(arg); end

  def get_ushort(arg); end

  def put(arg, arg1, arg2); end

  def put_array_of_char(arg, arg1); end

  def put_array_of_double(arg, arg1); end

  def put_array_of_float(arg, arg1); end

  def put_array_of_float32(arg, arg1); end

  def put_array_of_float64(arg, arg1); end

  def put_array_of_int(arg, arg1); end

  def put_array_of_int16(arg, arg1); end

  def put_array_of_int32(arg, arg1); end

  def put_array_of_int64(arg, arg1); end

  def put_array_of_int8(arg, arg1); end

  def put_array_of_long(arg, arg1); end

  def put_array_of_long_long(arg, arg1); end

  def put_array_of_pointer(arg, arg1); end

  def put_array_of_short(arg, arg1); end

  def put_array_of_uchar(arg, arg1); end

  def put_array_of_uint(arg, arg1); end

  def put_array_of_uint16(arg, arg1); end

  def put_array_of_uint32(arg, arg1); end

  def put_array_of_uint64(arg, arg1); end

  def put_array_of_uint8(arg, arg1); end

  def put_array_of_ulong(arg, arg1); end

  def put_array_of_ulong_long(arg, arg1); end

  def put_array_of_ushort(arg, arg1); end

  def put_bytes(*arg); end

  def put_char(arg, arg1); end

  def put_double(arg, arg1); end

  def put_float(arg, arg1); end

  def put_float32(arg, arg1); end

  def put_float64(arg, arg1); end

  def put_int(arg, arg1); end

  def put_int16(arg, arg1); end

  def put_int32(arg, arg1); end

  def put_int64(arg, arg1); end

  def put_int8(arg, arg1); end

  def put_long(arg, arg1); end

  def put_long_long(arg, arg1); end

  def put_pointer(arg, arg1); end

  def put_short(arg, arg1); end

  def put_string(arg, arg1); end

  def put_uchar(arg, arg1); end

  def put_uint(arg, arg1); end

  def put_uint16(arg, arg1); end

  def put_uint32(arg, arg1); end

  def put_uint64(arg, arg1); end

  def put_uint8(arg, arg1); end

  def put_ulong(arg, arg1); end

  def put_ulong_long(arg, arg1); end

  def put_ushort(arg, arg1); end

  def read_array_of_char(arg); end

  def read_array_of_double(arg); end

  def read_array_of_float(arg); end

  def read_array_of_int(arg); end

  def read_array_of_int16(arg); end

  def read_array_of_int32(arg); end

  def read_array_of_int64(arg); end

  def read_array_of_int8(arg); end

  def read_array_of_long(arg); end

  def read_array_of_long_long(arg); end

  def read_array_of_pointer(arg); end

  def read_array_of_short(arg); end

  def read_array_of_string(*arg); end

  def read_array_of_uchar(arg); end

  def read_array_of_uint(arg); end

  def read_array_of_uint16(arg); end

  def read_array_of_uint32(arg); end

  def read_array_of_uint64(arg); end

  def read_array_of_uint8(arg); end

  def read_array_of_ulong(arg); end

  def read_array_of_ulong_long(arg); end

  def read_array_of_ushort(arg); end

  def read_bytes(arg); end

  def read_char(); end

  def read_double(); end

  def read_float(); end

  def read_int(); end

  def read_int16(); end

  def read_int32(); end

  def read_int64(); end

  def read_int8(); end

  def read_long(); end

  def read_long_long(); end

  def read_pointer(); end

  def read_short(); end

  def read_uchar(); end

  def read_uint(); end

  def read_uint16(); end

  def read_uint32(); end

  def read_uint64(); end

  def read_uint8(); end

  def read_ulong(); end

  def read_ulong_long(); end

  def read_ushort(); end

  def size(); end

  def size_limit?(); end

  def total(); end

  def type_size(); end

  def write_array_of_char(arg); end

  def write_array_of_double(arg); end

  def write_array_of_float(arg); end

  def write_array_of_int(arg); end

  def write_array_of_int16(arg); end

  def write_array_of_int32(arg); end

  def write_array_of_int64(arg); end

  def write_array_of_int8(arg); end

  def write_array_of_long(arg); end

  def write_array_of_long_long(arg); end

  def write_array_of_pointer(arg); end

  def write_array_of_short(arg); end

  def write_array_of_uchar(arg); end

  def write_array_of_uint(arg); end

  def write_array_of_uint16(arg); end

  def write_array_of_uint32(arg); end

  def write_array_of_uint64(arg); end

  def write_array_of_uint8(arg); end

  def write_array_of_ulong(arg); end

  def write_array_of_ulong_long(arg); end

  def write_array_of_ushort(arg); end

  def write_bytes(*arg); end

  def write_char(arg); end

  def write_double(arg); end

  def write_float(arg); end

  def write_int(arg); end

  def write_int16(arg); end

  def write_int32(arg); end

  def write_int64(arg); end

  def write_int8(arg); end

  def write_long(arg); end

  def write_long_long(arg); end

  def write_pointer(arg); end

  def write_short(arg); end

  def write_uchar(arg); end

  def write_uint(arg); end

  def write_uint16(arg); end

  def write_uint32(arg); end

  def write_uint64(arg); end

  def write_uint8(arg); end

  def write_ulong(arg); end

  def write_ulong_long(arg); end

  def write_ushort(arg); end
end

class FFI::AbstractMemory
end

class FFI::ArrayType
  def elem_type(); end

  def initialize(arg, arg1); end

  def length(); end
end

class FFI::ArrayType
end

class FFI::AutoPointer
  def autorelease=(autorelease); end

  def clone(); end

  def initialize(ptr, proc=T.unsafe(nil)); end
end

class FFI::AutoPointer::Releaser
  def autorelease(); end

  def autorelease=(autorelease); end

  def call(*args); end

  def free(); end

  def initialize(ptr, proc); end

  def release(ptr); end
end

class FFI::AutoPointer::Releaser
end

class FFI::AutoPointer
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end

  def self.native_type(); end
end

class FFI::Bitmask
  def [](*query); end

  def to_native(query, ctx); end
end

class FFI::Bitmask
end

class FFI::Buffer
  def +(arg); end

  def initialize(*arg); end

  def length(); end

  def order(*arg); end

  def slice(arg, arg1); end
end

class FFI::Buffer
  def self.alloc_in(*arg); end

  def self.alloc_inout(*arg); end

  def self.alloc_out(*arg); end

  def self.new_in(*arg); end

  def self.new_inout(*arg); end

  def self.new_out(*arg); end
end

FFI::CallbackInfo = FFI::FunctionType

module FFI::DataConverter
  def from_native(value, ctx); end

  def native_type(type=T.unsafe(nil)); end

  def to_native(value, ctx); end
end

module FFI::DataConverter
end

class FFI::DynamicLibrary
  def find_function(arg); end

  def find_symbol(arg); end

  def find_variable(arg); end

  def initialize(arg, arg1); end

  def last_error(); end

  def name(); end
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SEARCH_PATH = ::T.let(nil, ::T.untyped)
  SEARCH_PATH_MESSAGE = ::T.let(nil, ::T.untyped)
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary::Symbol
end

class FFI::DynamicLibrary
  def self.last_error(); end

  def self.open(arg, arg1); end
end

class FFI::Enum
  include ::FFI::DataConverter
  def [](query); end

  def find(query); end

  def from_native(val, ctx); end

  def initialize(*args); end

  def native_type(); end

  def symbol_map(); end

  def symbols(); end

  def tag(); end

  def to_h(); end

  def to_hash(); end

  def to_native(val, ctx); end
end

class FFI::Enum
end

class FFI::Enums
  def <<(enum); end

  def __map_symbol(symbol); end

  def find(query); end
end

class FFI::Enums
end

class FFI::Function
  include ::FFI::Function::RegisterAttach
  def autorelease(); end

  def call(*arg); end

  def param_types(); end

  def return_type(); end
end

module FFI::Function::RegisterAttach
  def attach(mod, name); end
end

module FFI::Function::RegisterAttach
end

class FFI::Function
end

FFI::FunctionInfo = FFI::FunctionType

class FFI::FunctionType
  def initialize(*arg); end

  def param_types(); end

  def return_type(); end
end

class FFI::FunctionType
end

module FFI::IO
end

module FFI::IO
  def self.for_fd(fd, mode=T.unsafe(nil)); end

  def self.native_read(io, buf, len); end
end

module FFI::LastError
end

module FFI::LastError
  def self.error(); end

  def self.error=(error); end
end

module FFI::LegacyForkTracking
end

module FFI::LegacyForkTracking::IOExt
  def popen(*args); end
end

module FFI::LegacyForkTracking::IOExt
end

module FFI::LegacyForkTracking::KernelExt
  def fork(); end
end

module FFI::LegacyForkTracking::KernelExt
end

module FFI::LegacyForkTracking::KernelExtPrivate
  include ::FFI::LegacyForkTracking::KernelExt
end

module FFI::LegacyForkTracking::KernelExtPrivate
end

module FFI::LegacyForkTracking
end

module FFI::Library
  def attach_function(name, func, args, returns=T.unsafe(nil), options=T.unsafe(nil)); end

  def attach_variable(mname, a1, a2=T.unsafe(nil)); end

  def attached_functions(); end

  def attached_variables(); end

  def bitmask(*args); end

  def callback(*args); end

  def enum(*args); end

  def enum_type(name); end

  def enum_value(symbol); end

  def ffi_convention(convention=T.unsafe(nil)); end

  def ffi_lib(*names); end

  def ffi_lib_flags(*flags); end

  def ffi_libraries(); end

  def find_type(t); end

  def freeze(); end

  def function_names(name, arg_types); end

  def typedef(old, add, info=T.unsafe(nil)); end
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

module FFI::Library
  def self.extended(mod); end
end

class FFI::LibraryPath
  def abi_number(); end

  def full_name(); end

  def initialize(name, abi_number: T.unsafe(nil), root: T.unsafe(nil)); end

  def name(); end

  def root(); end
end

class FFI::LibraryPath
  def self.wrap(value); end
end

class FFI::ManagedStruct
  def initialize(pointer=T.unsafe(nil)); end
end

class FFI::ManagedStruct
end

class FFI::MemoryPointer
end

class FFI::MemoryPointer
  def self.from_string(arg); end
end

module FFI::ModernForkTracking
  def _fork(); end
end

module FFI::ModernForkTracking
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NotFoundError
  def initialize(function, *libraries); end
end

class FFI::NotFoundError
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  GNU_LIBC = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

module FFI::Platform
  def self.bsd?(); end

  def self.is_os(os); end

  def self.mac?(); end

  def self.solaris?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class FFI::PlatformError
end

class FFI::PlatformError
end

class FFI::Pointer
  def +(arg); end

  def address(); end

  def autorelease=(autorelease); end

  def autorelease?(); end

  def free(); end

  def initialize(*arg); end

  def null?(); end

  def order(*arg); end

  def read(type); end

  def read_array_of_type(type, reader, length); end

  def read_string(len=T.unsafe(nil)); end

  def read_string_length(len); end

  def read_string_to_null(); end

  def slice(arg, arg1); end

  def to_i(); end

  def to_ptr(); end

  def write(type, value); end

  def write_array_of_type(type, writer, ary); end

  def write_string(str, len=T.unsafe(nil)); end

  def write_string_length(str, len); end
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  def self.size(); end
end

class FFI::StrPtrConverter
end

class FFI::StrPtrConverter
  extend ::FFI::DataConverter
  def self.from_native(val, ctx); end
end

class FFI::Struct
  def [](arg); end

  def []=(arg, arg1); end

  def align(); end

  def alignment(); end

  def clear(); end

  def initialize(*arg); end

  def layout(); end

  def members(); end

  def null?(); end

  def offset_of(name); end

  def offsets(); end

  def order(*arg); end

  def pointer(); end

  def size(); end

  def to_ptr(); end

  def values(); end
end

class FFI::Struct::InlineArray
  include ::Enumerable
  def [](arg); end

  def []=(arg, arg1); end

  def each(&blk); end

  def initialize(arg, arg1); end

  def size(); end

  def to_a(); end

  def to_ptr(); end
end

class FFI::Struct::InlineArray
end

class FFI::Struct::ManagedStructConverter
  def from_native(ptr, ctx); end
end

class FFI::Struct::ManagedStructConverter
end

class FFI::Struct
  def self.align(alignment=T.unsafe(nil)); end

  def self.aligned(alignment=T.unsafe(nil)); end

  def self.alignment(); end

  def self.alloc_in(*arg, **arg1); end

  def self.alloc_inout(*arg, **arg1); end

  def self.alloc_out(*arg, **arg1); end

  def self.auto_ptr(); end

  def self.by_ref(flags=T.unsafe(nil)); end

  def self.by_value(); end

  def self.callback(params, ret); end

  def self.enclosing_module(); end

  def self.find_field_type(type, mod=T.unsafe(nil)); end

  def self.find_type(type, mod=T.unsafe(nil)); end

  def self.in(); end

  def self.layout(*spec); end

  def self.members(); end

  def self.new_in(*arg, **arg1); end

  def self.new_inout(*arg, **arg1); end

  def self.new_out(*arg, **arg1); end

  def self.offset_of(name); end

  def self.offsets(); end

  def self.out(); end

  def self.pack(packed=T.unsafe(nil)); end

  def self.packed(packed=T.unsafe(nil)); end

  def self.ptr(flags=T.unsafe(nil)); end

  def self.size(); end

  def self.size=(size); end

  def self.val(); end
end

class FFI::StructByReference
  include ::FFI::DataConverter
  def initialize(struct_class); end

  def native_type(_type=T.unsafe(nil)); end

  def struct_class(); end
end

class FFI::StructByReference
end

class FFI::StructByValue
  def layout(); end

  def struct_class(); end
end

class FFI::StructByValue
end

class FFI::StructLayout
  def [](arg); end

  def __union!(); end

  def fields(); end

  def initialize(arg, arg1, arg2); end

  def members(); end

  def offset_of(field_name); end

  def offsets(); end

  def to_a(); end
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::Array
end

class FFI::StructLayout::CharArray
  def to_str(); end
end

class FFI::StructLayout::CharArray
end

class FFI::StructLayout::Enum
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::Enum
end

class FFI::StructLayout::Field
  def alignment(); end

  def get(arg); end

  def initialize(*arg); end

  def name(); end

  def offset(); end

  def put(arg, arg1); end

  def size(); end

  def type(); end
end

class FFI::StructLayout::Field
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::Function
end

class FFI::StructLayout::InnerStruct
  def get(ptr); end

  def put(ptr, value); end
end

class FFI::StructLayout::InnerStruct
end

class FFI::StructLayout::Mapped
  def get(ptr); end

  def initialize(name, offset, type, orig_field); end

  def put(ptr, value); end
end

class FFI::StructLayout::Mapped
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayout
end

class FFI::StructLayoutBuilder
  def add(name, type, offset=T.unsafe(nil)); end

  def add_array(name, type, count, offset=T.unsafe(nil)); end

  def add_field(name, type, offset=T.unsafe(nil)); end

  def add_struct(name, type, offset=T.unsafe(nil)); end

  def alignment(); end

  def alignment=(align); end

  def build(); end

  def packed=(packed); end

  def size(); end

  def size=(size); end

  def union=(is_union); end

  def union?(); end
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::StructLayoutBuilder
end

class FFI::Type
  def alignment(); end

  def initialize(arg); end

  def size(); end
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

class FFI::Type::Builtin
end

class FFI::Type::Builtin
end

FFI::Type::Function = FFI::FunctionType

class FFI::Type::Mapped
  def converter(); end

  def from_native(*arg); end

  def native_type(); end

  def to_native(*arg); end

  def type(); end
end

class FFI::Type::Mapped
end

FFI::Type::Struct = FFI::StructByValue

class FFI::Type
end

class FFI::Union
end

class FFI::Union
  def self.builder(); end
end

class FFI::VariadicInvoker
  def attach(mod, mname); end

  def call(*args, &block); end

  def initialize(arg, arg1, arg2, arg3); end

  def invoke(arg, arg1); end

  def param_types(); end

  def return_type(); end
end

class FFI::VariadicInvoker
end

module FFI
  def self._async_cb_dispatcher_atfork_child(); end

  def self.add_typedef(old, add); end

  def self.errno(); end

  def self.errno=(error); end

  def self.find_type(name, type_map=T.unsafe(nil)); end

  def self.make_shareable(obj); end

  def self.map_library_name(lib); end

  def self.shareable_proc(**_kwargs, &block); end

  def self.type_size(type); end

  def self.typedef(old, add); end
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def kill(); end

  def storage(); end

  def storage=(storage); end
end

class Fiber
  def self.blocking(); end

  def self.blocking?(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
end

class File
  def self.absolute_path?(arg); end

  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.open!(file, *args, &block); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Find
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.config(hash=T.unsafe(nil)); end

  def self.latest_compact_info(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  DEFAULT_SOURCE_DATE_EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  VALIDATES_FOR_RESOLUTION = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  SINCE_FAST_PATH = ::T.let(nil, ::T.untyped)
end

module Gem::BUNDLED_GEMS
  def self.build_message(gem); end

  def self.find_gem(path); end

  def self.replace_require(specs); end

  def self.uplevel(); end

  def self.warning?(name, specs: T.unsafe(nil)); end
end

class Gem::BasicSpecification
  def base_dir_priority(gem_path); end

  def default_gem_priority(); end

  def full_name_with_location(); end

  def ignored?(); end

  def installable_on_platform?(target_platform); end

  def plugins(); end
end

module Gem::BetterPermissionError
  def data(); end
end

module Gem::BetterPermissionError
end

module Gem::CIDetector
  ENV_DESCRIPTORS = ::T.let(nil, ::T.untyped)
  ENV_INDICATORS = ::T.let(nil, ::T.untyped)
end

module Gem::CIDetector
  def self.ci?(); end

  def self.ci_strings(); end
end

Gem::Cache = Gem::SourceIndex

class Gem::ConfigFile
  def install_extension_in_lib(); end

  def install_extension_in_lib=(install_extension_in_lib); end

  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_INSTALL_EXTENSION_IN_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
  def self.deep_transform_config_keys!(config); end

  def self.dump_with_rubygems_yaml(content); end

  def self.load_with_rubygems_config_hash(yaml); end
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::ExtensionBuildError
end

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  DEPRECATED_EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_EXCEPTION_REGEXP = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  DEPRECATED_LICENSE_REGEXP = ::T.let(nil, ::T.untyped)
  LICENSE_REF = ::T.let(nil, ::T.untyped)
  VALID_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  def self.deprecated_exception_id?(license); end

  def self.deprecated_license_id?(license); end
end

module Gem::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(vertices); end
end

class Gem::Molinillo::CircularDependencyError
end

module Gem::Molinillo::Delegates
end

module Gem::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end

  def unused_unwind_options(); end
end

module Gem::Molinillo::Delegates::ResolutionState
end

module Gem::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::Delegates::SpecificationProvider
end

module Gem::Molinillo::Delegates
end

class Gem::Molinillo::DependencyGraph
  include ::Enumerable
  include ::Gem::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(&blk); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(arg); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Molinillo::DependencyGraph::AddVertex
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Molinillo::DependencyGraph::Edge
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Molinillo::DependencyGraph::SetPayload
end

class Gem::Molinillo::DependencyGraph::Tag
  def initialize(tag); end

  def tag(); end
end

class Gem::Molinillo::DependencyGraph::Tag
end

class Gem::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Molinillo::DependencyGraph::Vertex
end

class Gem::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Molinillo::DependencyState
end

class Gem::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Molinillo::NoSuchDependencyError
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::PossibilityState
end

class Gem::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end

  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Molinillo::ResolutionState
  def self.[](*arg); end

  def self.empty(); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Molinillo::Resolver::Resolution
  include ::Gem::Molinillo::Delegates::ResolutionState
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility_set(); end

  def possibility_set=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Molinillo::Resolver::Resolution::Conflict
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Molinillo::Resolver::Resolution
end

class Gem::Molinillo::Resolver
end

class Gem::Molinillo::ResolverError
end

class Gem::Molinillo::ResolverError
end

module Gem::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_equal?(dependencies, other_dependencies); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Molinillo::SpecificationProvider
end

module Gem::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Molinillo::UI
end

class Gem::Molinillo::VersionConflict
  include ::Gem::Molinillo::Delegates::SpecificationProvider
  def conflicts(); end

  def initialize(conflicts, specification_provider); end

  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Molinillo::VersionConflict
end

module Gem::Molinillo
end

class Gem::NameTuple
  def lock_name(); end
end

module Gem::Net
end

class Gem::Net::BufferedIO
  def <<(*strs); end

  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def eof?(); end

  def initialize(io, read_timeout: T.unsafe(nil), write_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  def io(); end

  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  def read_all(dest=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readline(); end

  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  def write(*strs); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end

  def writeline(str); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
end

class Gem::Net::BufferedIO
end

class Gem::Net::HTTP
  def active?(); end

  def address(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def ca_path(); end

  def ca_path=(ca_path); end

  def cert(); end

  def cert=(cert); end

  def cert_store(); end

  def cert_store=(cert_store); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def close_on_empty_response(); end

  def close_on_empty_response=(close_on_empty_response); end

  def continue_timeout(); end

  def continue_timeout=(sec); end

  def copy(path, initheader=T.unsafe(nil)); end

  def delete(path, initheader=T.unsafe(nil)); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(); end

  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def get2(path, initheader=T.unsafe(nil), &block); end

  def head(path, initheader=T.unsafe(nil)); end

  def head2(path, initheader=T.unsafe(nil), &block); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(address, port=T.unsafe(nil)); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def key(); end

  def key=(key); end

  def local_host(); end

  def local_host=(local_host); end

  def local_port(); end

  def local_port=(local_port); end

  def lock(path, body, initheader=T.unsafe(nil)); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def move(path, initheader=T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def options(path, initheader=T.unsafe(nil)); end

  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def peer_cert(); end

  def port(); end

  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  def post2(path, data, initheader=T.unsafe(nil), &block); end

  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  def proppatch(path, body, initheader=T.unsafe(nil)); end

  def proxy?(); end

  def proxy_address(); end

  def proxy_address=(proxy_address); end

  def proxy_from_env=(proxy_from_env); end

  def proxy_from_env?(); end

  def proxy_pass(); end

  def proxy_pass=(proxy_pass); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_uri(); end

  def proxy_use_ssl=(proxy_use_ssl); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def proxyaddr(); end

  def proxyport(); end

  def put(path, data, initheader=T.unsafe(nil)); end

  def put2(path, data, initheader=T.unsafe(nil), &block); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def request(req, body=T.unsafe(nil), &block); end

  def request_get(path, initheader=T.unsafe(nil), &block); end

  def request_head(path, initheader=T.unsafe(nil), &block); end

  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  def set_debug_output(output); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(); end

  def started?(); end

  def trace(path, initheader=T.unsafe(nil)); end

  def unlock(path, body, initheader=T.unsafe(nil)); end

  def use_ssl=(flag); end

  def use_ssl?(); end

  def verify_callback(); end

  def verify_callback=(verify_callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(sec); end
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Copy
end

class Gem::Net::HTTP::Delete
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Delete
end

class Gem::Net::HTTP::Get
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Get
end

class Gem::Net::HTTP::Head
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Head
end

class Gem::Net::HTTP::Lock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Lock
end

class Gem::Net::HTTP::Mkcol
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Mkcol
end

class Gem::Net::HTTP::Move
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Move
end

class Gem::Net::HTTP::Options
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Options
end

class Gem::Net::HTTP::Patch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Patch
end

class Gem::Net::HTTP::Persistent
  def ca_file(); end

  def ca_file=(file); end

  def ca_path(); end

  def ca_path=(path); end

  def cert(); end

  def cert=(certificate); end

  def cert_store(); end

  def cert_store=(store); end

  def certificate(); end

  def certificate=(certificate); end

  def ciphers(); end

  def ciphers=(ciphers); end

  def connection_for(uri); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def escape(str); end

  def expired?(connection); end

  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def finish(connection); end

  def generation(); end

  def headers(); end

  def http_version(uri); end

  def http_versions(); end

  def idle_timeout(); end

  def idle_timeout=(idle_timeout); end

  def initialize(name: T.unsafe(nil), proxy: T.unsafe(nil), pool_size: T.unsafe(nil)); end

  def keep_alive(); end

  def keep_alive=(keep_alive); end

  def key(); end

  def key=(key); end

  def max_requests(); end

  def max_requests=(max_requests); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def name(); end

  def no_proxy(); end

  def normalize_uri(uri); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def override_headers(); end

  def pool(); end

  def private_key(); end

  def private_key=(key); end

  def proxy=(proxy); end

  def proxy_bypass?(host, port); end

  def proxy_from_env(); end

  def proxy_uri(); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def reconnect(); end

  def reconnect_ssl(); end

  def reload(); end

  def request(uri, req=T.unsafe(nil), &block); end

  def request_setup(req_or_uri); end

  def reset(connection); end

  def reuse_ssl_sessions(); end

  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  def shutdown(); end

  def socket_options(); end

  def ssl(connection); end

  def ssl_generation(); end

  def ssl_timeout(); end

  def ssl_timeout=(ssl_timeout); end

  def ssl_version(); end

  def ssl_version=(ssl_version); end

  def start(http); end

  def timeout_key(); end

  def unescape(str); end

  def verify_callback(); end

  def verify_callback=(callback); end

  def verify_depth(); end

  def verify_depth=(verify_depth); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end

  def write_timeout(); end

  def write_timeout=(write_timeout); end
  DEFAULT_POOL_SIZE = ::T.let(nil, ::T.untyped)
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Persistent::Connection
  def close(); end

  def finish(); end

  def http(); end

  def http=(http); end

  def initialize(http_class, http_args, ssl_generation); end

  def last_use(); end

  def last_use=(last_use); end

  def requests(); end

  def requests=(requests); end

  def reset(); end

  def ressl(ssl_generation); end

  def ssl_generation(); end

  def ssl_generation=(ssl_generation); end
end

class Gem::Net::HTTP::Persistent::Connection
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Error
end

class Gem::Net::HTTP::Persistent::Pool
  def checkin(net_http_args); end

  def checkout(net_http_args); end

  def key(); end

  def shutdown(); end
end

class Gem::Net::HTTP::Persistent::Pool
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
end

class Gem::Net::HTTP::Persistent::TimedStackMulti
  def self.hash_of_arrays(); end
end

class Gem::Net::HTTP::Persistent
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Gem::Net::HTTP::Post
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Post
end

class Gem::Net::HTTP::Propfind
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Propfind
end

class Gem::Net::HTTP::Proppatch
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Proppatch
end

module Gem::Net::HTTP::ProxyDelta
end

module Gem::Net::HTTP::ProxyDelta
end

class Gem::Net::HTTP::Put
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Put
end

class Gem::Net::HTTP::Trace
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Trace
end

class Gem::Net::HTTP::Unlock
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTP::Unlock
end

class Gem::Net::HTTP
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_use_ssl=T.unsafe(nil)); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.default_port(); end

  def self.get(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_print(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.get_response(uri_or_host, path_or_headers=T.unsafe(nil), port=T.unsafe(nil), &block); end

  def self.http_default_port(); end

  def self.https_default_port(); end

  def self.is_version_1_1?(); end

  def self.is_version_1_2?(); end

  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil), p_no_proxy=T.unsafe(nil), p_use_ssl=T.unsafe(nil)); end

  def self.newobj(*arg, **arg1); end

  def self.post(url, data, header=T.unsafe(nil)); end

  def self.post_form(url, params); end

  def self.proxy_address(); end

  def self.proxy_class?(); end

  def self.proxy_pass(); end

  def self.proxy_port(); end

  def self.proxy_use_ssl(); end

  def self.proxy_user(); end

  def self.put(url, data, header=T.unsafe(nil)); end

  def self.socket_type(); end

  def self.start(address, *arg, &block); end

  def self.version_1_1?(); end

  def self.version_1_2(); end

  def self.version_1_2?(); end
end

class Gem::Net::HTTPAccepted
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAccepted
end

class Gem::Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPAlreadyReported
end

class Gem::Net::HTTPBadGateway
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadGateway
end

class Gem::Net::HTTPBadRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPBadRequest
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPBadResponse
end

class Gem::Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPClientError::EXCEPTION_TYPE = Gem::Net::HTTPClientException

class Gem::Net::HTTPClientError
end

class Gem::Net::HTTPClientException
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPClientException
end

class Gem::Net::HTTPConflict
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPConflict
end

class Gem::Net::HTTPContinue
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPContinue
end

class Gem::Net::HTTPCreated
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPCreated
end

class Gem::Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPEarlyHints
end

class Gem::Net::HTTPError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPError
end

module Gem::Net::HTTPExceptions
  def data(); end

  def initialize(msg, res); end

  def response(); end
end

module Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPExpectationFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPExpectationFailed
end

class Gem::Net::HTTPFailedDependency
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFailedDependency
end

class Gem::Net::HTTPFatalError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPFatalError
end

class Gem::Net::HTTPForbidden
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPForbidden
end

class Gem::Net::HTTPFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPFound
end

Gem::Net::HTTPGatewayTimeOut = Gem::Net::HTTPGatewayTimeout

class Gem::Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGatewayTimeout
end

class Gem::Net::HTTPGenericRequest
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(str); end

  def body_exist?(); end

  def body_stream(); end

  def body_stream=(input); end

  def decode_content(); end

  def exec(sock, ver, path); end

  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  def method(); end

  def path(); end

  def request_body_permitted?(); end

  def response_body_permitted?(); end

  def set_body_internal(str); end

  def update_uri(addr, port, ssl); end

  def uri(); end
end

class Gem::Net::HTTPGenericRequest::Chunker
  def finish(); end

  def initialize(sock); end

  def write(buf); end
end

class Gem::Net::HTTPGenericRequest::Chunker
end

class Gem::Net::HTTPGenericRequest
end

class Gem::Net::HTTPGone
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPGone
end

module Gem::Net::HTTPHeader
  def [](key); end

  def []=(key, val); end

  def add_field(key, val); end

  def basic_auth(account, password); end

  def canonical_each(); end

  def chunked?(); end

  def connection_close?(); end

  def connection_keep_alive?(); end

  def content_length(); end

  def content_length=(len); end

  def content_range(); end

  def content_type(); end

  def content_type=(type, params=T.unsafe(nil)); end

  def delete(key); end

  def each(&blk); end

  def each_capitalized(); end

  def each_capitalized_name(); end

  def each_header(); end

  def each_key(&block); end

  def each_name(&block); end

  def each_value(); end

  def fetch(key, *args, &block); end

  def form_data=(params, sep=T.unsafe(nil)); end

  def get_fields(key); end

  def initialize_http_header(initheader); end

  def key?(key); end

  def length(); end

  def main_type(); end

  def proxy_basic_auth(account, password); end

  def range(); end

  def range=(r, e=T.unsafe(nil)); end

  def range_length(); end

  def set_content_type(type, params=T.unsafe(nil)); end

  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  def set_form_data(params, sep=T.unsafe(nil)); end

  def set_range(r, e=T.unsafe(nil)); end

  def size(); end

  def sub_type(); end

  def to_hash(); end

  def type_params(); end
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

module Gem::Net::HTTPHeader
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPHeaderSyntaxError
end

class Gem::Net::HTTPIMUsed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPIMUsed
end

class Gem::Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPInformation::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPInformation
end

class Gem::Net::HTTPInsufficientStorage
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInsufficientStorage
end

class Gem::Net::HTTPInternalServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPInternalServerError
end

class Gem::Net::HTTPLengthRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLengthRequired
end

class Gem::Net::HTTPLocked
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLocked
end

class Gem::Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPLoopDetected
end

class Gem::Net::HTTPMethodNotAllowed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMethodNotAllowed
end

class Gem::Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMisdirectedRequest
end

class Gem::Net::HTTPMovedPermanently
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMovedPermanently
end

Gem::Net::HTTPMovedTemporarily = Gem::Net::HTTPFound

class Gem::Net::HTTPMultiStatus
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultiStatus
end

Gem::Net::HTTPMultipleChoice = Gem::Net::HTTPMultipleChoices

class Gem::Net::HTTPMultipleChoices
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPMultipleChoices
end

class Gem::Net::HTTPNetworkAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNetworkAuthenticationRequired
end

class Gem::Net::HTTPNoContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNoContent
end

class Gem::Net::HTTPNonAuthoritativeInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNonAuthoritativeInformation
end

class Gem::Net::HTTPNotAcceptable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotAcceptable
end

class Gem::Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotExtended
end

class Gem::Net::HTTPNotFound
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotFound
end

class Gem::Net::HTTPNotImplemented
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotImplemented
end

class Gem::Net::HTTPNotModified
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPNotModified
end

class Gem::Net::HTTPOK
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPOK
end

class Gem::Net::HTTPPartialContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPartialContent
end

class Gem::Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPayloadTooLarge
end

class Gem::Net::HTTPPaymentRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPaymentRequired
end

class Gem::Net::HTTPPermanentRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPermanentRedirect
end

class Gem::Net::HTTPPreconditionFailed
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionFailed
end

class Gem::Net::HTTPPreconditionRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPPreconditionRequired
end

class Gem::Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProcessing
end

class Gem::Net::HTTPProxyAuthenticationRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPProxyAuthenticationRequired
end

class Gem::Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRangeNotSatisfiable
end

class Gem::Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPRedirection::EXCEPTION_TYPE = Gem::Net::HTTPRetriableError

class Gem::Net::HTTPRedirection
end

class Gem::Net::HTTPRequest
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Gem::Net::HTTPRequest
end

Gem::Net::HTTPRequestEntityTooLarge = Gem::Net::HTTPPayloadTooLarge

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestHeaderFieldsTooLarge
end

Gem::Net::HTTPRequestTimeOut = Gem::Net::HTTPRequestTimeout

class Gem::Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPRequestTimeout
end

Gem::Net::HTTPRequestURITooLarge = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestURITooLong = Gem::Net::HTTPURITooLong

Gem::Net::HTTPRequestedRangeNotSatisfiable = Gem::Net::HTTPRangeNotSatisfiable

class Gem::Net::HTTPResetContent
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResetContent
end

class Gem::Net::HTTPResponse
  include ::Gem::Net::HTTPHeader
  def body(); end

  def body=(value); end

  def body_encoding(); end

  def body_encoding=(value); end

  def code(); end

  def code_type(); end

  def decode_content(); end

  def decode_content=(decode_content); end

  def entity(); end

  def error!(); end

  def error_type(); end

  def header(); end

  def http_version(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def initialize(httpv, code, msg); end

  def message(); end

  def msg(); end

  def read_body(dest=T.unsafe(nil), &block); end

  def read_header(); end

  def reading_body(sock, reqmethodallowbody); end

  def response(); end

  def uri(); end

  def uri=(uri); end

  def value(); end
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPResponse::Inflater
  def bytes_inflated(); end

  def finish(); end

  def inflate_adapter(dest); end

  def initialize(socket); end

  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  def read_all(dest); end
end

class Gem::Net::HTTPResponse::Inflater
end

class Gem::Net::HTTPResponse
  def self.body_permitted?(); end

  def self.exception_type(); end

  def self.read_new(sock); end
end

class Gem::Net::HTTPRetriableError
  include ::Gem::Net::HTTPExceptions
end

class Gem::Net::HTTPRetriableError
end

class Gem::Net::HTTPSeeOther
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSeeOther
end

class Gem::Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPServerError::EXCEPTION_TYPE = Gem::Net::HTTPFatalError

class Gem::Net::HTTPServerError
end

Gem::Net::HTTPServerException = Gem::Net::HTTPClientException

class Gem::Net::HTTPServiceUnavailable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPServiceUnavailable
end

Gem::Net::HTTPSession = Gem::Net::HTTP

class Gem::Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPSuccess::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPSuccess
end

class Gem::Net::HTTPSwitchProtocol
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPSwitchProtocol
end

class Gem::Net::HTTPTemporaryRedirect
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTemporaryRedirect
end

class Gem::Net::HTTPTooManyRequests
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPTooManyRequests
end

class Gem::Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPURITooLong
end

class Gem::Net::HTTPUnauthorized
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnauthorized
end

class Gem::Net::HTTPUnavailableForLegalReasons
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnavailableForLegalReasons
end

class Gem::Net::HTTPUnknownResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

Gem::Net::HTTPUnknownResponse::EXCEPTION_TYPE = Gem::Net::HTTPError

class Gem::Net::HTTPUnknownResponse
end

class Gem::Net::HTTPUnprocessableEntity
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnprocessableEntity
end

class Gem::Net::HTTPUnsupportedMediaType
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUnsupportedMediaType
end

class Gem::Net::HTTPUpgradeRequired
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUpgradeRequired
end

class Gem::Net::HTTPUseProxy
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPUseProxy
end

class Gem::Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVariantAlsoNegotiates
end

class Gem::Net::HTTPVersionNotSupported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Gem::Net::HTTPVersionNotSupported
end

class Gem::Net::InternetMessageIO
  def each_list_item(); end

  def each_message_chunk(); end

  def initialize(*arg, **arg1); end

  def write_message(src); end

  def write_message_0(src); end

  def write_message_by_block(&block); end
end

class Gem::Net::InternetMessageIO
end

module Gem::Net::NetPrivate
end

Gem::Net::NetPrivate::Socket = Gem::Net::InternetMessageIO

module Gem::Net::NetPrivate
end

class Gem::Net::OpenTimeout
end

class Gem::Net::OpenTimeout
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoAuthError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoCommandError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoFatalError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoRetriableError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoServerError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoSyntaxError
end

class Gem::Net::ProtoUnknownError
end

class Gem::Net::ProtoUnknownError
end

Gem::Net::ProtocRetryError = Gem::Net::ProtoRetriableError

class Gem::Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Net::Protocol
  def self.protocol_param(name, val); end
end

class Gem::Net::ProtocolError
end

class Gem::Net::ProtocolError
end

class Gem::Net::ReadAdapter
  def <<(str); end

  def initialize(block); end
end

class Gem::Net::ReadAdapter
end

class Gem::Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::ReadTimeout
end

class Gem::Net::WriteAdapter
  def <<(str); end

  def initialize(writer); end

  def print(str); end

  def printf(*args); end

  def puts(str=T.unsafe(nil)); end

  def write(str); end
end

class Gem::Net::WriteAdapter
end

class Gem::Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Gem::Net::WriteTimeout
end

module Gem::Net
end

class Gem::Package
  def copy_stream(src, dst); end

  def gem(); end

  def limit_read(io, name, limit); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::SymlinkError
  def initialize(name, destination, destination_dir); end
end

class Gem::Package::SymlinkError
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def full_name(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def check_closed(); end
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end

  def self.raw_spec(path, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end
  UNIVERSAL_MINGW = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
  X64_MINGW_LEGACY = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self._deprecated_match(platform); end

  def self.generic(platform); end

  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.platform_specificity_match(spec_platform, user_platform); end

  def self.sort_and_filter_best_platform_match(matching, platform); end

  def self.sort_best_platform_match(matching, platform); end

  def self.sort_priority(platform); end
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolv
  def each_address(name); end

  def each_name(address); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(resolvers=T.unsafe(nil), use_ipv6: T.unsafe(nil)); end
  AddressRegex = ::T.let(nil, ::T.untyped)
  DefaultResolver = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS
  def close(); end

  def each_address(name); end

  def each_name(address); end

  def each_resource(name, typeclass, &proc); end

  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def getresource(name, typeclass); end

  def getresources(name, typeclass); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end

  def timeouts=(values); end
  Port = ::T.let(nil, ::T.untyped)
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
  UDPSize = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end

  def use_ipv6?(); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::NXDomain
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config::OtherResolvError
end

class Gem::Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::DecodeError
end

class Gem::Resolv::DNS::EncodeError
end

class Gem::Resolv::DNS::EncodeError
end

module Gem::Resolv::DNS::Label
end

class Gem::Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Gem::Resolv::DNS::Label::Str
end

module Gem::Resolv::DNS::Label
  def self.split(arg); end
end

class Gem::Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_list(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Message::MessageDecoder
end

class Gem::Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d, compress: T.unsafe(nil)); end

  def put_length16(); end

  def put_name(d, compress: T.unsafe(nil)); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Gem::Resolv::DNS::Message::MessageEncoder
end

class Gem::Resolv::DNS::Message
  def self.decode(m); end
end

class Gem::Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def absolute?(); end

  def eql?(other); end

  def initialize(labels, absolute=T.unsafe(nil)); end

  def length(); end

  def subdomain_of?(other); end

  def to_a(); end
end

class Gem::Resolv::DNS::Name
  def self.create(arg); end
end

module Gem::Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::OpCode
end

class Gem::Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Gem::Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Gem::Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Gem::Resolv::DNS::RCode
end

class Gem::Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::ConnectedUDP
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::MDNSOneShot
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::RequestError
end

class Gem::Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Gem::Resolv::DNS::Requester::Sender
end

class Gem::Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::TCP::Sender
end

class Gem::Resolv::DNS::Requester::TCP
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Gem::Resolv::DNS::Requester::UnconnectedUDP
end

class Gem::Resolv::DNS::Requester
end

class Gem::Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end

  def ttl(); end
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::ANY
end

class Gem::Resolv::DNS::Resource::CAA
  def critical?(); end

  def flags(); end

  def initialize(flags, tag, value); end

  def tag(); end

  def value(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CAA
end

class Gem::Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::CNAME
end

module Gem::Resolv::DNS::Resource::ClassHash
end

module Gem::Resolv::DNS::Resource::ClassHash
  def self.[]=(type_class_value, klass); end
end

class Gem::Resolv::DNS::Resource::DomainName
  def initialize(name); end

  def name(); end
end

class Gem::Resolv::DNS::Resource::DomainName
end

class Gem::Resolv::DNS::Resource::Generic
  def data(); end

  def initialize(data); end
end

class Gem::Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Gem::Resolv::DNS::Resource::HINFO
  def cpu(); end

  def initialize(cpu, os); end

  def os(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::HINFO
end

module Gem::Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::A
end

class Gem::Resolv::DNS::Resource::IN::AAAA
  def address(); end

  def initialize(address); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::AAAA
end

Gem::Resolv::DNS::Resource::IN::ANY = Gem::Resolv::DNS::Resource::Type255_Class1

Gem::Resolv::DNS::Resource::IN::CAA = Gem::Resolv::DNS::Resource::Type257_Class1

Gem::Resolv::DNS::Resource::IN::CNAME = Gem::Resolv::DNS::Resource::Type5_Class1

Gem::Resolv::DNS::Resource::IN::HINFO = Gem::Resolv::DNS::Resource::Type13_Class1

class Gem::Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::HTTPS
end

Gem::Resolv::DNS::Resource::IN::LOC = Gem::Resolv::DNS::Resource::Type29_Class1

Gem::Resolv::DNS::Resource::IN::MINFO = Gem::Resolv::DNS::Resource::Type14_Class1

Gem::Resolv::DNS::Resource::IN::MX = Gem::Resolv::DNS::Resource::Type15_Class1

Gem::Resolv::DNS::Resource::IN::NS = Gem::Resolv::DNS::Resource::Type2_Class1

Gem::Resolv::DNS::Resource::IN::PTR = Gem::Resolv::DNS::Resource::Type12_Class1

Gem::Resolv::DNS::Resource::IN::SOA = Gem::Resolv::DNS::Resource::Type6_Class1

class Gem::Resolv::DNS::Resource::IN::SRV
  def initialize(priority, weight, port, target); end

  def port(); end

  def priority(); end

  def target(); end

  def weight(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SRV
end

class Gem::Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::SVCB
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Gem::Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

Gem::Resolv::DNS::Resource::IN::TXT = Gem::Resolv::DNS::Resource::Type16_Class1

class Gem::Resolv::DNS::Resource::IN::WKS
  def address(); end

  def bitmap(); end

  def initialize(address, protocol, bitmap); end

  def protocol(); end
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::IN::WKS
end

module Gem::Resolv::DNS::Resource::IN
end

class Gem::Resolv::DNS::Resource::LOC
  def altitude(); end

  def hprecision(); end

  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end

  def latitude(); end

  def longitude(); end

  def ssize(); end

  def version(); end

  def vprecision(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::LOC
end

class Gem::Resolv::DNS::Resource::MINFO
  def emailbx(); end

  def initialize(rmailbx, emailbx); end

  def rmailbx(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MINFO
end

class Gem::Resolv::DNS::Resource::MX
  def exchange(); end

  def initialize(preference, exchange); end

  def preference(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::MX
end

class Gem::Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::NS
end

class Gem::Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::PTR
end

class Gem::Resolv::DNS::Resource::SOA
  def expire(); end

  def initialize(mname, rname, serial, refresh, retry_, expire, minimum); end

  def minimum(); end

  def mname(); end

  def refresh(); end

  def retry(); end

  def rname(); end

  def serial(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::SOA
end

class Gem::Resolv::DNS::Resource::TXT
  def data(); end

  def initialize(first_string, *rest_strings); end

  def strings(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::TXT
end

Gem::Resolv::DNS::Resource::Type11_Class1 = Gem::Resolv::DNS::Resource::IN::WKS

class Gem::Resolv::DNS::Resource::Type12_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type12_Class1
end

class Gem::Resolv::DNS::Resource::Type13_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type13_Class1
end

class Gem::Resolv::DNS::Resource::Type14_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type14_Class1
end

class Gem::Resolv::DNS::Resource::Type15_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type15_Class1
end

class Gem::Resolv::DNS::Resource::Type16_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type16_Class1
end

Gem::Resolv::DNS::Resource::Type1_Class1 = Gem::Resolv::DNS::Resource::IN::A

class Gem::Resolv::DNS::Resource::Type255_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type255_Class1
end

class Gem::Resolv::DNS::Resource::Type257_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type257_Class1
end

Gem::Resolv::DNS::Resource::Type28_Class1 = Gem::Resolv::DNS::Resource::IN::AAAA

class Gem::Resolv::DNS::Resource::Type29_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type29_Class1
end

class Gem::Resolv::DNS::Resource::Type2_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type2_Class1
end

Gem::Resolv::DNS::Resource::Type33_Class1 = Gem::Resolv::DNS::Resource::IN::SRV

class Gem::Resolv::DNS::Resource::Type5_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type5_Class1
end

Gem::Resolv::DNS::Resource::Type64_Class1 = Gem::Resolv::DNS::Resource::IN::SVCB

Gem::Resolv::DNS::Resource::Type65_Class1 = Gem::Resolv::DNS::Resource::IN::HTTPS

class Gem::Resolv::DNS::Resource::Type6_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::Resource::Type6_Class1
end

class Gem::Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Gem::Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Gem::Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Gem::Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Gem::Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Gem::Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Gem::Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.open(*args); end

  def self.random(arg); end
end

class Gem::Resolv::Hosts
  def each_address(name, &proc); end

  def each_name(address, &proc); end

  def getaddress(name); end

  def getaddresses(name); end

  def getname(address); end

  def getnames(address); end

  def initialize(filename=T.unsafe(nil)); end

  def lazy_initialize(); end
  DefaultFileName = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::Hosts
end

class Gem::Resolv::IPv4
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex256 = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv4
  def self.create(arg); end
end

class Gem::Resolv::IPv6
  def ==(other); end

  def address(); end

  def eql?(other); end

  def initialize(address); end

  def to_name(); end
  Regex = ::T.let(nil, ::T.untyped)
  Regex_6Hex4Dec = ::T.let(nil, ::T.untyped)
  Regex_8Hex = ::T.let(nil, ::T.untyped)
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex = ::T.let(nil, ::T.untyped)
  Regex_CompressedHex4Dec = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::IPv6
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::LOC::Alt
  def ==(other); end

  def altitude(); end

  def eql?(other); end

  def initialize(altitude); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Alt
  def self.create(arg); end
end

class Gem::Resolv::LOC::Coord
  def ==(other); end

  def coordinates(); end

  def eql?(other); end

  def initialize(coordinates, orientation); end

  def orientation(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Coord
  def self.create(arg); end
end

class Gem::Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end

  def initialize(scalar); end

  def scalar(); end
  Regex = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::LOC::Size
  def self.create(arg); end
end

module Gem::Resolv::LOC
end

class Gem::Resolv::MDNS
  AddressV4 = ::T.let(nil, ::T.untyped)
  AddressV6 = ::T.let(nil, ::T.untyped)
  Addresses = ::T.let(nil, ::T.untyped)
  Port = ::T.let(nil, ::T.untyped)
end

class Gem::Resolv::MDNS
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvError
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv::ResolvTimeout
end

class Gem::Resolv
  def self.each_address(name, &block); end

  def self.each_name(address, &proc); end

  def self.getaddress(name); end

  def self.getaddresses(name); end

  def self.getname(address); end

  def self.getnames(address); end
end

class Gem::Resolver
  include ::Gem::Molinillo::UI
  include ::Gem::Molinillo::SpecificationProvider
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::SecureRandom
  VERSION = ::T.let(nil, ::T.untyped)
end

module Gem::SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
end

module Gem::Security
  DEFAULT_KEY_ALGORITHM = ::T.let(nil, ::T.untyped)
  EC_NAME = ::T.let(nil, ::T.untyped)
  RSA_DSA_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_digest(algorithm=T.unsafe(nil)); end

  def self.create_key(algorithm); end

  def self.email_to_name(email_address); end

  def self.get_public_key(key); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::Source::Git
  def git_command(); end
end

class Gem::SourceIndex
  include ::Enumerable
  def ==(other); end

  def add_spec(gem_spec, name=T.unsafe(nil)); end

  def add_specs(*gem_specs); end

  def all_gems(); end

  def dump(); end

  def each(&block); end

  def find_name(gem_name, requirement=T.unsafe(nil)); end

  def gem_signature(gem_full_name); end

  def gems(); end

  def index_signature(); end

  def initialize(specifications=T.unsafe(nil)); end

  def latest_specs(include_prerelease=T.unsafe(nil)); end

  def length(); end

  def load_gems_in(*spec_dirs); end

  def outdated(); end

  def prerelease_gems(); end

  def prerelease_specs(); end

  def refresh!(); end

  def released_gems(); end

  def released_specs(); end

  def remove_spec(full_name); end

  def search(gem_pattern, platform_only=T.unsafe(nil)); end

  def size(); end

  def spec_dirs(); end

  def spec_dirs=(spec_dirs); end

  def specification(full_name); end
end

class Gem::SourceIndex
  def self.from_gems_in(*spec_dirs); end

  def self.from_installed_gems(*deprecated); end

  def self.installed_spec_directories(); end

  def self.load_specification(file_name); end
end

class Gem::SourceList
  def append(obj); end

  def prepend(obj); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def sources(); end

  def specs(); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Gem::Specification::AllowSettingSource
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def conflicts_when_loaded_with?(list_of_specs); end

  def flatten_require_paths(); end

  def insecurely_materialized?(); end

  def installation_missing?(); end

  def lock_name(); end

  def removed_method_calls(); end

  def to_ruby(); end

  def validate_for_resolution(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

module Gem::Specification::AllowSettingSource
  def source(); end

  def source=(source); end
end

module Gem::Specification::AllowSettingSource
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.find_by_full_name(full_name); end

  def self.gemspec_stubs_in(dir, pattern); end

  def self.latest_spec_for(name); end

  def self.specification_record(); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_for_resolution(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end

  def validate_required_metadata!(); end

  def validate_required_ruby_version(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::SpecificationRecord
  include ::Enumerable
  def add_spec(spec); end

  def all(); end

  def all=(specs); end

  def all_names(); end

  def each(&blk); end

  def find_active_stub_by_path(path); end

  def find_all_by_name(name, *requirements); end

  def find_by_path(path); end

  def find_inactive_by_path(path); end

  def initialize(dirs); end

  def latest_spec_for(name); end

  def latest_specs(prerelease); end

  def remove_spec(spec); end

  def stubs(); end

  def stubs_for(name); end

  def stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationRecord
  def self.dirs_from(paths); end

  def self.from_path(path); end
end

class Gem::StubSpecification
  include ::Gem::BetterPermissionError
  def ==(other); end

  def build_extensions(); end

  def eql?(other); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def sort_obj(); end

  def spec(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::TSort::Cyclic
end

class Gem::TSort::Cyclic
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Gem::TargetRbConfig
  def [](key); end

  def initialize(rbconfig, path); end

  def path(); end
end

class Gem::TargetRbConfig
  def self.for_running_ruby(); end

  def self.from_path(rbconfig_path); end
end

module Gem::Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Timeout::Error
end

class Gem::Timeout::Error
  def self.handle_timeout(message); end
end

class Gem::Timeout::ExitException
  def exception(*arg); end
end

class Gem::Timeout::ExitException
end

module Gem::Timeout
  def self.ensure_timeout_thread_created(); end

  def self.timeout(sec, klass=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module Gem::URI
  ABS_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  RFC2396_PARSER = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Gem::URI::BadURIError
end

class Gem::URI::BadURIError
end

class Gem::URI::Error
end

class Gem::URI::Error
end

class Gem::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Gem::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Gem::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::File
end

class Gem::URI::Generic
  include ::Gem::URI
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def to_str(); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Gem::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Gem::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTP
end

class Gem::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::HTTPS
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidComponentError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::InvalidURIError
end

class Gem::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAP
end

class Gem::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::LDAPS
end

class Gem::URI::MailTo
  include ::Gem::URI::RFC2396_REGEXP
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::URI::MailTo
end

Gem::URI::Parser = Gem::URI::RFC3986_Parser

class Gem::URI::RFC2396_Parser
  include ::Gem::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
  TO_S = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC2396_Parser
end

module Gem::URI::RFC2396_REGEXP
end

module Gem::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Gem::URI::RFC2396_REGEXP::PATTERN
end

module Gem::URI::RFC2396_REGEXP
end

class Gem::URI::RFC3986_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil), &block); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Gem::URI::RFC3986_Parser
end

module Gem::URI::Util
end

module Gem::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Gem::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WS
end

class Gem::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Gem::URI::WSS
end

module Gem::URI
  def self.const_missing(const); end

  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.parser=(parser=T.unsafe(nil)); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

class Gem::Version
  def partition_segments(ver); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::WebauthnVerificationError
  def initialize(message); end
end

class Gem::WebauthnVerificationError
end

module Gem::YAMLSerializer
  ARRAY_REGEX = ::T.let(nil, ::T.untyped)
  HASH_REGEX = ::T.let(nil, ::T.untyped)
end

module Gem::YAMLSerializer
  def self.dump(hash); end

  def self.load(str); end

  def self.strip_comment(val); end
end

module Gem
  def self.activate_and_load_bin_path(name, exec_name=T.unsafe(nil), *requirements); end

  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.default_user_install(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.dynamic_library_suffixes(); end

  def self.find_config_file(); end

  def self.find_default_spec(path); end

  def self.freebsd_platform?(); end

  def self.load_bundler_extensions(version); end

  def self.load_safe_marshal(); end

  def self.open_file(path, flags, &block); end

  def self.open_file_with_flock(path, &block); end

  def self.open_file_with_lock(path, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.set_target_rbconfig(rbconfig_path); end

  def self.solaris_platform?(); end

  def self.source_index(); end

  def self.state_file(); end

  def self.state_home(); end

  def self.target_rbconfig(); end
end

module Gherkin
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DIALECTS = ::T.let(nil, ::T.untyped)
  DIALECT_FILE_PATH = ::T.let(nil, ::T.untyped)
  RULE_TYPE = ::T.let(nil, ::T.untyped)
end

class Gherkin::AstBuilder
  def build(token); end

  def current_node(); end

  def end_rule(_rule_type); end

  def ensure_cell_count(rows); end

  def get_cells(table_row_token); end

  def get_description(node); end

  def get_location(token, column); end

  def get_result(); end

  def get_steps(node); end

  def get_table_rows(node); end

  def get_tags(node); end

  def initialize(id_generator); end

  def reset(); end

  def start_rule(rule_type); end

  def transform_node(node); end
end

class Gherkin::AstBuilder
end

class Gherkin::AstBuilderException
end

class Gherkin::AstBuilderException
end

class Gherkin::AstNode
  def add(rule_type, obj); end

  def get_items(rule_type); end

  def get_single(rule_type); end

  def get_token(token_type); end

  def get_tokens(token_type); end

  def initialize(rule_type); end

  def rule_type(); end
end

class Gherkin::AstNode
end

class Gherkin::AstNodeNotLocatedException
end

class Gherkin::AstNodeNotLocatedException
end

class Gherkin::CompositeParserException
  def errors(); end

  def initialize(errors); end
end

class Gherkin::CompositeParserException
end

class Gherkin::Dialect
  def and_keywords(); end

  def background_keywords(); end

  def but_keywords(); end

  def examples_keywords(); end

  def feature_keywords(); end

  def given_keywords(); end

  def initialize(spec); end

  def rule_keywords(); end

  def scenario_keywords(); end

  def scenario_outline_keywords(); end

  def then_keywords(); end

  def when_keywords(); end
end

class Gherkin::Dialect
  def self.for(name); end
end

class Gherkin::DoubleIterationException
end

class Gherkin::DoubleIterationException
end

class Gherkin::GherkinLine
  def empty?(); end

  def get_line_text(indent_to_remove); end

  def get_rest_trimmed(length); end

  def indent(); end

  def initialize(line_text, line_number); end

  def split_table_cells(row); end

  def start_with?(prefix); end

  def start_with_title_keyword?(keyword); end

  def table_cells(); end

  def tags(); end

  def trimmed_line_text(); end
end

class Gherkin::GherkinLine::Span
end

class Gherkin::GherkinLine::Span
end

class Gherkin::GherkinLine
end

class Gherkin::NoSuchLanguageException
  def initialize(language, location); end
end

class Gherkin::NoSuchLanguageException
end

class Gherkin::Parser
  def add_error(context, error); end

  def build(context, token); end

  def end_rule(context, rule_type); end

  def get_result(); end

  def initialize(ast_builder=T.unsafe(nil)); end

  def lookahead0(context, current_token); end

  def lookahead1(context, current_token); end

  def match_BackgroundLine(context, token); end

  def match_Comment(context, token); end

  def match_DocStringSeparator(context, token); end

  def match_EOF(context, token); end

  def match_Empty(context, token); end

  def match_ExamplesLine(context, token); end

  def match_FeatureLine(context, token); end

  def match_Language(context, token); end

  def match_Other(context, token); end

  def match_RuleLine(context, token); end

  def match_ScenarioLine(context, token); end

  def match_StepLine(context, token); end

  def match_TableRow(context, token); end

  def match_TagLine(context, token); end

  def match_token(state, token, context); end

  def match_token_at_state0(token, context); end

  def match_token_at_state1(token, context); end

  def match_token_at_state10(token, context); end

  def match_token_at_state11(token, context); end

  def match_token_at_state12(token, context); end

  def match_token_at_state13(token, context); end

  def match_token_at_state14(token, context); end

  def match_token_at_state15(token, context); end

  def match_token_at_state16(token, context); end

  def match_token_at_state17(token, context); end

  def match_token_at_state18(token, context); end

  def match_token_at_state19(token, context); end

  def match_token_at_state2(token, context); end

  def match_token_at_state20(token, context); end

  def match_token_at_state21(token, context); end

  def match_token_at_state22(token, context); end

  def match_token_at_state23(token, context); end

  def match_token_at_state24(token, context); end

  def match_token_at_state25(token, context); end

  def match_token_at_state26(token, context); end

  def match_token_at_state27(token, context); end

  def match_token_at_state28(token, context); end

  def match_token_at_state29(token, context); end

  def match_token_at_state3(token, context); end

  def match_token_at_state30(token, context); end

  def match_token_at_state31(token, context); end

  def match_token_at_state32(token, context); end

  def match_token_at_state33(token, context); end

  def match_token_at_state35(token, context); end

  def match_token_at_state36(token, context); end

  def match_token_at_state37(token, context); end

  def match_token_at_state38(token, context); end

  def match_token_at_state39(token, context); end

  def match_token_at_state4(token, context); end

  def match_token_at_state40(token, context); end

  def match_token_at_state41(token, context); end

  def match_token_at_state42(token, context); end

  def match_token_at_state5(token, context); end

  def match_token_at_state6(token, context); end

  def match_token_at_state7(token, context); end

  def match_token_at_state8(token, context); end

  def match_token_at_state9(token, context); end

  def parse(token_scanner, token_matcher=T.unsafe(nil)); end

  def read_token(context); end

  def start_rule(context, rule_type); end

  def stop_at_first_error(); end

  def stop_at_first_error=(stop_at_first_error); end
end

class Gherkin::Parser
end

class Gherkin::ParserContext
  def errors(); end

  def initialize(token_scanner, token_matcher, token_queue, errors); end

  def token_matcher(); end

  def token_queue(); end

  def token_scanner(); end
end

class Gherkin::ParserContext
end

class Gherkin::ParserError
end

class Gherkin::ParserError
end

class Gherkin::ParserException
  def initialize(message, location); end

  def location(); end
end

class Gherkin::ParserException
end

module Gherkin::Pickles
end

class Gherkin::Pickles::Compiler
  def compile(gherkin_document, source); end

  def initialize(id_generator); end
end

class Gherkin::Pickles::Compiler
end

module Gherkin::Pickles
end

class Gherkin::Query
  def location(ast_node_id); end

  def scenario_parent_locations(scenario_node_id); end

  def update(message); end
end

class Gherkin::Query
end

module Gherkin::Stream
end

class Gherkin::Stream::ParserMessageStream
  def initialize(paths, sources, options); end

  def messages(); end
end

class Gherkin::Stream::ParserMessageStream
end

module Gherkin::Stream
end

class Gherkin::Token
  def detach(); end

  def eof?(); end

  def matched_gherkin_dialect(); end

  def matched_gherkin_dialect=(matched_gherkin_dialect); end

  def matched_indent(); end

  def matched_indent=(matched_indent); end

  def matched_items(); end

  def matched_items=(matched_items); end

  def matched_keyword(); end

  def matched_keyword=(matched_keyword); end

  def matched_keyword_type(); end

  def matched_keyword_type=(matched_keyword_type); end

  def matched_text(); end

  def matched_text=(matched_text); end

  def matched_type(); end

  def matched_type=(matched_type); end

  def token_value(); end
end

class Gherkin::Token
end

class Gherkin::TokenMatcher
  def _match_DocStringSeparator(token, separator, is_open); end

  def initialize(dialect_name=T.unsafe(nil)); end

  def match_BackgroundLine(token); end

  def match_Comment(token); end

  def match_DocStringSeparator(token); end

  def match_EOF(token); end

  def match_Empty(token); end

  def match_ExamplesLine(token); end

  def match_FeatureLine(token); end

  def match_Language(token); end

  def match_Other(token); end

  def match_RuleLine(token); end

  def match_ScenarioLine(token); end

  def match_StepLine(token); end

  def match_TableRow(token); end

  def match_TagLine(token); end

  def reset(); end
  LANGUAGE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gherkin::TokenMatcher
end

class Gherkin::TokenScanner
  def initialize(source_or_io); end

  def read(); end
end

class Gherkin::TokenScanner
end

class Gherkin::UnexpectedEOFException
  def initialize(received_token, expected_token_types, _state_comment); end
end

class Gherkin::UnexpectedEOFException
end

class Gherkin::UnexpectedTokenException
  def initialize(received_token, expected_token_types, _state_comment); end
end

class Gherkin::UnexpectedTokenException
end

module Gherkin
  def self.encode_source_message(uri, data); end

  def self.from_paths(paths, options=T.unsafe(nil)); end

  def self.from_source(uri, data, options=T.unsafe(nil)); end

  def self.from_sources(sources, options=T.unsafe(nil)); end
end

class Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def path(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def ttyname(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(*arg); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def private?(); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end

  def self.string(arg); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*arg); end

  def raw!(*arg); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*arg); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def as_json(*arg); end

  def begin_addr(); end

  def cidr(); end

  def end_addr(); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def to_json(*a); end

  def wildcard_mask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Insertion
  def after(val, recursive=T.unsafe(nil)); end

  def after_any(val); end

  def before(val, recursive=T.unsafe(nil)); end

  def before_any(val); end

  def initialize(list, value); end
end

class Insertion
end

class Integer
  def ceildiv(other); end

  def to_bn(); end
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Coder
  def dump(object, io=T.unsafe(nil)); end

  def generate(object, io=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &as_json); end

  def load(source); end

  def load_file(path); end

  def parse(source); end
end

class JSON::Ext::Generator::State
  def allow_nan=(allow_nan); end

  def as_json(); end

  def as_json=(as_json); end

  def ascii_only=(ascii_only); end

  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end

  def script_safe(); end

  def script_safe=(script_safe); end

  def script_safe?(); end

  def strict(); end

  def strict=(strict); end

  def strict?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end

  def self.generate(arg, arg1, arg2); end
end

class JSON::Ext::Parser
  def initialize(source, opts=T.unsafe(nil)); end
end

class JSON::Ext::Parser
  def self.parse(arg, arg1); end
end

class JSON::Ext::ParserConfig
  def initialize(arg); end

  def parse(arg); end
end

class JSON::Fragment
  def initialize(json); end

  def json(); end

  def json=(_); end

  def to_json(state=T.unsafe(nil), *arg); end
end

class JSON::Fragment
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class JSON::GeneratorError
  def detailed_message(*arg, **arg1, &arg2); end

  def initialize(message, invalid_object=T.unsafe(nil)); end

  def invalid_object(); end
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  def column(); end

  def line(); end
end

module JSON::ParserOptions
end

module JSON::ParserOptions
  def self.prepare(opts); end
end

JSON::State = JSON::Ext::Generator::State

module JSON
  def self._dump_default_options(); end

  def self._load_default_options(); end

  def self._unsafe_load_default_options(); end

  def self.deprecation_warning(message, uplevel=T.unsafe(nil)); end

  def self.unsafe_load(source, proc=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load_default_options(); end

  def self.unsafe_load_default_options=(val); end
end

module Kernel
  def Namespace(name); end

  def TypeName(string); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.no_warning_require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module LanguageServer
end

module LanguageServer::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant
end

module LanguageServer::Protocol::Constant::CodeActionKind
  EMPTY = ::T.let(nil, ::T.untyped)
  QUICK_FIX = ::T.let(nil, ::T.untyped)
  REFACTOR = ::T.let(nil, ::T.untyped)
  REFACTOR_EXTRACT = ::T.let(nil, ::T.untyped)
  REFACTOR_INLINE = ::T.let(nil, ::T.untyped)
  REFACTOR_REWRITE = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SOURCE_FIX_ALL = ::T.let(nil, ::T.untyped)
  SOURCE_ORGANIZE_IMPORTS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionKind
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
  AUTOMATIC = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
end

module LanguageServer::Protocol::Constant::CompletionItemKind
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemKind
end

module LanguageServer::Protocol::Constant::CompletionItemTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemTag
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
  TRIGGER_FOR_INCOMPLETE_COMPLETIONS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
end

module LanguageServer::Protocol::Constant::DiagnosticTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
  UNNECESSARY = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticTag
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
  FULL = ::T.let(nil, ::T.untyped)
  UNCHANGED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
  READ = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
end

module LanguageServer::Protocol::Constant::ErrorCodes
  CONTENT_MODIFIED = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  REQUEST_FAILED = ::T.let(nil, ::T.untyped)
  SERVER_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ErrorCodes
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
  ABORT = ::T.let(nil, ::T.untyped)
  TEXT_ONLY_TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  UNDO = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
end

module LanguageServer::Protocol::Constant::FileChangeType
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileChangeType
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
  COMMENT = ::T.let(nil, ::T.untyped)
  IMPORTS = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
  UNKNOWN_PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
end

module LanguageServer::Protocol::Constant::InlayHintKind
  PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InlayHintKind
end

module LanguageServer::Protocol::Constant::InsertTextFormat
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextFormat
end

module LanguageServer::Protocol::Constant::InsertTextMode
  ADJUST_INDENTATION = ::T.let(nil, ::T.untyped)
  AS_IS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextMode
end

module LanguageServer::Protocol::Constant::MarkupKind
  MARKDOWN = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MarkupKind
end

module LanguageServer::Protocol::Constant::MessageType
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MessageType
end

module LanguageServer::Protocol::Constant::MonikerKind
  EXPORT = ::T.let(nil, ::T.untyped)
  IMPORT = ::T.let(nil, ::T.untyped)
  LOCAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MonikerKind
end

module LanguageServer::Protocol::Constant::NotebookCellKind
  CODE = ::T.let(nil, ::T.untyped)
  MARKUP = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::NotebookCellKind
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
  IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  RENAME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
  ABSTRACT = ::T.let(nil, ::T.untyped)
  ASYNC = ::T.let(nil, ::T.untyped)
  DECLARATION = ::T.let(nil, ::T.untyped)
  DEFAULT_LIBRARY = ::T.let(nil, ::T.untyped)
  DEFINITION = ::T.let(nil, ::T.untyped)
  DEPRECATED = ::T.let(nil, ::T.untyped)
  DOCUMENTATION = ::T.let(nil, ::T.untyped)
  MODIFICATION = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  STATIC = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
  CLASS = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECORATOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  MACRO = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
  CONTENT_CHANGE = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
end

module LanguageServer::Protocol::Constant::SymbolKind
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolKind
end

module LanguageServer::Protocol::Constant::SymbolTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolTag
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
  AFTER_DELAY = ::T.let(nil, ::T.untyped)
  FOCUS_OUT = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
end

module LanguageServer::Protocol::Constant::TokenFormat
  RELATIVE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TokenFormat
end

module LanguageServer::Protocol::Constant::UniquenessLevel
  DOCUMENT = ::T.let(nil, ::T.untyped)
  GLOBAL = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  PROJECT = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::UniquenessLevel
end

module LanguageServer::Protocol::Constant::WatchKind
  CHANGE = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::WatchKind
end

module LanguageServer::Protocol::Constant
end

module LanguageServer::Protocol::Interface
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
  def annotation_id(); end

  def attributes(); end

  def initialize(range:, new_text:, annotation_id:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::AnnotatedTextEdit
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
  def attributes(); end

  def edit(); end

  def initialize(edit:, label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditParams
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
  def applied(); end

  def attributes(); end

  def failed_change(); end

  def failure_reason(); end

  def initialize(applied:, failure_reason: T.unsafe(nil), failed_change: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ApplyWorkspaceEditResult
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyClientCapabilities
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
  def attributes(); end

  def from(); end

  def from_ranges(); end

  def initialize(from:, from_ranges:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCall
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyIncomingCallsParams
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyItem
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOptions
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
  def attributes(); end

  def from_ranges(); end

  def initialize(to:, from_ranges:); end

  def to(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCall
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyOutgoingCallsParams
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyPrepareParams
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CallHierarchyRegistrationOptions
end

class LanguageServer::Protocol::Interface::CancelParams
  def attributes(); end

  def id(); end

  def initialize(id:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CancelParams
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
  def attributes(); end

  def description(); end

  def initialize(label:, needs_confirmation: T.unsafe(nil), description: T.unsafe(nil)); end

  def label(); end

  def needs_confirmation(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ChangeAnnotation
end

class LanguageServer::Protocol::Interface::ClientCapabilities
  def attributes(); end

  def experimental(); end

  def general(); end

  def initialize(workspace: T.unsafe(nil), text_document: T.unsafe(nil), notebook_document: T.unsafe(nil), window: T.unsafe(nil), general: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def notebook_document(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def window(); end

  def workspace(); end
end

class LanguageServer::Protocol::Interface::ClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeAction
  def attributes(); end

  def command(); end

  def data(); end

  def diagnostics(); end

  def disabled(); end

  def edit(); end

  def initialize(title:, kind: T.unsafe(nil), diagnostics: T.unsafe(nil), is_preferred: T.unsafe(nil), disabled: T.unsafe(nil), edit: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def is_preferred(); end

  def kind(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeAction
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
  def attributes(); end

  def code_action_literal_support(); end

  def data_support(); end

  def disabled_support(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), code_action_literal_support: T.unsafe(nil), is_preferred_support: T.unsafe(nil), disabled_support: T.unsafe(nil), data_support: T.unsafe(nil), resolve_support: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def is_preferred_support(); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeActionClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeActionContext
  def attributes(); end

  def diagnostics(); end

  def initialize(diagnostics:, only: T.unsafe(nil), trigger_kind: T.unsafe(nil)); end

  def only(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CodeActionContext
end

class LanguageServer::Protocol::Interface::CodeActionOptions
  def attributes(); end

  def code_action_kinds(); end

  def initialize(work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionOptions
end

class LanguageServer::Protocol::Interface::CodeActionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeActionParams
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
  def attributes(); end

  def code_action_kinds(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), code_action_kinds: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeActionRegistrationOptions
end

class LanguageServer::Protocol::Interface::CodeDescription
  def attributes(); end

  def href(); end

  def initialize(href:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeDescription
end

class LanguageServer::Protocol::Interface::CodeLens
  def attributes(); end

  def command(); end

  def data(); end

  def initialize(range:, command: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLens
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensClientCapabilities
end

class LanguageServer::Protocol::Interface::CodeLensOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensOptions
end

class LanguageServer::Protocol::Interface::CodeLensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CodeLensParams
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CodeLensRegistrationOptions
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CodeLensWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::Color
  def alpha(); end

  def attributes(); end

  def blue(); end

  def green(); end

  def initialize(red:, green:, blue:, alpha:); end

  def red(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Color
end

class LanguageServer::Protocol::Interface::ColorInformation
  def attributes(); end

  def color(); end

  def initialize(range:, color:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorInformation
end

class LanguageServer::Protocol::Interface::ColorPresentation
  def additional_text_edits(); end

  def attributes(); end

  def initialize(label:, text_edit: T.unsafe(nil), additional_text_edits: T.unsafe(nil)); end

  def label(); end

  def text_edit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ColorPresentation
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
  def attributes(); end

  def color(); end

  def initialize(text_document:, color:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ColorPresentationParams
end

class LanguageServer::Protocol::Interface::Command
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(title:, command:, arguments: T.unsafe(nil)); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Command
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
  def attributes(); end

  def completion_item(); end

  def completion_item_kind(); end

  def completion_list(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), completion_item: T.unsafe(nil), completion_item_kind: T.unsafe(nil), context_support: T.unsafe(nil), insert_text_mode: T.unsafe(nil), completion_list: T.unsafe(nil)); end

  def insert_text_mode(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionClientCapabilities
end

class LanguageServer::Protocol::Interface::CompletionContext
  def attributes(); end

  def initialize(trigger_kind:, trigger_character: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::CompletionContext
end

class LanguageServer::Protocol::Interface::CompletionItem
  def additional_text_edits(); end

  def attributes(); end

  def command(); end

  def commit_characters(); end

  def data(); end

  def deprecated(); end

  def detail(); end

  def documentation(); end

  def filter_text(); end

  def initialize(label:, label_details: T.unsafe(nil), kind: T.unsafe(nil), tags: T.unsafe(nil), detail: T.unsafe(nil), documentation: T.unsafe(nil), deprecated: T.unsafe(nil), preselect: T.unsafe(nil), sort_text: T.unsafe(nil), filter_text: T.unsafe(nil), insert_text: T.unsafe(nil), insert_text_format: T.unsafe(nil), insert_text_mode: T.unsafe(nil), text_edit: T.unsafe(nil), text_edit_text: T.unsafe(nil), additional_text_edits: T.unsafe(nil), commit_characters: T.unsafe(nil), command: T.unsafe(nil), data: T.unsafe(nil)); end

  def insert_text(); end

  def insert_text_format(); end

  def insert_text_mode(); end

  def kind(); end

  def label(); end

  def label_details(); end

  def preselect(); end

  def sort_text(); end

  def tags(); end

  def text_edit(); end

  def text_edit_text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItem
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
  def attributes(); end

  def description(); end

  def detail(); end

  def initialize(detail: T.unsafe(nil), description: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionItemLabelDetails
end

class LanguageServer::Protocol::Interface::CompletionList
  def attributes(); end

  def initialize(is_incomplete:, items:, item_defaults: T.unsafe(nil)); end

  def is_incomplete(); end

  def item_defaults(); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CompletionList
end

class LanguageServer::Protocol::Interface::CompletionOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionOptions
end

class LanguageServer::Protocol::Interface::CompletionParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::CompletionParams
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
  def all_commit_characters(); end

  def attributes(); end

  def completion_item(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), all_commit_characters: T.unsafe(nil), resolve_provider: T.unsafe(nil), completion_item: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::CompletionRegistrationOptions
end

class LanguageServer::Protocol::Interface::ConfigurationItem
  def attributes(); end

  def initialize(scope_uri: T.unsafe(nil), section: T.unsafe(nil)); end

  def scope_uri(); end

  def section(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationItem
end

class LanguageServer::Protocol::Interface::ConfigurationParams
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ConfigurationParams
end

class LanguageServer::Protocol::Interface::CreateFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::CreateFile
end

class LanguageServer::Protocol::Interface::CreateFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFileOptions
end

class LanguageServer::Protocol::Interface::CreateFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::CreateFilesParams
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeclarationClientCapabilities
end

class LanguageServer::Protocol::Interface::DeclarationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationOptions
end

class LanguageServer::Protocol::Interface::DeclarationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DeclarationParams
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DeclarationRegistrationOptions
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DefinitionClientCapabilities
end

class LanguageServer::Protocol::Interface::DefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionOptions
end

class LanguageServer::Protocol::Interface::DefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DefinitionParams
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DefinitionRegistrationOptions
end

class LanguageServer::Protocol::Interface::DeleteFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::DeleteFile
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
  def attributes(); end

  def ignore_if_not_exists(); end

  def initialize(recursive: T.unsafe(nil), ignore_if_not_exists: T.unsafe(nil)); end

  def recursive(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFileOptions
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DeleteFilesParams
end

class LanguageServer::Protocol::Interface::Diagnostic
  def attributes(); end

  def code(); end

  def code_description(); end

  def data(); end

  def initialize(range:, message:, severity: T.unsafe(nil), code: T.unsafe(nil), code_description: T.unsafe(nil), source: T.unsafe(nil), tags: T.unsafe(nil), related_information: T.unsafe(nil), data: T.unsafe(nil)); end

  def message(); end

  def range(); end

  def related_information(); end

  def severity(); end

  def source(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Diagnostic
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), related_document_support: T.unsafe(nil)); end

  def related_document_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticClientCapabilities
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
  def attributes(); end

  def identifier(); end

  def initialize(inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticOptions
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def identifier(); end

  def initialize(document_selector:, inter_file_dependencies:, workspace_diagnostics:, work_done_progress: T.unsafe(nil), identifier: T.unsafe(nil), id: T.unsafe(nil)); end

  def inter_file_dependencies(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end

  def workspace_diagnostics(); end
end

class LanguageServer::Protocol::Interface::DiagnosticRegistrationOptions
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
  def attributes(); end

  def initialize(location:, message:); end

  def location(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticRelatedInformation
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
  def attributes(); end

  def initialize(retrigger_request:); end

  def retrigger_request(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticServerCancellationData
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DiagnosticWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
  def attributes(); end

  def initialize(settings:); end

  def settings(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeConfigurationParams
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
  def attributes(); end

  def change(); end

  def initialize(notebook_document:, change:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
  def attributes(); end

  def content_changes(); end

  def initialize(text_document:, content_changes:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), relative_pattern_support: T.unsafe(nil)); end

  def relative_pattern_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesClientCapabilities
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
  def attributes(); end

  def changes(); end

  def initialize(changes:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesParams
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
  def attributes(); end

  def initialize(watchers:); end

  def to_hash(); end

  def to_json(*args); end

  def watchers(); end
end

class LanguageServer::Protocol::Interface::DidChangeWatchedFilesRegistrationOptions
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
  def attributes(); end

  def event(); end

  def initialize(event:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidChangeWorkspaceFoldersParams
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidCloseTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
  def attributes(); end

  def cell_text_documents(); end

  def initialize(notebook_document:, cell_text_documents:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
  def attributes(); end

  def initialize(text_document:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidOpenTextDocumentParams
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
  def attributes(); end

  def initialize(notebook_document:); end

  def notebook_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveNotebookDocumentParams
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, text: T.unsafe(nil)); end

  def text(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DidSaveTextDocumentParams
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentColorClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorOptions
end

class LanguageServer::Protocol::Interface::DocumentColorParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentColorParams
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, id: T.unsafe(nil), work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentColorRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil), previous_result_id: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticParams
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
  def attributes(); end

  def initialize(related_documents:); end

  def related_documents(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentDiagnosticReportPartialResult
end

class LanguageServer::Protocol::Interface::DocumentFilter
  def attributes(); end

  def initialize(language: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def language(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFilter
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
  def attributes(); end

  def initialize(text_document:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentHighlight
  def attributes(); end

  def initialize(range:, kind: T.unsafe(nil)); end

  def kind(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlight
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightOptions
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightParams
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentHighlightRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentLink
  def attributes(); end

  def data(); end

  def initialize(range:, target: T.unsafe(nil), tooltip: T.unsafe(nil), data: T.unsafe(nil)); end

  def range(); end

  def target(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::DocumentLink
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), tooltip_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip_support(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkOptions
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkParams
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentLinkRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
  def attributes(); end

  def first_trigger_character(); end

  def initialize(first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
  def attributes(); end

  def ch(); end

  def initialize(text_document:, position:, ch:, options:); end

  def options(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def first_trigger_character(); end

  def initialize(document_selector:, first_trigger_character:, more_trigger_character: T.unsafe(nil)); end

  def more_trigger_character(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentOnTypeFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingOptions
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
  def attributes(); end

  def initialize(text_document:, range:, options:, work_done_token: T.unsafe(nil)); end

  def options(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingParams
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentRangeFormattingRegistrationOptions
end

class LanguageServer::Protocol::Interface::DocumentSymbol
  def attributes(); end

  def children(); end

  def deprecated(); end

  def detail(); end

  def initialize(name:, kind:, range:, selection_range:, detail: T.unsafe(nil), tags: T.unsafe(nil), deprecated: T.unsafe(nil), children: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbol
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def hierarchical_document_symbol_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), hierarchical_document_symbol_support: T.unsafe(nil), tag_support: T.unsafe(nil), label_support: T.unsafe(nil)); end

  def label_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolClientCapabilities
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolOptions
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolParams
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), label: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::DocumentSymbolRegistrationOptions
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandClientCapabilities
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandOptions
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
  def arguments(); end

  def attributes(); end

  def command(); end

  def initialize(command:, work_done_token: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandParams
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
  def attributes(); end

  def commands(); end

  def initialize(commands:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ExecuteCommandRegistrationOptions
end

class LanguageServer::Protocol::Interface::ExecutionSummary
  def attributes(); end

  def execution_order(); end

  def initialize(execution_order:, success: T.unsafe(nil)); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ExecutionSummary
end

class LanguageServer::Protocol::Interface::FileCreate
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileCreate
end

class LanguageServer::Protocol::Interface::FileDelete
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileDelete
end

class LanguageServer::Protocol::Interface::FileEvent
  def attributes(); end

  def initialize(uri:, type:); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::FileEvent
end

class LanguageServer::Protocol::Interface::FileOperationFilter
  def attributes(); end

  def initialize(pattern:, scheme: T.unsafe(nil)); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationFilter
end

class LanguageServer::Protocol::Interface::FileOperationPattern
  def attributes(); end

  def glob(); end

  def initialize(glob:, matches: T.unsafe(nil), options: T.unsafe(nil)); end

  def matches(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPattern
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
  def attributes(); end

  def ignore_case(); end

  def initialize(ignore_case: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationPatternOptions
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
  def attributes(); end

  def filters(); end

  def initialize(filters:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileOperationRegistrationOptions
end

class LanguageServer::Protocol::Interface::FileRename
  def attributes(); end

  def initialize(old_uri:, new_uri:); end

  def new_uri(); end

  def old_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileRename
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
  def attributes(); end

  def glob_pattern(); end

  def initialize(glob_pattern:, kind: T.unsafe(nil)); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FileSystemWatcher
end

class LanguageServer::Protocol::Interface::FoldingRange
  def attributes(); end

  def collapsed_text(); end

  def end_character(); end

  def end_line(); end

  def initialize(start_line:, end_line:, start_character: T.unsafe(nil), end_character: T.unsafe(nil), kind: T.unsafe(nil), collapsed_text: T.unsafe(nil)); end

  def kind(); end

  def start_character(); end

  def start_line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRange
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def folding_range(); end

  def folding_range_kind(); end

  def initialize(dynamic_registration: T.unsafe(nil), range_limit: T.unsafe(nil), line_folding_only: T.unsafe(nil), folding_range_kind: T.unsafe(nil), folding_range: T.unsafe(nil)); end

  def line_folding_only(); end

  def range_limit(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FoldingRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeOptions
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeParams
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::FoldingRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::FormattingOptions
  def attributes(); end

  def initialize(tab_size:, insert_spaces:, trim_trailing_whitespace: T.unsafe(nil), insert_final_newline: T.unsafe(nil), trim_final_newlines: T.unsafe(nil)); end

  def insert_final_newline(); end

  def insert_spaces(); end

  def tab_size(); end

  def to_hash(); end

  def to_json(*args); end

  def trim_final_newlines(); end

  def trim_trailing_whitespace(); end
end

class LanguageServer::Protocol::Interface::FormattingOptions
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::FullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::Hover
  def attributes(); end

  def contents(); end

  def initialize(contents:, range: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Hover
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
  def attributes(); end

  def content_format(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), content_format: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::HoverClientCapabilities
end

class LanguageServer::Protocol::Interface::HoverOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverOptions
end

class LanguageServer::Protocol::Interface::HoverParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::HoverParams
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::HoverRegistrationOptions
end

class LanguageServer::Protocol::Interface::HoverResult
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::HoverResult
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ImplementationClientCapabilities
end

class LanguageServer::Protocol::Interface::ImplementationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationOptions
end

class LanguageServer::Protocol::Interface::ImplementationParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ImplementationParams
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ImplementationRegistrationOptions
end

class LanguageServer::Protocol::Interface::InitializeError
  def attributes(); end

  def initialize(retry:); end

  def retry(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeError
end

class LanguageServer::Protocol::Interface::InitializeParams
  def attributes(); end

  def capabilities(); end

  def client_info(); end

  def initialization_options(); end

  def initialize(process_id:, root_uri:, capabilities:, work_done_token: T.unsafe(nil), client_info: T.unsafe(nil), locale: T.unsafe(nil), root_path: T.unsafe(nil), initialization_options: T.unsafe(nil), trace: T.unsafe(nil), workspace_folders: T.unsafe(nil)); end

  def locale(); end

  def process_id(); end

  def root_path(); end

  def root_uri(); end

  def to_hash(); end

  def to_json(*args); end

  def trace(); end

  def work_done_token(); end

  def workspace_folders(); end
end

class LanguageServer::Protocol::Interface::InitializeParams
end

class LanguageServer::Protocol::Interface::InitializeResult
  def attributes(); end

  def capabilities(); end

  def initialize(capabilities:, server_info: T.unsafe(nil)); end

  def server_info(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializeResult
end

class LanguageServer::Protocol::Interface::InitializedParams
  def attributes(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InitializedParams
end

class LanguageServer::Protocol::Interface::InlayHint
  def attributes(); end

  def data(); end

  def initialize(position:, label:, kind: T.unsafe(nil), text_edits: T.unsafe(nil), tooltip: T.unsafe(nil), padding_left: T.unsafe(nil), padding_right: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def label(); end

  def padding_left(); end

  def padding_right(); end

  def position(); end

  def text_edits(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end
end

class LanguageServer::Protocol::Interface::InlayHint
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintClientCapabilities
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
  def attributes(); end

  def command(); end

  def initialize(value:, tooltip: T.unsafe(nil), location: T.unsafe(nil), command: T.unsafe(nil)); end

  def location(); end

  def to_hash(); end

  def to_json(*args); end

  def tooltip(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::InlayHintLabelPart
end

class LanguageServer::Protocol::Interface::InlayHintOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintOptions
end

class LanguageServer::Protocol::Interface::InlayHintParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlayHintParams
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil), id: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlayHintRegistrationOptions
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlayHintWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueClientCapabilities
end

class LanguageServer::Protocol::Interface::InlineValueContext
  def attributes(); end

  def frame_id(); end

  def initialize(frame_id:, stopped_location:); end

  def stopped_location(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueContext
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
  def attributes(); end

  def expression(); end

  def initialize(range:, expression: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueEvaluatableExpression
end

class LanguageServer::Protocol::Interface::InlineValueOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueOptions
end

class LanguageServer::Protocol::Interface::InlineValueParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, range:, context:, work_done_token: T.unsafe(nil)); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::InlineValueParams
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::InlineValueRegistrationOptions
end

class LanguageServer::Protocol::Interface::InlineValueText
  def attributes(); end

  def initialize(range:, text:); end

  def range(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueText
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
  def attributes(); end

  def case_sensitive_lookup(); end

  def initialize(range:, case_sensitive_lookup:, variable_name: T.unsafe(nil)); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def variable_name(); end
end

class LanguageServer::Protocol::Interface::InlineValueVariableLookup
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InlineValueWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
  def attributes(); end

  def initialize(new_text:, insert:, replace:); end

  def insert(); end

  def new_text(); end

  def replace(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::InsertReplaceEdit
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeOptions
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeParams
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
  def attributes(); end

  def initialize(ranges:, word_pattern: T.unsafe(nil)); end

  def ranges(); end

  def to_hash(); end

  def to_json(*args); end

  def word_pattern(); end
end

class LanguageServer::Protocol::Interface::LinkedEditingRanges
end

class LanguageServer::Protocol::Interface::Location
  def attributes(); end

  def initialize(uri:, range:); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::Location
end

class LanguageServer::Protocol::Interface::LocationLink
  def attributes(); end

  def initialize(target_uri:, target_range:, target_selection_range:, origin_selection_range: T.unsafe(nil)); end

  def origin_selection_range(); end

  def target_range(); end

  def target_selection_range(); end

  def target_uri(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::LocationLink
end

class LanguageServer::Protocol::Interface::LogMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::LogMessageParams
end

class LanguageServer::Protocol::Interface::LogTraceParams
  def attributes(); end

  def initialize(message:, verbose: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def verbose(); end
end

class LanguageServer::Protocol::Interface::LogTraceParams
end

class LanguageServer::Protocol::Interface::MarkupContent
  def attributes(); end

  def initialize(kind:, value:); end

  def kind(); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::MarkupContent
end

class LanguageServer::Protocol::Interface::Message
  def attributes(); end

  def initialize(jsonrpc:); end

  def jsonrpc(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Message
end

class LanguageServer::Protocol::Interface::MessageActionItem
  def attributes(); end

  def initialize(title:); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MessageActionItem
end

class LanguageServer::Protocol::Interface::Moniker
  def attributes(); end

  def identifier(); end

  def initialize(scheme:, identifier:, unique:, kind: T.unsafe(nil)); end

  def kind(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end

  def unique(); end
end

class LanguageServer::Protocol::Interface::Moniker
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::MonikerClientCapabilities
end

class LanguageServer::Protocol::Interface::MonikerOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerOptions
end

class LanguageServer::Protocol::Interface::MonikerParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::MonikerParams
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::MonikerRegistrationOptions
end

class LanguageServer::Protocol::Interface::NotebookCell
  def attributes(); end

  def document(); end

  def execution_summary(); end

  def initialize(kind:, document:, metadata: T.unsafe(nil), execution_summary: T.unsafe(nil)); end

  def kind(); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCell
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
  def attributes(); end

  def cells(); end

  def delete_count(); end

  def initialize(start:, delete_count:, cells: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellArrayChange
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
  def attributes(); end

  def initialize(notebook:, language: T.unsafe(nil)); end

  def language(); end

  def notebook(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookCellTextDocumentFilter
end

class LanguageServer::Protocol::Interface::NotebookDocument
  def attributes(); end

  def cells(); end

  def initialize(uri:, notebook_type:, version:, cells:, metadata: T.unsafe(nil)); end

  def metadata(); end

  def notebook_type(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::NotebookDocument
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
  def attributes(); end

  def cells(); end

  def initialize(metadata: T.unsafe(nil), cells: T.unsafe(nil)); end

  def metadata(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentChangeEvent
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
  def attributes(); end

  def initialize(synchronization:); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
  def attributes(); end

  def initialize(notebook_type: T.unsafe(nil), scheme: T.unsafe(nil), pattern: T.unsafe(nil)); end

  def notebook_type(); end

  def pattern(); end

  def scheme(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentFilter
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentIdentifier
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def execution_summary_support(); end

  def initialize(dynamic_registration: T.unsafe(nil), execution_summary_support: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncClientCapabilities
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
  def attributes(); end

  def initialize(notebook_selector:, save: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncOptions
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(notebook_selector:, save: T.unsafe(nil), id: T.unsafe(nil)); end

  def notebook_selector(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotebookDocumentSyncRegistrationOptions
end

class LanguageServer::Protocol::Interface::NotificationMessage
  def attributes(); end

  def initialize(jsonrpc:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::NotificationMessage
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::OptionalVersionedTextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::ParameterInformation
  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil)); end

  def label(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ParameterInformation
end

class LanguageServer::Protocol::Interface::PartialResultParams
  def attributes(); end

  def initialize(partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::PartialResultParams
end

class LanguageServer::Protocol::Interface::Position
  def attributes(); end

  def character(); end

  def initialize(line:, character:); end

  def line(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Position
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::PrepareRenameParams
end

class LanguageServer::Protocol::Interface::PreviousResultId
  def attributes(); end

  def initialize(uri:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::PreviousResultId
end

class LanguageServer::Protocol::Interface::ProgressParams
  def attributes(); end

  def initialize(token:, value:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end

  def value(); end
end

class LanguageServer::Protocol::Interface::ProgressParams
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
  def attributes(); end

  def code_description_support(); end

  def data_support(); end

  def initialize(related_information: T.unsafe(nil), tag_support: T.unsafe(nil), version_support: T.unsafe(nil), code_description_support: T.unsafe(nil), data_support: T.unsafe(nil)); end

  def related_information(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end

  def version_support(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsClientCapabilities
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
  def attributes(); end

  def diagnostics(); end

  def initialize(uri:, diagnostics:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::PublishDiagnosticsParams
end

class LanguageServer::Protocol::Interface::Range
  def attributes(); end

  def end(); end

  def initialize(start:, end:); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Range
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceClientCapabilities
end

class LanguageServer::Protocol::Interface::ReferenceContext
  def attributes(); end

  def include_declaration(); end

  def initialize(include_declaration:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ReferenceContext
end

class LanguageServer::Protocol::Interface::ReferenceOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceOptions
end

class LanguageServer::Protocol::Interface::ReferenceParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, context:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::ReferenceParams
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::ReferenceRegistrationOptions
end

class LanguageServer::Protocol::Interface::Registration
  def attributes(); end

  def id(); end

  def initialize(id:, method:, register_options: T.unsafe(nil)); end

  def method(); end

  def register_options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Registration
end

class LanguageServer::Protocol::Interface::RegistrationParams
  def attributes(); end

  def initialize(registrations:); end

  def registrations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RegistrationParams
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
  def attributes(); end

  def engine(); end

  def initialize(engine:, version: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def version(); end
end

class LanguageServer::Protocol::Interface::RegularExpressionsClientCapabilities
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, result_id: T.unsafe(nil), related_documents: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedFullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, related_documents: T.unsafe(nil)); end

  def kind(); end

  def related_documents(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelatedUnchangedDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::RelativePattern
  def attributes(); end

  def base_uri(); end

  def initialize(base_uri:, pattern:); end

  def pattern(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RelativePattern
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def honors_change_annotations(); end

  def initialize(dynamic_registration: T.unsafe(nil), prepare_support: T.unsafe(nil), prepare_support_default_behavior: T.unsafe(nil), honors_change_annotations: T.unsafe(nil)); end

  def prepare_support(); end

  def prepare_support_default_behavior(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameClientCapabilities
end

class LanguageServer::Protocol::Interface::RenameFile
  def annotation_id(); end

  def attributes(); end

  def initialize(kind:, old_uri:, new_uri:, options: T.unsafe(nil), annotation_id: T.unsafe(nil)); end

  def kind(); end

  def new_uri(); end

  def old_uri(); end

  def options(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFile
end

class LanguageServer::Protocol::Interface::RenameFileOptions
  def attributes(); end

  def ignore_if_exists(); end

  def initialize(overwrite: T.unsafe(nil), ignore_if_exists: T.unsafe(nil)); end

  def overwrite(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFileOptions
end

class LanguageServer::Protocol::Interface::RenameFilesParams
  def attributes(); end

  def files(); end

  def initialize(files:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RenameFilesParams
end

class LanguageServer::Protocol::Interface::RenameOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameOptions
end

class LanguageServer::Protocol::Interface::RenameParams
  def attributes(); end

  def initialize(text_document:, position:, new_name:, work_done_token: T.unsafe(nil)); end

  def new_name(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::RenameParams
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), prepare_provider: T.unsafe(nil)); end

  def prepare_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::RenameRegistrationOptions
end

class LanguageServer::Protocol::Interface::RequestMessage
  def attributes(); end

  def id(); end

  def initialize(jsonrpc:, id:, method:, params: T.unsafe(nil)); end

  def jsonrpc(); end

  def method(); end

  def params(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::RequestMessage
end

class LanguageServer::Protocol::Interface::ResponseError
  def attributes(); end

  def code(); end

  def data(); end

  def initialize(code:, message:, data: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseError
end

class LanguageServer::Protocol::Interface::ResponseMessage
  def attributes(); end

  def error(); end

  def id(); end

  def initialize(jsonrpc:, id:, result: T.unsafe(nil), error: T.unsafe(nil)); end

  def jsonrpc(); end

  def result(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ResponseMessage
end

class LanguageServer::Protocol::Interface::SaveOptions
  def attributes(); end

  def include_text(); end

  def initialize(include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SaveOptions
end

class LanguageServer::Protocol::Interface::SelectionRange
  def attributes(); end

  def initialize(range:, parent: T.unsafe(nil)); end

  def parent(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRange
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SelectionRangeClientCapabilities
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeOptions
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
  def attributes(); end

  def initialize(text_document:, positions:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def positions(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeParams
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SelectionRangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::SemanticTokens
  def attributes(); end

  def data(); end

  def initialize(data:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokens
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
  def attributes(); end

  def augments_syntax_tokens(); end

  def dynamic_registration(); end

  def formats(); end

  def initialize(requests:, token_types:, token_modifiers:, formats:, dynamic_registration: T.unsafe(nil), overlapping_token_support: T.unsafe(nil), multiline_token_support: T.unsafe(nil), server_cancel_support: T.unsafe(nil), augments_syntax_tokens: T.unsafe(nil)); end

  def multiline_token_support(); end

  def overlapping_token_support(); end

  def requests(); end

  def server_cancel_support(); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensClientCapabilities
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
  def attributes(); end

  def edits(); end

  def initialize(edits:, result_id: T.unsafe(nil)); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDelta
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
  def attributes(); end

  def initialize(text_document:, previous_result_id:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_id(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaParams
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
  def attributes(); end

  def edits(); end

  def initialize(edits:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensDeltaPartialResult
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
  def attributes(); end

  def data(); end

  def delete_count(); end

  def initialize(start:, delete_count:, data: T.unsafe(nil)); end

  def start(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensEdit
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
  def attributes(); end

  def initialize(token_types:, token_modifiers:); end

  def to_hash(); end

  def to_json(*args); end

  def token_modifiers(); end

  def token_types(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensLegend
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
  def attributes(); end

  def full(); end

  def initialize(legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensOptions
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
  def attributes(); end

  def initialize(text_document:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensParams
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
  def attributes(); end

  def data(); end

  def initialize(data:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensPartialResult
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
  def attributes(); end

  def initialize(text_document:, range:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def range(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRangeParams
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def full(); end

  def id(); end

  def initialize(document_selector:, legend:, work_done_progress: T.unsafe(nil), range: T.unsafe(nil), full: T.unsafe(nil), id: T.unsafe(nil)); end

  def legend(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SemanticTokensRegistrationOptions
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
  def attributes(); end

  def initialize(refresh_support: T.unsafe(nil)); end

  def refresh_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SemanticTokensWorkspaceClientCapabilities
end

class LanguageServer::Protocol::Interface::ServerCapabilities
  def attributes(); end

  def call_hierarchy_provider(); end

  def code_action_provider(); end

  def code_lens_provider(); end

  def color_provider(); end

  def completion_provider(); end

  def declaration_provider(); end

  def definition_provider(); end

  def diagnostic_provider(); end

  def document_formatting_provider(); end

  def document_highlight_provider(); end

  def document_link_provider(); end

  def document_on_type_formatting_provider(); end

  def document_range_formatting_provider(); end

  def document_symbol_provider(); end

  def execute_command_provider(); end

  def experimental(); end

  def folding_range_provider(); end

  def hover_provider(); end

  def implementation_provider(); end

  def initialize(position_encoding: T.unsafe(nil), text_document_sync: T.unsafe(nil), notebook_document_sync: T.unsafe(nil), completion_provider: T.unsafe(nil), hover_provider: T.unsafe(nil), signature_help_provider: T.unsafe(nil), declaration_provider: T.unsafe(nil), definition_provider: T.unsafe(nil), type_definition_provider: T.unsafe(nil), implementation_provider: T.unsafe(nil), references_provider: T.unsafe(nil), document_highlight_provider: T.unsafe(nil), document_symbol_provider: T.unsafe(nil), code_action_provider: T.unsafe(nil), code_lens_provider: T.unsafe(nil), document_link_provider: T.unsafe(nil), color_provider: T.unsafe(nil), document_formatting_provider: T.unsafe(nil), document_range_formatting_provider: T.unsafe(nil), document_on_type_formatting_provider: T.unsafe(nil), rename_provider: T.unsafe(nil), folding_range_provider: T.unsafe(nil), execute_command_provider: T.unsafe(nil), selection_range_provider: T.unsafe(nil), linked_editing_range_provider: T.unsafe(nil), call_hierarchy_provider: T.unsafe(nil), semantic_tokens_provider: T.unsafe(nil), moniker_provider: T.unsafe(nil), type_hierarchy_provider: T.unsafe(nil), inline_value_provider: T.unsafe(nil), inlay_hint_provider: T.unsafe(nil), diagnostic_provider: T.unsafe(nil), workspace_symbol_provider: T.unsafe(nil), workspace: T.unsafe(nil), experimental: T.unsafe(nil)); end

  def inlay_hint_provider(); end

  def inline_value_provider(); end

  def linked_editing_range_provider(); end

  def moniker_provider(); end

  def notebook_document_sync(); end

  def position_encoding(); end

  def references_provider(); end

  def rename_provider(); end

  def selection_range_provider(); end

  def semantic_tokens_provider(); end

  def signature_help_provider(); end

  def text_document_sync(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition_provider(); end

  def type_hierarchy_provider(); end

  def workspace(); end

  def workspace_symbol_provider(); end
end

class LanguageServer::Protocol::Interface::ServerCapabilities
end

class LanguageServer::Protocol::Interface::SetTraceParams
  def attributes(); end

  def initialize(value:); end

  def to_hash(); end

  def to_json(*args); end

  def value(); end
end

class LanguageServer::Protocol::Interface::SetTraceParams
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
  def attributes(); end

  def initialize(support:); end

  def support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
  def attributes(); end

  def external(); end

  def initialize(uri:, external: T.unsafe(nil), take_focus: T.unsafe(nil), selection: T.unsafe(nil)); end

  def selection(); end

  def take_focus(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::ShowDocumentParams
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
  def attributes(); end

  def initialize(success:); end

  def success(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowDocumentResult
end

class LanguageServer::Protocol::Interface::ShowMessageParams
  def attributes(); end

  def initialize(type:, message:); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageParams
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
  def attributes(); end

  def initialize(message_action_item: T.unsafe(nil)); end

  def message_action_item(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestClientCapabilities
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
  def actions(); end

  def attributes(); end

  def initialize(type:, message:, actions: T.unsafe(nil)); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end

  def type(); end
end

class LanguageServer::Protocol::Interface::ShowMessageRequestParams
end

class LanguageServer::Protocol::Interface::SignatureHelp
  def active_parameter(); end

  def active_signature(); end

  def attributes(); end

  def initialize(signatures:, active_signature: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def signatures(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelp
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
  def attributes(); end

  def context_support(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), signature_information: T.unsafe(nil), context_support: T.unsafe(nil)); end

  def signature_information(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureHelpClientCapabilities
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
  def active_signature_help(); end

  def attributes(); end

  def initialize(trigger_kind:, is_retrigger:, trigger_character: T.unsafe(nil), active_signature_help: T.unsafe(nil)); end

  def is_retrigger(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_character(); end

  def trigger_kind(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpContext
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpOptions
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
  def attributes(); end

  def context(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), context: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpParams
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), trigger_characters: T.unsafe(nil), retrigger_characters: T.unsafe(nil)); end

  def retrigger_characters(); end

  def to_hash(); end

  def to_json(*args); end

  def trigger_characters(); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::SignatureHelpRegistrationOptions
end

class LanguageServer::Protocol::Interface::SignatureInformation
  def active_parameter(); end

  def attributes(); end

  def documentation(); end

  def initialize(label:, documentation: T.unsafe(nil), parameters: T.unsafe(nil), active_parameter: T.unsafe(nil)); end

  def label(); end

  def parameters(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SignatureInformation
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
  def attributes(); end

  def id(); end

  def initialize(id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::StaticRegistrationOptions
end

class LanguageServer::Protocol::Interface::SymbolInformation
  def attributes(); end

  def container_name(); end

  def deprecated(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), deprecated: T.unsafe(nil), container_name: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::SymbolInformation
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:, sync_kind:); end

  def sync_kind(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentChangeRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
  def attributes(); end

  def call_hierarchy(); end

  def code_action(); end

  def code_lens(); end

  def color_provider(); end

  def completion(); end

  def declaration(); end

  def definition(); end

  def diagnostic(); end

  def document_highlight(); end

  def document_link(); end

  def document_symbol(); end

  def folding_range(); end

  def formatting(); end

  def hover(); end

  def implementation(); end

  def initialize(synchronization: T.unsafe(nil), completion: T.unsafe(nil), hover: T.unsafe(nil), signature_help: T.unsafe(nil), declaration: T.unsafe(nil), definition: T.unsafe(nil), type_definition: T.unsafe(nil), implementation: T.unsafe(nil), references: T.unsafe(nil), document_highlight: T.unsafe(nil), document_symbol: T.unsafe(nil), code_action: T.unsafe(nil), code_lens: T.unsafe(nil), document_link: T.unsafe(nil), color_provider: T.unsafe(nil), formatting: T.unsafe(nil), range_formatting: T.unsafe(nil), on_type_formatting: T.unsafe(nil), rename: T.unsafe(nil), publish_diagnostics: T.unsafe(nil), folding_range: T.unsafe(nil), selection_range: T.unsafe(nil), linked_editing_range: T.unsafe(nil), call_hierarchy: T.unsafe(nil), semantic_tokens: T.unsafe(nil), moniker: T.unsafe(nil), type_hierarchy: T.unsafe(nil), inline_value: T.unsafe(nil), inlay_hint: T.unsafe(nil), diagnostic: T.unsafe(nil)); end

  def inlay_hint(); end

  def inline_value(); end

  def linked_editing_range(); end

  def moniker(); end

  def on_type_formatting(); end

  def publish_diagnostics(); end

  def range_formatting(); end

  def references(); end

  def rename(); end

  def selection_range(); end

  def semantic_tokens(); end

  def signature_help(); end

  def synchronization(); end

  def to_hash(); end

  def to_json(*args); end

  def type_definition(); end

  def type_hierarchy(); end
end

class LanguageServer::Protocol::Interface::TextDocumentClientCapabilities
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
  def attributes(); end

  def initialize(text:, range: T.unsafe(nil), range_length: T.unsafe(nil)); end

  def range(); end

  def range_length(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentContentChangeEvent
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
  def attributes(); end

  def edits(); end

  def initialize(text_document:, edits:); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentEdit
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
  def attributes(); end

  def initialize(uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::TextDocumentItem
  def attributes(); end

  def initialize(uri:, language_id:, version:, text:); end

  def language_id(); end

  def text(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::TextDocumentItem
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
  def attributes(); end

  def initialize(text_document:, position:); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentPositionParams
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def initialize(document_selector:); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def include_text(); end

  def initialize(document_selector:, include_text: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextDocumentSaveRegistrationOptions
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
  def attributes(); end

  def did_save(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), did_save: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncClientCapabilities
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
  def attributes(); end

  def change(); end

  def initialize(open_close: T.unsafe(nil), change: T.unsafe(nil), will_save: T.unsafe(nil), will_save_wait_until: T.unsafe(nil), save: T.unsafe(nil)); end

  def open_close(); end

  def save(); end

  def to_hash(); end

  def to_json(*args); end

  def will_save(); end

  def will_save_wait_until(); end
end

class LanguageServer::Protocol::Interface::TextDocumentSyncOptions
end

class LanguageServer::Protocol::Interface::TextEdit
  def attributes(); end

  def initialize(range:, new_text:); end

  def new_text(); end

  def range(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TextEdit
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), link_support: T.unsafe(nil)); end

  def link_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionClientCapabilities
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionOptions
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionParams
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeDefinitionRegistrationOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
  def attributes(); end

  def data(); end

  def detail(); end

  def initialize(name:, kind:, uri:, range:, selection_range:, tags: T.unsafe(nil), detail: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def name(); end

  def range(); end

  def selection_range(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyItem
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
  def attributes(); end

  def initialize(text_document:, position:, work_done_token: T.unsafe(nil)); end

  def position(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyPrepareParams
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
  def attributes(); end

  def document_selector(); end

  def id(); end

  def initialize(document_selector:, work_done_progress: T.unsafe(nil), id: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchyRegistrationOptions
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySubtypesParams
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
  def attributes(); end

  def initialize(item:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def item(); end

  def partial_result_token(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::TypeHierarchySupertypesParams
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::UnchangedDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::Unregistration
  def attributes(); end

  def id(); end

  def initialize(id:, method:); end

  def method(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::Unregistration
end

class LanguageServer::Protocol::Interface::UnregistrationParams
  def attributes(); end

  def initialize(unregisterations:); end

  def to_hash(); end

  def to_json(*args); end

  def unregisterations(); end
end

class LanguageServer::Protocol::Interface::UnregistrationParams
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
  def attributes(); end

  def initialize(version:, uri:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedNotebookDocumentIdentifier
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
  def attributes(); end

  def initialize(uri:, version:); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::VersionedTextDocumentIdentifier
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
  def attributes(); end

  def initialize(text_document:, reason:); end

  def reason(); end

  def text_document(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WillSaveTextDocumentParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, title:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def title(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressBegin
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCancelParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
  def attributes(); end

  def initialize(token:); end

  def to_hash(); end

  def to_json(*args); end

  def token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressCreateParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
  def attributes(); end

  def initialize(kind:, message: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressEnd
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressOptions
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
  def attributes(); end

  def initialize(work_done_token: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressParams
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
  def attributes(); end

  def cancellable(); end

  def initialize(kind:, cancellable: T.unsafe(nil), message: T.unsafe(nil), percentage: T.unsafe(nil)); end

  def kind(); end

  def message(); end

  def percentage(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkDoneProgressReport
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
  def attributes(); end

  def identifier(); end

  def initialize(previous_result_ids:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil), identifier: T.unsafe(nil)); end

  def partial_result_token(); end

  def previous_result_ids(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticParams
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReport
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
  def attributes(); end

  def initialize(items:); end

  def items(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceDiagnosticReportPartialResult
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
  def attributes(); end

  def change_annotations(); end

  def changes(); end

  def document_changes(); end

  def initialize(changes: T.unsafe(nil), document_changes: T.unsafe(nil), change_annotations: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEdit
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
  def attributes(); end

  def change_annotation_support(); end

  def document_changes(); end

  def failure_handling(); end

  def initialize(document_changes: T.unsafe(nil), resource_operations: T.unsafe(nil), failure_handling: T.unsafe(nil), normalizes_line_endings: T.unsafe(nil), change_annotation_support: T.unsafe(nil)); end

  def normalizes_line_endings(); end

  def resource_operations(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceEditClientCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
  def attributes(); end

  def initialize(uri:, name:); end

  def name(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFolder
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
  def added(); end

  def attributes(); end

  def initialize(added:, removed:); end

  def removed(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersChangeEvent
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
  def attributes(); end

  def change_notifications(); end

  def initialize(supported: T.unsafe(nil), change_notifications: T.unsafe(nil)); end

  def supported(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceFoldersServerCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, items:, uri:, version:, result_id: T.unsafe(nil)); end

  def items(); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceFullDocumentDiagnosticReport
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
  def attributes(); end

  def container_name(); end

  def data(); end

  def initialize(name:, kind:, location:, tags: T.unsafe(nil), container_name: T.unsafe(nil), data: T.unsafe(nil)); end

  def kind(); end

  def location(); end

  def name(); end

  def tags(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbol
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
  def attributes(); end

  def dynamic_registration(); end

  def initialize(dynamic_registration: T.unsafe(nil), symbol_kind: T.unsafe(nil), tag_support: T.unsafe(nil), resolve_support: T.unsafe(nil)); end

  def resolve_support(); end

  def symbol_kind(); end

  def tag_support(); end

  def to_hash(); end

  def to_json(*args); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolClientCapabilities
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolOptions
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
  def attributes(); end

  def initialize(query:, work_done_token: T.unsafe(nil), partial_result_token: T.unsafe(nil)); end

  def partial_result_token(); end

  def query(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_token(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolParams
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
  def attributes(); end

  def initialize(work_done_progress: T.unsafe(nil), resolve_provider: T.unsafe(nil)); end

  def resolve_provider(); end

  def to_hash(); end

  def to_json(*args); end

  def work_done_progress(); end
end

class LanguageServer::Protocol::Interface::WorkspaceSymbolRegistrationOptions
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
  def attributes(); end

  def initialize(kind:, result_id:, uri:, version:); end

  def kind(); end

  def result_id(); end

  def to_hash(); end

  def to_json(*args); end

  def uri(); end

  def version(); end
end

class LanguageServer::Protocol::Interface::WorkspaceUnchangedDocumentDiagnosticReport
end

module LanguageServer::Protocol::Interface
end

module LanguageServer::Protocol::Transport
end

module LanguageServer::Protocol::Transport::Io
end

class LanguageServer::Protocol::Transport::Io::Reader
  def close(); end

  def initialize(io); end

  def read(&block); end
end

class LanguageServer::Protocol::Transport::Io::Reader
end

class LanguageServer::Protocol::Transport::Io::Writer
  def close(); end

  def initialize(io); end

  def io(); end

  def write(response); end
end

class LanguageServer::Protocol::Transport::Io::Writer
end

module LanguageServer::Protocol::Transport::Io
end

module LanguageServer::Protocol::Transport::Stdio
end

class LanguageServer::Protocol::Transport::Stdio::Reader
  def initialize(); end
end

class LanguageServer::Protocol::Transport::Stdio::Reader
end

class LanguageServer::Protocol::Transport::Stdio::Writer
  def initialize(); end
end

class LanguageServer::Protocol::Transport::Stdio::Writer
end

module LanguageServer::Protocol::Transport::Stdio
end

module LanguageServer::Protocol::Transport
end

module LanguageServer::Protocol
end

module LanguageServer
end

module LintRoller
  VERSION = ::T.let(nil, ::T.untyped)
end

class LintRoller::About
  def description(); end

  def description=(_); end

  def homepage(); end

  def homepage=(_); end

  def name(); end

  def name=(_); end

  def version(); end

  def version=(_); end
end

class LintRoller::About
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class LintRoller::Context
  def engine(); end

  def engine=(_); end

  def engine_version(); end

  def engine_version=(_); end

  def rule_format(); end

  def rule_format=(_); end

  def runner(); end

  def runner=(_); end

  def runner_version(); end

  def runner_version=(_); end

  def target_ruby_version(); end

  def target_ruby_version=(_); end
end

class LintRoller::Context
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class LintRoller::Error
end

class LintRoller::Error
end

class LintRoller::Plugin
  def about(); end

  def initialize(config=T.unsafe(nil)); end

  def rules(context); end

  def supported?(context); end
end

class LintRoller::Plugin
end

class LintRoller::Rules
  def config_format(); end

  def config_format=(_); end

  def error(); end

  def error=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class LintRoller::Rules
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module LintRoller::Support
end

class LintRoller::Support::MergesUpstreamMetadata
  def merge(plugin_yaml, upstream_yaml); end
end

class LintRoller::Support::MergesUpstreamMetadata
end

module LintRoller::Support
end

module LintRoller
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end

  def with_level(severity); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
  MODE = ::T.let(nil, ::T.untyped)
  MODE_TO_CREATE = ::T.let(nil, ::T.untyped)
  MODE_TO_OPEN = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Severity
  def self.coerce(severity); end
end

class MatchData
  def bytebegin(arg); end

  def byteend(arg); end

  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

module Memoist
  def all_memoized_structs(); end

  def clear_structs(); end

  def memoize(*method_names); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Memoist::InstanceMethods
  def flush_cache(*method_names); end

  def memoize_all(); end

  def memoized_structs(names); end

  def prime_cache(*method_names); end

  def unmemoize_all(); end
end

module Memoist::InstanceMethods
end

class Memoist::MemoizedMethod
  def arity(); end

  def arity=(_); end

  def ivar(); end

  def ivar=(_); end

  def memoized_method(); end

  def memoized_method=(_); end
end

class Memoist::MemoizedMethod
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Memoist
  def self.escape_punctuation(string); end

  def self.extended(extender); end

  def self.extract_reload!(method, args); end

  def self.memoist_eval(klass, *args, **kwargs, &block); end

  def self.memoized_ivar_for(method_name, identifier=T.unsafe(nil)); end

  def self.memoized_prefix(identifier=T.unsafe(nil)); end

  def self.unmemoized_method_for(method_name, identifier=T.unsafe(nil)); end

  def self.unmemoized_prefix(identifier=T.unsafe(nil)); end
end

class MethodBasedSexpProcessor
  def class_stack(); end

  def in_klass(name); end

  def in_method(name, file, line, line_max=T.unsafe(nil)); end

  def in_sklass(); end

  def klass_name(); end

  def method_locations(); end

  def method_name(); end

  def method_stack(); end

  def process_class(exp); end

  def process_defn(exp); end

  def process_defs(exp); end

  def process_module(exp); end

  def process_sclass(exp); end

  def process_until_empty(exp); end

  def sclass(); end

  def signature(); end

  def with_new_method_stack(); end
end

class MethodBasedSexpProcessor
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

module MiniMime::Configuration
end

module MiniMime::Configuration
  def self.content_type_db_path(); end

  def self.content_type_db_path=(content_type_db_path); end

  def self.ext_db_path(); end

  def self.ext_db_path=(ext_db_path); end
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

MiniMime::Db::PReadFile = File

class MiniMime::Db::RandomAccessDb
  def initialize(path, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class Module
  def class_name(); end

  def context(*a, &b); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def rake_extension(method); end

  def set_temporary_name(arg); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def undefined_instance_methods(); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiTest
end

class MultiTest::AssertionLibrary
  def extend_world(world); end

  def initialize(requirer, extender); end

  def require?(); end
end

class MultiTest::AssertionLibrary
  def self.available(); end

  def self.detect_best(); end

  def self.null(); end
end

module MultiTest::MinitestWorld
  def assertions(); end

  def assertions=(assertions); end
end

module MultiTest::MinitestWorld
  def self.extended(base); end
end

module MultiTest
  def self.disable_autorun(); end

  def self.extend_with_best_assertion_library(object); end
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def proxy_use_ssl=(proxy_use_ssl); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::HTTP
  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.proxy_use_ssl(); end

  def self.put(url, data, header=T.unsafe(nil)); end
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPClientException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

module Net::HTTPHeader
  MAX_FIELD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_KEY_LENGTH = ::T.let(nil, ::T.untyped)
end

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

class Net::HTTPResponse
  def body_encoding(); end

  def body_encoding=(value); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end
end

class Net::HTTPResponse::Inflater
  def bytes_inflated(); end
end

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  def =~(arg); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NotEmptyError
end

class NotEmptyError
end

class Object
  include ::PP::ObjectMixin
  def deep_clone(); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def delete(arg); end
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::ASN1
  CLASS_TAG_MAP = ::T.let(nil, ::T.untyped)
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::ASN1::BitString
  def initialize(*arg); end
end

class OpenSSL::ASN1::Constructive
  include ::OpenSSL::ASN1::TaggedASN1Data
end

class OpenSSL::ASN1::Primitive
  include ::OpenSSL::ASN1::TaggedASN1Data
end

module OpenSSL::ASN1::TaggedASN1Data
  def initialize(value, tag=T.unsafe(nil), tagging=T.unsafe(nil), tag_class=T.unsafe(nil)); end

  def tagging(); end

  def tagging=(tagging); end
end

module OpenSSL::ASN1::TaggedASN1Data
end

module OpenSSL::ASN1
  def self.take_default_tag(klass); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def mod_sqrt(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  def getbyte(); end

  def readbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::Digest
  def self.digests(); end
end

class OpenSSL::HMAC
  def ==(other); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

class OpenSSL::PKCS12
  def set_mac(*arg); end
  KEY_EX = ::T.let(nil, ::T.untyped)
  KEY_SIG = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKCS7
  def to_text(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def raw_private_key(); end

  def raw_public_key(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end

  def self.new_raw_private_key(arg, arg1); end

  def self.new_raw_public_key(arg, arg1); end
end

class OpenSSL::Provider
  def name(); end

  def unload(); end
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider::ProviderError
end

class OpenSSL::Provider
  def self.load(arg); end

  def self.provider_names(); end
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def ciphersuites=(ciphersuites); end

  def enable_fallback_scsv(); end

  def keylog_cb(); end

  def keylog_cb=(keylog_cb); end

  def max_version=(version); end

  def min_version=(version); end

  def tmp_dh=(tmp_dh); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def close_read(); end

  def close_write(); end

  def export_keying_material(*arg); end

  def finished_message(); end

  def peer_finished_message(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  def self.open(remote_host, remote_port, local_host=T.unsafe(nil), local_port=T.unsafe(nil), context: T.unsafe(nil)); end
end

module OpenSSL::SSL::SocketForwarder
  def close_on_exec=(value); end

  def close_on_exec?(); end

  def fileno(); end

  def local_address(); end

  def remote_address(); end

  def timeout(); end

  def timeout=(value); end

  def wait(*args); end

  def wait_readable(*args); end

  def wait_writable(*args); end
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def to_text(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def to_text(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def to_text(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def tbs_bytes(); end
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  def Namespace!(name); end

  def TypeName!(string); end

  def __id__!(); end

  def __send__!(*arg); end

  def as_null_object!(); end

  def at_exit!(&block); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def deep_clone!(); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def exit!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def pretty_inspect!(); end

  def pretty_print!(q); end

  def pretty_print_cycle!(q); end

  def pretty_print_inspect!(); end

  def pretty_print_instance_variables!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def should!(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not!(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive!(message, &block); end

  def should_receive!(message, opts=T.unsafe(nil), &block); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def stub!(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain!(*chain, &blk); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_json!(*arg); end

  def to_s!(); end

  def to_yaml!(options=T.unsafe(nil)); end

  def unstub!(message); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def help_exit(); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  OptionalArgument = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def omitted_argument(val); end

  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end

  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

class PP
  VERSION = ::T.let(nil, ::T.untyped)
end

module PP::PPMethods
  def pp_hash_pair(k, v); end
end

class PP
  def self.width_for(out); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
  def initialize(value=T.unsafe(nil)); end

  def value(); end
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.filter_map(*arg, **arg1, &arg2); end

  def self.flat_map(*arg, **arg1, &arg2); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  include ::AST::Processor::Mixin
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def lexer(); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def forwarded_kwrestarg(dstar_t); end

  def forwarded_restarg(star_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_pattern(lhs, match_t, rhs); end

  def match_pattern_p(lhs, match_t, rhs); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_label(key_t); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_kwargs(); end

  def self.emit_kwargs=(emit_kwargs); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_match_pattern(); end

  def self.emit_match_pattern=(emit_match_pattern); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def cant_return(); end

  def cant_return=(cant_return); end

  def in_argdef(); end

  def in_argdef=(in_argdef); end

  def in_block(); end

  def in_block=(in_block); end

  def in_class(); end

  def in_class=(in_class); end

  def in_def(); end

  def in_def=(in_def); end

  def in_defined(); end

  def in_defined=(in_defined); end

  def in_dynamic_block?(); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def in_lambda(); end

  def in_lambda=(in_lambda); end

  def reset(); end
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::Context
end

class Parser::CurrentArgStack
  def empty?(); end

  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def check_ambiguous_slash(tm); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def cmdarg_stack(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def cond_stack(); end

  def construct_float(chars); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def e_lbrace(); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_class_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_colon_with_digits(p, tm, diag_msg); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment_from_range(p, pe); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_global_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_instance_var(ts=T.unsafe(nil), te=T.unsafe(nil)); end

  def emit_rbrace_rparen_rbrack(); end

  def emit_singleton_class(); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encoding(); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def initialize(version); end

  def lambda_stack(); end

  def numeric_literal_int(); end

  def on_newline(p); end

  def paren_nest(); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def push_cmdarg(); end

  def push_cond(); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version(); end

  def version?(*versions); end
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TAB = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_inside_string(); end

  def self.lex_en_inside_string=(lex_en_inside_string); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::LexerStrings
  def advance(p); end

  def check_ambiguous_slash(tm); end

  def check_invalid_escapes(p); end

  def close_interp_on_current_literal(p); end

  def cond(); end

  def continue_lexing(current_literal); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_character_constant(); end

  def emit_interp_var(interp_var_kind); end

  def emit_invalid_escapes?(); end

  def encode_escape(ord); end

  def encode_escaped_char(p); end

  def eof_codepoint?(point); end

  def extend_interp_code(current_literal); end

  def extend_interp_digit_var(); end

  def extend_interp_var(current_literal); end

  def extend_string_eol_check_eof(current_literal, pe); end

  def extend_string_eol_heredoc_intertwined(p); end

  def extend_string_eol_heredoc_line(); end

  def extend_string_eol_words(current_literal, p); end

  def extend_string_escaped(); end

  def extend_string_for_token_range(current_literal, string); end

  def extend_string_slice_end(lookahead); end

  def herebody_s(); end

  def herebody_s=(herebody_s); end

  def initialize(lexer, version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def on_newline(p); end

  def pop_literal(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def read_character_constant(p); end

  def read_post_meta_or_ctrl_char(p); end

  def reset(); end

  def slash_c_char(); end

  def slash_m_char(); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def source_pts(); end

  def source_pts=(source_pts); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def unescape_char(p); end

  def unicode_points(p); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  def self.lex_en_character(); end

  def self.lex_en_character=(lex_en_character); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_en_unknown(); end

  def self.lex_en_unknown=(lex_en_unknown); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def empty?(); end

  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(static:); end

  def register(numparam); end

  def stack(); end

  def top(); end
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*arg); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_335(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_339(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_430(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_436(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_548(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_558(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_562(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_577(val, _values, result); end

  def _reduce_578(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_591(val, _values, result); end

  def _reduce_592(val, _values, result); end

  def _reduce_597(val, _values, result); end

  def _reduce_598(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_602(val, _values, result); end

  def _reduce_606(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def local_pop(); end

  def local_push(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(start, length=T.unsafe(nil)); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  include ::RuboCop::Ext::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_by_identity(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_by_identity(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::MethodDefinition
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  include ::RuboCop::AST::Ext::Range
  include ::RuboCop::Ext::Range
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_anonymous_blockarg(); end

  def declare_anonymous_kwrestarg(); end

  def declare_anonymous_restarg(); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_anonymous_blockarg?(); end

  def declared_anonymous_blockarg_in_current_scpe?(); end

  def declared_anonymous_kwrestarg?(); end

  def declared_anonymous_kwrestarg_in_current_scope?(); end

  def declared_anonymous_restarg?(); end

  def declared_anonymous_restarg_in_current_scope?(); end

  def declared_forward_args?(); end

  def empty?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def parent_has_anonymous_blockarg?(); end

  def parent_has_anonymous_kwrestarg?(); end

  def parent_has_anonymous_restarg?(); end

  def reset(); end

  def unextend(); end
  ANONYMOUS_BLOCKARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_BLOCKARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_INHERITED = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG_IN_CURRENT_SCOPE = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::UnknownEncodingInMagicComment
end

class Parser::UnknownEncodingInMagicComment
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def empty?(); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def lutime(arg, arg1); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pathname
  def self.mktmpdir(); end
end

class PrettyPrint
  VERSION = ::T.let(nil, ::T.untyped)
end

module Prism
  BACKEND = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Prism::ASCIISource
end

class Prism::ASCIISource
end

class Prism::AliasGlobalVariableNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def new_name(); end

  def old_name(); end

  def save_keyword_loc(repository); end
end

class Prism::AliasGlobalVariableNode
end

class Prism::AliasMethodNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, new_name, old_name, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def new_name(); end

  def old_name(); end

  def save_keyword_loc(repository); end
end

class Prism::AliasMethodNode
end

class Prism::AlternationPatternNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def save_operator_loc(repository); end
end

class Prism::AlternationPatternNode
end

class Prism::AndNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def save_operator_loc(repository); end
end

class Prism::AndNode
end

class Prism::ArgumentsNode
  def ===(other); end

  def arguments(); end

  def contains_forwarding?(); end

  def contains_keyword_splat?(); end

  def contains_keywords?(); end

  def contains_multiple_splats?(); end

  def contains_splat?(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, arguments); end
end

class Prism::ArgumentsNode
end

module Prism::ArgumentsNodeFlags
  CONTAINS_FORWARDING = ::T.let(nil, ::T.untyped)
  CONTAINS_KEYWORDS = ::T.let(nil, ::T.untyped)
  CONTAINS_KEYWORD_SPLAT = ::T.let(nil, ::T.untyped)
  CONTAINS_MULTIPLE_SPLATS = ::T.let(nil, ::T.untyped)
  CONTAINS_SPLAT = ::T.let(nil, ::T.untyped)
end

module Prism::ArgumentsNodeFlags
end

class Prism::ArrayNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def contains_splat?(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(source, node_id, location, flags, elements, opening_loc, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::ArrayNode
end

module Prism::ArrayNodeFlags
  CONTAINS_SPLAT = ::T.let(nil, ::T.untyped)
end

module Prism::ArrayNodeFlags
end

class Prism::ArrayPatternNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def constant(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, constant, requireds, rest, posts, opening_loc, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def posts(); end

  def requireds(); end

  def rest(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::ArrayPatternNode
end

class Prism::AssocNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, key, value, operator_loc); end

  def key(); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::AssocNode
end

class Prism::AssocSplatNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::AssocSplatNode
end

class Prism::BackReferenceReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::BackReferenceReadNode
end

class Prism::BasicVisitor
  def visit(node); end

  def visit_all(nodes); end

  def visit_child_nodes(node); end
end

class Prism::BasicVisitor
end

class Prism::BeginNode
  def ===(other); end

  def begin_keyword(); end

  def begin_keyword_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def else_clause(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def ensure_clause(); end

  def initialize(source, node_id, location, flags, begin_keyword_loc, statements, rescue_clause, else_clause, ensure_clause, end_keyword_loc); end

  def rescue_clause(); end

  def save_begin_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def statements(); end
end

class Prism::BeginNode
end

class Prism::BlockArgumentNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(source, node_id, location, flags, expression, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end
end

class Prism::BlockArgumentNode
end

class Prism::BlockLocalVariableNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end

  def repeated_parameter?(); end
end

class Prism::BlockLocalVariableNode
end

class Prism::BlockNode
  def ===(other); end

  def body(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, locals, parameters, body, opening_loc, closing_loc); end

  def locals(); end

  def opening(); end

  def opening_loc(); end

  def parameters(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::BlockNode
end

class Prism::BlockParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::BlockParameterNode
end

class Prism::BlockParametersNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, parameters, locals, opening_loc, closing_loc); end

  def locals(); end

  def opening(); end

  def opening_loc(); end

  def parameters(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::BlockParametersNode
end

class Prism::BreakNode
  def ===(other); end

  def arguments(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def save_keyword_loc(repository); end
end

class Prism::BreakNode
end

class Prism::CallAndWriteNode
  def ===(other); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_message_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallAndWriteNode
end

class Prism::CallNode
  def ===(other); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def equal(); end

  def equal_loc(); end

  def full_message_loc(); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc, opening_loc, arguments, closing_loc, equal_loc, block); end

  def message(); end

  def message_loc(); end

  def name(); end

  def opening(); end

  def opening_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_closing_loc(repository); end

  def save_equal_loc(repository); end

  def save_message_loc(repository); end

  def save_opening_loc(repository); end

  def variable_call?(); end
end

class Prism::CallNode
end

module Prism::CallNodeFlags
  ATTRIBUTE_WRITE = ::T.let(nil, ::T.untyped)
  IGNORE_VISIBILITY = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
  VARIABLE_CALL = ::T.let(nil, ::T.untyped)
end

module Prism::CallNodeFlags
end

class Prism::CallOperatorWriteNode
  def ===(other); end

  def attribute_write?(); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def call_operator(); end

  def call_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, binary_operator, binary_operator_loc, value); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_binary_operator_loc(repository); end

  def save_call_operator_loc(repository); end

  def save_message_loc(repository); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallOperatorWriteNode
end

class Prism::CallOrWriteNode
  def ===(other); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, message_loc, read_name, write_name, operator_loc, value); end

  def message(); end

  def message_loc(); end

  def operator(); end

  def operator_loc(); end

  def read_name(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_message_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end

  def variable_call?(); end

  def write_name(); end
end

class Prism::CallOrWriteNode
end

class Prism::CallTargetNode
  def ===(other); end

  def attribute_write?(); end

  def call_operator(); end

  def call_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, name, message_loc); end

  def message(); end

  def message_loc(); end

  def name(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_message_loc(repository); end

  def variable_call?(); end
end

class Prism::CallTargetNode
end

class Prism::CapturePatternNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value, target, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def target(); end

  def value(); end
end

class Prism::CapturePatternNode
end

class Prism::CaseMatchNode
  def ===(other); end

  def case_keyword(); end

  def case_keyword_loc(); end

  def conditions(); end

  def consequent(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def else_clause(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  def predicate(); end

  def save_case_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end
end

class Prism::CaseMatchNode
end

class Prism::CaseNode
  def ===(other); end

  def case_keyword(); end

  def case_keyword_loc(); end

  def conditions(); end

  def consequent(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def else_clause(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(source, node_id, location, flags, predicate, conditions, else_clause, case_keyword_loc, end_keyword_loc); end

  def predicate(); end

  def save_case_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end
end

class Prism::CaseNode
end

class Prism::ClassNode
  def ===(other); end

  def body(); end

  def class_keyword(); end

  def class_keyword_loc(); end

  def constant_path(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def inheritance_operator(); end

  def inheritance_operator_loc(); end

  def initialize(source, node_id, location, flags, locals, class_keyword_loc, constant_path, inheritance_operator_loc, superclass, body, end_keyword_loc, name); end

  def locals(); end

  def name(); end

  def save_class_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def save_inheritance_operator_loc(repository); end

  def superclass(); end
end

class Prism::ClassNode
end

class Prism::ClassVariableAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ClassVariableAndWriteNode
end

class Prism::ClassVariableOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::ClassVariableOperatorWriteNode
end

class Prism::ClassVariableOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ClassVariableOrWriteNode
end

class Prism::ClassVariableReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::ClassVariableReadNode
end

class Prism::ClassVariableTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::ClassVariableTargetNode
end

class Prism::ClassVariableWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ClassVariableWriteNode
end

class Prism::CodeUnitsCache
  def [](byte_offset); end

  def initialize(source, encoding); end
end

class Prism::CodeUnitsCache
end

class Prism::Comment
  def deconstruct_keys(keys); end

  def initialize(location); end

  def location(); end

  def slice(); end
end

class Prism::Comment
end

class Prism::Compiler
end

class Prism::Compiler
end

class Prism::ConstantAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ConstantAndWriteNode
end

class Prism::ConstantOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::ConstantOperatorWriteNode
end

class Prism::ConstantOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ConstantOrWriteNode
end

class Prism::ConstantPathAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def target(); end

  def value(); end
end

class Prism::ConstantPathAndWriteNode
end

class Prism::ConstantPathNode
  def ===(other); end

  def child(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def delimiter(); end

  def delimiter_loc(); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  def name(); end

  def name_loc(); end

  def parent(); end

  def save_delimiter_loc(repository); end

  def save_name_loc(repository); end
end

class Prism::ConstantPathNode::DynamicPartsInConstantPathError
end

class Prism::ConstantPathNode::DynamicPartsInConstantPathError
end

class Prism::ConstantPathNode::MissingNodesInConstantPathError
end

class Prism::ConstantPathNode::MissingNodesInConstantPathError
end

class Prism::ConstantPathNode
end

class Prism::ConstantPathOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, target, binary_operator_loc, value, binary_operator); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def target(); end

  def value(); end
end

class Prism::ConstantPathOperatorWriteNode
end

class Prism::ConstantPathOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def target(); end

  def value(); end
end

class Prism::ConstantPathOrWriteNode
end

class Prism::ConstantPathTargetNode
  def ===(other); end

  def child(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def delimiter(); end

  def delimiter_loc(); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(source, node_id, location, flags, parent, name, delimiter_loc, name_loc); end

  def name(); end

  def name_loc(); end

  def parent(); end

  def save_delimiter_loc(repository); end

  def save_name_loc(repository); end
end

class Prism::ConstantPathTargetNode
end

class Prism::ConstantPathWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, target, operator_loc, value); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def target(); end

  def value(); end
end

class Prism::ConstantPathWriteNode
end

class Prism::ConstantReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::ConstantReadNode
end

class Prism::ConstantTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::ConstantTargetNode
end

class Prism::ConstantWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def full_name(); end

  def full_name_parts(); end

  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::ConstantWriteNode
end

class Prism::CurrentVersionError
  def initialize(version); end
end

class Prism::CurrentVersionError
end

module Prism::DSL
  def alias_global_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def alias_method_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), new_name: T.unsafe(nil), old_name: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def alternation_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def and_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def arguments_node_flag(name); end

  def array_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def array_node_flag(name); end

  def array_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), requireds: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def assoc_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), key: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def assoc_splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def back_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def begin_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), begin_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), rescue_clause: T.unsafe(nil), else_clause: T.unsafe(nil), ensure_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def block_argument_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def block_local_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def block_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def block_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def block_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parameters: T.unsafe(nil), locals: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def break_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def call_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def call_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def call_node_flag(name); end

  def call_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def call_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), message_loc: T.unsafe(nil), read_name: T.unsafe(nil), write_name: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def call_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), name: T.unsafe(nil), message_loc: T.unsafe(nil)); end

  def capture_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def case_match_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def case_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), predicate: T.unsafe(nil), conditions: T.unsafe(nil), else_clause: T.unsafe(nil), case_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), inheritance_operator_loc: T.unsafe(nil), superclass: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  def class_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def class_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def class_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def class_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def class_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def class_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def constant_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def constant_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def constant_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def constant_path_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def constant_path_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def constant_path_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def constant_path_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def constant_path_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), parent: T.unsafe(nil), name: T.unsafe(nil), delimiter_loc: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def constant_path_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), target: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def constant_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def constant_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def constant_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def def_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def defined_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def else_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def embedded_statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def embedded_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  def encoding_flag(name); end

  def ensure_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def false_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def find_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def flip_flop_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def float_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def for_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def forwarding_arguments_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def forwarding_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def forwarding_super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  def global_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def global_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def global_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def global_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def global_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def global_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def hash_pattern_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def if_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def imaginary_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  def implicit_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def implicit_rest_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def in_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  def index_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def index_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def index_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def index_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def instance_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def instance_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def instance_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def instance_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def instance_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def instance_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def integer_base_flag(name); end

  def integer_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def interpolated_match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def interpolated_regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def interpolated_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def interpolated_string_node_flag(name); end

  def interpolated_symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def interpolated_x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def it_local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def it_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def keyword_hash_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  def keyword_hash_node_flag(name); end

  def keyword_rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def lambda_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  def local_variable_and_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def local_variable_operator_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  def local_variable_or_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def local_variable_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def local_variable_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def local_variable_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def location(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  def loop_flag(name); end

  def match_last_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def match_predicate_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def match_required_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def match_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  def missing_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def module_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  def multi_target_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  def multi_write_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def next_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def nil_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def no_keywords_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def numbered_parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  def numbered_reference_read_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  def optional_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def optional_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def or_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def parameter_flag(name); end

  def parameters_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  def parentheses_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def parentheses_node_flag(name); end

  def pinned_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  def pinned_variable_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def post_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def pre_execution_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def program_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  def range_flag(name); end

  def range_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def rational_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  def redo_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def regular_expression_flag(name); end

  def regular_expression_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def required_keyword_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def required_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def rescue_modifier_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  def rescue_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  def rest_parameter_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def retry_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def return_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def self_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def shareable_constant_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  def shareable_constant_node_flag(name); end

  def singleton_class_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def source(string); end

  def source_encoding_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def source_file_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  def source_line_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def splat_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  def statements_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  def string_flag(name); end

  def string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def super_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def symbol_flag(name); end

  def symbol_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def true_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def undef_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def unless_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def until_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  def when_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  def while_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  def x_string_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def yield_node(source: T.unsafe(nil), node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end
end

module Prism::DSL
  extend ::Prism::DSL
end

class Prism::DefNode
  def ===(other); end

  def body(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), receiver: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil), locals: T.unsafe(nil), def_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), equal_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def def_keyword(); end

  def def_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def equal(); end

  def equal_loc(); end

  def initialize(source, node_id, location, flags, name, name_loc, receiver, parameters, body, locals, def_keyword_loc, operator_loc, lparen_loc, rparen_loc, equal_loc, end_keyword_loc); end

  def locals(); end

  def lparen(); end

  def lparen_loc(); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def parameters(); end

  def receiver(); end

  def rparen(); end

  def rparen_loc(); end

  def save_def_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def save_equal_loc(repository); end

  def save_lparen_loc(repository); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def save_rparen_loc(repository); end
end

class Prism::DefNode
end

class Prism::DefinedNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lparen_loc: T.unsafe(nil), value: T.unsafe(nil), rparen_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, lparen_loc, value, rparen_loc, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def save_keyword_loc(repository); end

  def save_lparen_loc(repository); end

  def save_rparen_loc(repository); end

  def value(); end
end

class Prism::DefinedNode
end

class Prism::DesugarCompiler
end

class Prism::DesugarCompiler
end

class Prism::Dispatcher
  def dispatch(node); end

  def dispatch_once(node); end

  def listeners(); end

  def register(listener, *events); end

  def register_public_methods(listener); end
end

class Prism::Dispatcher
end

class Prism::DotVisitor
  def digraph(); end

  def to_dot(); end
end

class Prism::DotVisitor
end

class Prism::ElseNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), else_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def else_keyword(); end

  def else_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(source, node_id, location, flags, else_keyword_loc, statements, end_keyword_loc); end

  def save_else_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def statements(); end
end

class Prism::ElseNode
end

class Prism::EmbDocComment
  def trailing?(); end
end

class Prism::EmbDocComment
end

class Prism::EmbeddedStatementsNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), statements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, opening_loc, statements, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def statements(); end
end

class Prism::EmbeddedStatementsNode
end

class Prism::EmbeddedVariableNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), variable: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, operator_loc, variable); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def variable(); end
end

class Prism::EmbeddedVariableNode
end

module Prism::EncodingFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
end

module Prism::EncodingFlags
end

class Prism::EnsureNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), ensure_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def ensure_keyword(); end

  def ensure_keyword_loc(); end

  def initialize(source, node_id, location, flags, ensure_keyword_loc, statements, end_keyword_loc); end

  def save_end_keyword_loc(repository); end

  def save_ensure_keyword_loc(repository); end

  def statements(); end
end

class Prism::EnsureNode
end

class Prism::FalseNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::FalseNode
end

class Prism::FindPatternNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def constant(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), left: T.unsafe(nil), requireds: T.unsafe(nil), right: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, constant, left, requireds, right, opening_loc, closing_loc); end

  def left(); end

  def opening(); end

  def opening_loc(); end

  def requireds(); end

  def right(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::FindPatternNode
end

class Prism::FlipFlopNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def exclude_end?(); end

  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def save_operator_loc(repository); end
end

class Prism::FlipFlopNode
end

class Prism::FloatNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value); end

  def value(); end
end

class Prism::FloatNode
end

class Prism::ForNode
  def ===(other); end

  def collection(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), index: T.unsafe(nil), collection: T.unsafe(nil), statements: T.unsafe(nil), for_keyword_loc: T.unsafe(nil), in_keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def do_keyword(); end

  def do_keyword_loc(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def for_keyword(); end

  def for_keyword_loc(); end

  def in_keyword(); end

  def in_keyword_loc(); end

  def index(); end

  def initialize(source, node_id, location, flags, index, collection, statements, for_keyword_loc, in_keyword_loc, do_keyword_loc, end_keyword_loc); end

  def save_do_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def save_for_keyword_loc(repository); end

  def save_in_keyword_loc(repository); end

  def statements(); end
end

class Prism::ForNode
end

class Prism::ForwardingArgumentsNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::ForwardingArgumentsNode
end

class Prism::ForwardingParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::ForwardingParameterNode
end

class Prism::ForwardingSuperNode
  def ===(other); end

  def block(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), block: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, block); end
end

class Prism::ForwardingSuperNode
end

class Prism::GlobalVariableAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::GlobalVariableAndWriteNode
end

class Prism::GlobalVariableOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::GlobalVariableOperatorWriteNode
end

class Prism::GlobalVariableOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::GlobalVariableOrWriteNode
end

class Prism::GlobalVariableReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::GlobalVariableReadNode
end

class Prism::GlobalVariableTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::GlobalVariableTargetNode
end

class Prism::GlobalVariableWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::GlobalVariableWriteNode
end

class Prism::HashNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), elements: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(source, node_id, location, flags, opening_loc, elements, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::HashNode
end

class Prism::HashPatternNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def constant(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), constant: T.unsafe(nil), elements: T.unsafe(nil), rest: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(source, node_id, location, flags, constant, elements, rest, opening_loc, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def rest(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::HashPatternNode
end

module Prism::HeredocQuery
  def heredoc?(); end
end

module Prism::HeredocQuery
end

class Prism::IfNode
  def ===(other); end

  def consequent(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), if_keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def if_keyword(); end

  def if_keyword_loc(); end

  def initialize(source, node_id, location, flags, if_keyword_loc, predicate, then_keyword_loc, statements, subsequent, end_keyword_loc); end

  def predicate(); end

  def save_end_keyword_loc(repository); end

  def save_if_keyword_loc(repository); end

  def save_then_keyword_loc(repository); end

  def statements(); end

  def subsequent(); end

  def then_keyword(); end

  def then_keyword_loc(); end
end

class Prism::IfNode
end

class Prism::ImaginaryNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numeric: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, numeric); end

  def numeric(); end

  def value(); end
end

class Prism::ImaginaryNode
end

class Prism::ImplicitNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value); end

  def value(); end
end

class Prism::ImplicitNode
end

class Prism::ImplicitRestNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::ImplicitRestNode
end

class Prism::InNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), pattern: T.unsafe(nil), statements: T.unsafe(nil), in_loc: T.unsafe(nil), then_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def in(); end

  def in_loc(); end

  def initialize(source, node_id, location, flags, pattern, statements, in_loc, then_loc); end

  def pattern(); end

  def save_in_loc(repository); end

  def save_then_loc(repository); end

  def statements(); end

  def then_loc(); end
end

class Prism::InNode
end

class Prism::IndexAndWriteNode
  def ===(other); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexAndWriteNode
end

class Prism::IndexOperatorWriteNode
  def ===(other); end

  def arguments(); end

  def attribute_write?(); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), binary_operator: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, binary_operator, binary_operator_loc, value); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_binary_operator_loc(repository); end

  def save_call_operator_loc(repository); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexOperatorWriteNode
end

class Prism::IndexOrWriteNode
  def ===(other); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def call_operator(); end

  def call_operator_loc(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), call_operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, call_operator_loc, opening_loc, arguments, closing_loc, block, operator_loc, value); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_call_operator_loc(repository); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end

  def variable_call?(); end
end

class Prism::IndexOrWriteNode
end

class Prism::IndexTargetNode
  def ===(other); end

  def arguments(); end

  def attribute_write?(); end

  def block(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), receiver: T.unsafe(nil), opening_loc: T.unsafe(nil), arguments: T.unsafe(nil), closing_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def ignore_visibility?(); end

  def initialize(source, node_id, location, flags, receiver, opening_loc, arguments, closing_loc, block); end

  def opening(); end

  def opening_loc(); end

  def receiver(); end

  def safe_navigation?(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def variable_call?(); end
end

class Prism::IndexTargetNode
end

class Prism::InlineComment
  def trailing?(); end
end

class Prism::InlineComment
end

class Prism::InspectVisitor
  def commands(); end

  def compose(); end

  def indent(); end

  def initialize(indent=T.unsafe(nil)); end
end

class Prism::InspectVisitor
  def self.compose(node); end
end

class Prism::InstanceVariableAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::InstanceVariableAndWriteNode
end

class Prism::InstanceVariableOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), binary_operator: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, binary_operator_loc, value, binary_operator); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::InstanceVariableOperatorWriteNode
end

class Prism::InstanceVariableOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::InstanceVariableOrWriteNode
end

class Prism::InstanceVariableReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::InstanceVariableReadNode
end

class Prism::InstanceVariableTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end
end

class Prism::InstanceVariableTargetNode
end

class Prism::InstanceVariableWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, value, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::InstanceVariableWriteNode
end

module Prism::IntegerBaseFlags
  BINARY = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
end

module Prism::IntegerBaseFlags
end

class Prism::IntegerNode
  def ===(other); end

  def binary?(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil)); end

  def decimal?(); end

  def deconstruct_keys(keys); end

  def hexadecimal?(); end

  def initialize(source, node_id, location, flags, value); end

  def octal?(); end

  def value(); end
end

class Prism::IntegerNode
end

class Prism::InterpolatedMatchLastLineNode
  include ::Prism::RegularExpressionOptions
  def ===(other); end

  def ascii_8bit?(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::InterpolatedMatchLastLineNode
end

class Prism::InterpolatedRegularExpressionNode
  include ::Prism::RegularExpressionOptions
  def ===(other); end

  def ascii_8bit?(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::InterpolatedRegularExpressionNode
end

class Prism::InterpolatedStringNode
  include ::Prism::HeredocQuery
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def mutable?(); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::InterpolatedStringNode
end

module Prism::InterpolatedStringNodeFlags
  FROZEN = ::T.let(nil, ::T.untyped)
  MUTABLE = ::T.let(nil, ::T.untyped)
end

module Prism::InterpolatedStringNodeFlags
end

class Prism::InterpolatedSymbolNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::InterpolatedSymbolNode
end

class Prism::InterpolatedXStringNode
  include ::Prism::HeredocQuery
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), parts: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, opening_loc, parts, closing_loc); end

  def opening(); end

  def opening_loc(); end

  def parts(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::InterpolatedXStringNode
end

class Prism::ItLocalVariableReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::ItLocalVariableReadNode
end

class Prism::ItParametersNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::ItParametersNode
end

class Prism::KeywordHashNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), elements: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def elements(); end

  def initialize(source, node_id, location, flags, elements); end

  def symbol_keys?(); end
end

class Prism::KeywordHashNode
end

module Prism::KeywordHashNodeFlags
  SYMBOL_KEYS = ::T.let(nil, ::T.untyped)
end

module Prism::KeywordHashNodeFlags
end

class Prism::KeywordRestParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::KeywordRestParameterNode
end

class Prism::LambdaNode
  def ===(other); end

  def body(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), operator_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), parameters: T.unsafe(nil), body: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, locals, operator_loc, opening_loc, closing_loc, parameters, body); end

  def locals(); end

  def opening(); end

  def opening_loc(); end

  def operator(); end

  def operator_loc(); end

  def parameters(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::LambdaNode
end

class Prism::LexResult
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def value(); end
end

class Prism::LexResult
end

class Prism::LocalVariableAndWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::LocalVariableAndWriteNode
end

class Prism::LocalVariableOperatorWriteNode
  def ===(other); end

  def binary_operator(); end

  def binary_operator_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), binary_operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), binary_operator: T.unsafe(nil), depth: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name_loc, binary_operator_loc, value, name, binary_operator, depth); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_binary_operator_loc(repository); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::LocalVariableOperatorWriteNode
end

class Prism::LocalVariableOrWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def desugar(); end

  def initialize(source, node_id, location, flags, name_loc, operator_loc, value, name, depth); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::LocalVariableOrWriteNode
end

class Prism::LocalVariableReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(source, node_id, location, flags, name, depth); end

  def name(); end
end

class Prism::LocalVariableReadNode
end

class Prism::LocalVariableTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(source, node_id, location, flags, name, depth); end

  def name(); end
end

class Prism::LocalVariableTargetNode
end

class Prism::LocalVariableWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), depth: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def depth(); end

  def initialize(source, node_id, location, flags, name, depth, name_loc, value, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::LocalVariableWriteNode
end

class Prism::Location
  def ==(other); end

  def adjoin(string); end

  def cached_end_code_units_column(cache); end

  def cached_end_code_units_offset(cache); end

  def cached_start_code_units_column(cache); end

  def cached_start_code_units_offset(cache); end

  def chop(); end

  def comments(); end

  def copy(source: T.unsafe(nil), start_offset: T.unsafe(nil), length: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_character_column(); end

  def end_character_offset(); end

  def end_code_units_column(encoding=T.unsafe(nil)); end

  def end_code_units_offset(encoding=T.unsafe(nil)); end

  def end_column(); end

  def end_line(); end

  def end_offset(); end

  def initialize(source, start_offset, length); end

  def join(other); end

  def leading_comment(comment); end

  def leading_comments(); end

  def length(); end

  def slice(); end

  def slice_lines(); end

  def source(); end

  def source_lines(); end

  def start_character_column(); end

  def start_character_offset(); end

  def start_code_units_column(encoding=T.unsafe(nil)); end

  def start_code_units_offset(encoding=T.unsafe(nil)); end

  def start_column(); end

  def start_line(); end

  def start_line_slice(); end

  def start_offset(); end

  def trailing_comment(comment); end

  def trailing_comments(); end
end

class Prism::Location
end

module Prism::LoopFlags
  BEGIN_MODIFIER = ::T.let(nil, ::T.untyped)
end

module Prism::LoopFlags
end

class Prism::MagicComment
  def deconstruct_keys(keys); end

  def initialize(key_loc, value_loc); end

  def key(); end

  def key_loc(); end

  def value(); end

  def value_loc(); end
end

class Prism::MagicComment
end

class Prism::MatchLastLineNode
  include ::Prism::RegularExpressionOptions
  def ===(other); end

  def ascii_8bit?(); end

  def closing(); end

  def closing_loc(); end

  def content(); end

  def content_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_content_loc(repository); end

  def save_opening_loc(repository); end

  def unescaped(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::MatchLastLineNode
end

class Prism::MatchPredicateNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def pattern(); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::MatchPredicateNode
end

class Prism::MatchRequiredNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), value: T.unsafe(nil), pattern: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, value, pattern, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def pattern(); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::MatchRequiredNode
end

class Prism::MatchWriteNode
  def ===(other); end

  def call(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), call: T.unsafe(nil), targets: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, call, targets); end

  def targets(); end
end

class Prism::MatchWriteNode
end

class Prism::MissingNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::MissingNode
end

class Prism::ModuleNode
  def ===(other); end

  def body(); end

  def constant_path(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), module_keyword_loc: T.unsafe(nil), constant_path: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(source, node_id, location, flags, locals, module_keyword_loc, constant_path, body, end_keyword_loc, name); end

  def locals(); end

  def module_keyword(); end

  def module_keyword_loc(); end

  def name(); end

  def save_end_keyword_loc(repository); end

  def save_module_keyword_loc(repository); end
end

class Prism::ModuleNode
end

class Prism::MultiTargetNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc); end

  def lefts(); end

  def lparen(); end

  def lparen_loc(); end

  def rest(); end

  def rights(); end

  def rparen(); end

  def rparen_loc(); end

  def save_lparen_loc(repository); end

  def save_rparen_loc(repository); end
end

class Prism::MultiTargetNode
end

class Prism::MultiWriteNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), lefts: T.unsafe(nil), rest: T.unsafe(nil), rights: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, lefts, rest, rights, lparen_loc, rparen_loc, operator_loc, value); end

  def lefts(); end

  def lparen(); end

  def lparen_loc(); end

  def operator(); end

  def operator_loc(); end

  def rest(); end

  def rights(); end

  def rparen(); end

  def rparen_loc(); end

  def save_lparen_loc(repository); end

  def save_operator_loc(repository); end

  def save_rparen_loc(repository); end

  def value(); end
end

class Prism::MultiWriteNode
end

class Prism::MutationCompiler
end

class Prism::MutationCompiler
end

class Prism::NextNode
  def ===(other); end

  def arguments(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), arguments: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, arguments, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def save_keyword_loc(repository); end
end

class Prism::NextNode
end

class Prism::NilNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::NilNode
end

class Prism::NoKeywordsParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, operator_loc, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def operator(); end

  def operator_loc(); end

  def save_keyword_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::NoKeywordsParameterNode
end

class Prism::Node
  def accept(visitor); end

  def breadth_first_search(&block); end

  def cached_end_code_units_column(cache); end

  def cached_end_code_units_offset(cache); end

  def cached_start_code_units_column(cache); end

  def cached_start_code_units_offset(cache); end

  def child_nodes(); end

  def comment_targets(); end

  def comments(); end

  def compact_child_nodes(); end

  def deconstruct(); end

  def deprecated(*replacements); end

  def each_child_node(); end

  def end_character_column(); end

  def end_character_offset(); end

  def end_column(); end

  def end_line(); end

  def end_offset(); end

  def flags(); end

  def leading_comments(); end

  def location(); end

  def newline?(); end

  def node_id(); end

  def save(repository); end

  def save_location(repository); end

  def script_lines(); end

  def slice(); end

  def slice_lines(); end

  def source_lines(); end

  def start_character_column(); end

  def start_character_offset(); end

  def start_column(); end

  def start_line(); end

  def start_offset(); end

  def static_literal?(); end

  def to_dot(); end

  def trailing_comments(); end

  def tunnel(line, column); end

  def type(); end
end

class Prism::Node
  def self.fields(); end

  def self.type(); end
end

module Prism::NodeFlags
  NEWLINE = ::T.let(nil, ::T.untyped)
  STATIC_LITERAL = ::T.let(nil, ::T.untyped)
end

module Prism::NodeFlags
end

class Prism::NumberedParametersNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), maximum: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, maximum); end

  def maximum(); end
end

class Prism::NumberedParametersNode
end

class Prism::NumberedReferenceReadNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), number: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, number); end

  def number(); end
end

class Prism::NumberedReferenceReadNode
end

class Prism::OptionalKeywordParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, value); end

  def name(); end

  def name_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end

  def value(); end
end

class Prism::OptionalKeywordParameterNode
end

class Prism::OptionalParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), value: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc, value); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end

  def value(); end
end

class Prism::OptionalParameterNode
end

class Prism::OrNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def save_operator_loc(repository); end
end

class Prism::OrNode
end

module Prism::Pack
  AGNOSTIC_ENDIAN = ::T.let(nil, ::T.untyped)
  BACK = ::T.let(nil, ::T.untyped)
  BER = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  ENDIAN_NA = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  LENGTH_FIXED = ::T.let(nil, ::T.untyped)
  LENGTH_MAX = ::T.let(nil, ::T.untyped)
  LENGTH_NA = ::T.let(nil, ::T.untyped)
  LENGTH_RELATIVE = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  MOVE = ::T.let(nil, ::T.untyped)
  NATIVE_ENDIAN = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  SIGNED = ::T.let(nil, ::T.untyped)
  SIGNED_NA = ::T.let(nil, ::T.untyped)
  SIZE_16 = ::T.let(nil, ::T.untyped)
  SIZE_32 = ::T.let(nil, ::T.untyped)
  SIZE_64 = ::T.let(nil, ::T.untyped)
  SIZE_8 = ::T.let(nil, ::T.untyped)
  SIZE_INT = ::T.let(nil, ::T.untyped)
  SIZE_LONG = ::T.let(nil, ::T.untyped)
  SIZE_LONG_LONG = ::T.let(nil, ::T.untyped)
  SIZE_NA = ::T.let(nil, ::T.untyped)
  SIZE_P = ::T.let(nil, ::T.untyped)
  SIZE_SHORT = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  STRING_BASE64 = ::T.let(nil, ::T.untyped)
  STRING_FIXED = ::T.let(nil, ::T.untyped)
  STRING_HEX_HIGH = ::T.let(nil, ::T.untyped)
  STRING_HEX_LOW = ::T.let(nil, ::T.untyped)
  STRING_LSB = ::T.let(nil, ::T.untyped)
  STRING_MIME = ::T.let(nil, ::T.untyped)
  STRING_MSB = ::T.let(nil, ::T.untyped)
  STRING_NULL_PADDED = ::T.let(nil, ::T.untyped)
  STRING_NULL_TERMINATED = ::T.let(nil, ::T.untyped)
  STRING_POINTER = ::T.let(nil, ::T.untyped)
  STRING_SPACE_PADDED = ::T.let(nil, ::T.untyped)
  STRING_UU = ::T.let(nil, ::T.untyped)
  UNSIGNED = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Prism::Pack::Directive
  def describe(); end

  def endian(); end

  def initialize(version, variant, source, type, signed, endian, size, length_type, length); end

  def length(); end

  def length_type(); end

  def signed(); end

  def size(); end

  def source(); end

  def type(); end

  def variant(); end

  def version(); end
  ENDIAN_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  SIGNED_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  SIZE_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
end

class Prism::Pack::Directive
end

class Prism::Pack::Format
  def describe(); end

  def directives(); end

  def encoding(); end

  def initialize(directives, encoding); end
end

class Prism::Pack::Format
end

module Prism::Pack
  def self.parse(arg, arg1, arg2); end
end

module Prism::ParameterFlags
  REPEATED_PARAMETER = ::T.let(nil, ::T.untyped)
end

module Prism::ParameterFlags
end

class Prism::ParametersNode
  def ===(other); end

  def block(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), requireds: T.unsafe(nil), optionals: T.unsafe(nil), rest: T.unsafe(nil), posts: T.unsafe(nil), keywords: T.unsafe(nil), keyword_rest: T.unsafe(nil), block: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, requireds, optionals, rest, posts, keywords, keyword_rest, block); end

  def keyword_rest(); end

  def keywords(); end

  def optionals(); end

  def posts(); end

  def requireds(); end

  def rest(); end

  def signature(); end
end

class Prism::ParametersNode
end

class Prism::ParenthesesNode
  def ===(other); end

  def body(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, body, opening_loc, closing_loc); end

  def multiple_statements?(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end
end

class Prism::ParenthesesNode
end

module Prism::ParenthesesNodeFlags
  MULTIPLE_STATEMENTS = ::T.let(nil, ::T.untyped)
end

module Prism::ParenthesesNodeFlags
end

class Prism::ParseError
  def deconstruct_keys(keys); end

  def initialize(type, message, location, level); end

  def level(); end

  def location(); end

  def message(); end

  def type(); end
end

class Prism::ParseError
end

class Prism::ParseLexResult
  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def value(); end
end

class Prism::ParseLexResult
end

class Prism::ParseResult
  def attach_comments!(); end

  def errors_format(); end

  def initialize(value, comments, magic_comments, data_loc, errors, warnings, source); end

  def mark_newlines!(); end

  def value(); end
end

class Prism::ParseResult
end

class Prism::ParseWarning
  def deconstruct_keys(keys); end

  def initialize(type, message, location, level); end

  def level(); end

  def location(); end

  def message(); end

  def type(); end
end

class Prism::ParseWarning
end

class Prism::Pattern
  def compile(); end

  def initialize(query); end

  def query(); end

  def scan(root); end
end

class Prism::Pattern::CompilationError
  def initialize(repr); end
end

class Prism::Pattern::CompilationError
end

class Prism::Pattern
end

class Prism::PinnedExpressionNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), operator_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(source, node_id, location, flags, expression, operator_loc, lparen_loc, rparen_loc); end

  def lparen(); end

  def lparen_loc(); end

  def operator(); end

  def operator_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def save_lparen_loc(repository); end

  def save_operator_loc(repository); end

  def save_rparen_loc(repository); end
end

class Prism::PinnedExpressionNode
end

class Prism::PinnedVariableNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), variable: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, variable, operator_loc); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end

  def variable(); end
end

class Prism::PinnedVariableNode
end

class Prism::PostExecutionNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  def keyword(); end

  def keyword_loc(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_keyword_loc(repository); end

  def save_opening_loc(repository); end

  def statements(); end
end

class Prism::PostExecutionNode
end

class Prism::PreExecutionNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), statements: T.unsafe(nil), keyword_loc: T.unsafe(nil), opening_loc: T.unsafe(nil), closing_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, statements, keyword_loc, opening_loc, closing_loc); end

  def keyword(); end

  def keyword_loc(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_keyword_loc(repository); end

  def save_opening_loc(repository); end

  def statements(); end
end

class Prism::PreExecutionNode
end

class Prism::ProgramNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), statements: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, locals, statements); end

  def locals(); end

  def statements(); end
end

class Prism::ProgramNode
end

module Prism::RangeFlags
  EXCLUDE_END = ::T.let(nil, ::T.untyped)
end

module Prism::RangeFlags
end

class Prism::RangeNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def exclude_end?(); end

  def initialize(source, node_id, location, flags, left, right, operator_loc); end

  def left(); end

  def operator(); end

  def operator_loc(); end

  def right(); end

  def save_operator_loc(repository); end
end

class Prism::RangeNode
end

class Prism::RationalNode
  def ===(other); end

  def binary?(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), numerator: T.unsafe(nil), denominator: T.unsafe(nil)); end

  def decimal?(); end

  def deconstruct_keys(keys); end

  def denominator(); end

  def hexadecimal?(); end

  def initialize(source, node_id, location, flags, numerator, denominator); end

  def numerator(); end

  def numeric(); end

  def octal?(); end

  def value(); end
end

class Prism::RationalNode
end

class Prism::RedoNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::RedoNode
end

module Prism::Reflection
end

class Prism::Reflection::ConstantField
end

class Prism::Reflection::ConstantField
end

class Prism::Reflection::ConstantListField
end

class Prism::Reflection::ConstantListField
end

class Prism::Reflection::Field
  def initialize(name); end

  def name(); end
end

class Prism::Reflection::Field
end

class Prism::Reflection::FlagsField
  def flags(); end

  def initialize(name, flags); end
end

class Prism::Reflection::FlagsField
end

class Prism::Reflection::FloatField
end

class Prism::Reflection::FloatField
end

class Prism::Reflection::IntegerField
end

class Prism::Reflection::IntegerField
end

class Prism::Reflection::LocationField
end

class Prism::Reflection::LocationField
end

class Prism::Reflection::NodeField
end

class Prism::Reflection::NodeField
end

class Prism::Reflection::NodeListField
end

class Prism::Reflection::NodeListField
end

class Prism::Reflection::OptionalConstantField
end

class Prism::Reflection::OptionalConstantField
end

class Prism::Reflection::OptionalLocationField
end

class Prism::Reflection::OptionalLocationField
end

class Prism::Reflection::OptionalNodeField
end

class Prism::Reflection::OptionalNodeField
end

class Prism::Reflection::StringField
end

class Prism::Reflection::StringField
end

module Prism::Reflection
  def self.fields_for(node); end
end

module Prism::RegularExpressionFlags
  ASCII_8BIT = ::T.let(nil, ::T.untyped)
  EUC_JP = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_US_ASCII_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
  IGNORE_CASE = ::T.let(nil, ::T.untyped)
  MULTI_LINE = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
  WINDOWS_31J = ::T.let(nil, ::T.untyped)
end

module Prism::RegularExpressionFlags
end

class Prism::RegularExpressionNode
  include ::Prism::RegularExpressionOptions
  def ===(other); end

  def ascii_8bit?(); end

  def closing(); end

  def closing_loc(); end

  def content(); end

  def content_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def euc_jp?(); end

  def extended?(); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def ignore_case?(); end

  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def multi_line?(); end

  def once?(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_content_loc(repository); end

  def save_opening_loc(repository); end

  def unescaped(); end

  def utf_8?(); end

  def windows_31j?(); end
end

class Prism::RegularExpressionNode
end

module Prism::RegularExpressionOptions
  def options(); end
end

module Prism::RegularExpressionOptions
end

module Prism::Relocation
end

class Prism::Relocation::CharacterColumnsField
  def fields(value); end
end

class Prism::Relocation::CharacterColumnsField
end

class Prism::Relocation::CharacterOffsetsField
  def fields(value); end
end

class Prism::Relocation::CharacterOffsetsField
end

class Prism::Relocation::CodeUnitColumnsField
  def encoding(); end

  def fields(value); end

  def initialize(repository, encoding); end

  def repository(); end
end

class Prism::Relocation::CodeUnitColumnsField
end

class Prism::Relocation::CodeUnitOffsetsField
  def encoding(); end

  def fields(value); end

  def initialize(repository, encoding); end

  def repository(); end
end

class Prism::Relocation::CodeUnitOffsetsField
end

class Prism::Relocation::ColumnsField
  def fields(value); end
end

class Prism::Relocation::ColumnsField
end

class Prism::Relocation::CommentsField
end

class Prism::Relocation::CommentsField::Comment
  def initialize(slice); end

  def slice(); end
end

class Prism::Relocation::CommentsField::Comment
end

class Prism::Relocation::CommentsField
end

class Prism::Relocation::Entry
  def comments(); end

  def end_character_column(); end

  def end_character_offset(); end

  def end_code_units_column(); end

  def end_code_units_offset(); end

  def end_column(); end

  def end_line(); end

  def end_offset(); end

  def filepath(); end

  def initialize(repository); end

  def leading_comments(); end

  def reify!(values); end

  def start_character_column(); end

  def start_character_offset(); end

  def start_code_units_column(); end

  def start_code_units_offset(); end

  def start_column(); end

  def start_line(); end

  def start_offset(); end

  def trailing_comments(); end
end

class Prism::Relocation::Entry::MissingValueError
end

class Prism::Relocation::Entry::MissingValueError
end

class Prism::Relocation::Entry
end

class Prism::Relocation::FilepathField
  def fields(_value); end

  def initialize(value); end

  def value(); end
end

class Prism::Relocation::FilepathField
end

class Prism::Relocation::LeadingCommentsField
  def fields(value); end
end

class Prism::Relocation::LeadingCommentsField
end

class Prism::Relocation::LinesField
  def fields(value); end
end

class Prism::Relocation::LinesField
end

class Prism::Relocation::OffsetsField
  def fields(value); end
end

class Prism::Relocation::OffsetsField
end

class Prism::Relocation::Repository
  def character_columns(); end

  def character_offsets(); end

  def code_unit_columns(encoding); end

  def code_unit_offsets(encoding); end

  def code_units_cache(encoding); end

  def columns(); end

  def comments(); end

  def enter(node_id, field_name); end

  def entries(); end

  def fields(); end

  def filepath(); end

  def initialize(source); end

  def leading_comments(); end

  def lines(); end

  def offsets(); end

  def reify!(); end

  def source(); end

  def trailing_comments(); end
end

class Prism::Relocation::Repository::ConfigurationError
end

class Prism::Relocation::Repository::ConfigurationError
end

class Prism::Relocation::Repository
end

class Prism::Relocation::Source
  def code_units_cache(encoding); end

  def initialize(value); end

  def result(); end

  def value(); end
end

class Prism::Relocation::Source
end

class Prism::Relocation::SourceFilepath
end

class Prism::Relocation::SourceFilepath
end

class Prism::Relocation::SourceString
end

class Prism::Relocation::SourceString
end

class Prism::Relocation::TrailingCommentsField
  def fields(value); end
end

class Prism::Relocation::TrailingCommentsField
end

module Prism::Relocation
  def self.filepath(value); end

  def self.string(value); end
end

class Prism::RequiredKeywordParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc); end

  def name(); end

  def name_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end
end

class Prism::RequiredKeywordParameterNode
end

class Prism::RequiredParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name); end

  def name(); end

  def repeated_parameter?(); end
end

class Prism::RequiredParameterNode
end

class Prism::RescueModifierNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), expression: T.unsafe(nil), keyword_loc: T.unsafe(nil), rescue_expression: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(source, node_id, location, flags, expression, keyword_loc, rescue_expression); end

  def keyword(); end

  def keyword_loc(); end

  def rescue_expression(); end

  def save_keyword_loc(repository); end
end

class Prism::RescueModifierNode
end

class Prism::RescueNode
  def ===(other); end

  def consequent(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), exceptions: T.unsafe(nil), operator_loc: T.unsafe(nil), reference: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), subsequent: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def exceptions(); end

  def initialize(source, node_id, location, flags, keyword_loc, exceptions, operator_loc, reference, then_keyword_loc, statements, subsequent); end

  def keyword(); end

  def keyword_loc(); end

  def operator(); end

  def operator_loc(); end

  def reference(); end

  def save_keyword_loc(repository); end

  def save_operator_loc(repository); end

  def save_then_keyword_loc(repository); end

  def statements(); end

  def subsequent(); end

  def then_keyword(); end

  def then_keyword_loc(); end
end

class Prism::RescueNode
end

class Prism::RestParameterNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), name: T.unsafe(nil), name_loc: T.unsafe(nil), operator_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, name, name_loc, operator_loc); end

  def name(); end

  def name_loc(); end

  def operator(); end

  def operator_loc(); end

  def repeated_parameter?(); end

  def save_name_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::RestParameterNode
end

class Prism::Result
  def code_units_cache(encoding); end

  def comments(); end

  def data_loc(); end

  def deconstruct_keys(keys); end

  def encoding(); end

  def errors(); end

  def failure?(); end

  def initialize(comments, magic_comments, data_loc, errors, warnings, source); end

  def magic_comments(); end

  def source(); end

  def success?(); end

  def warnings(); end
end

class Prism::Result
end

class Prism::RetryNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::RetryNode
end

class Prism::ReturnNode
  def ===(other); end

  def arguments(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, keyword_loc, arguments); end

  def keyword(); end

  def keyword_loc(); end

  def save_keyword_loc(repository); end
end

class Prism::ReturnNode
end

class Prism::Scope
  def forwarding(); end

  def initialize(locals, forwarding); end

  def locals(); end
end

class Prism::Scope
end

class Prism::SelfNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::SelfNode
end

module Prism::Serialize
end

module Prism::Serialize
  def self.load_lex(input, serialized, freeze); end

  def self.load_parse(input, serialized, freeze); end

  def self.load_parse_comments(input, serialized, freeze); end

  def self.load_parse_lex(input, serialized, freeze); end
end

class Prism::ShareableConstantNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), write: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def experimental_copy?(); end

  def experimental_everything?(); end

  def initialize(source, node_id, location, flags, write); end

  def literal?(); end

  def write(); end
end

class Prism::ShareableConstantNode
end

module Prism::ShareableConstantNodeFlags
  EXPERIMENTAL_COPY = ::T.let(nil, ::T.untyped)
  EXPERIMENTAL_EVERYTHING = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

module Prism::ShareableConstantNodeFlags
end

class Prism::SingletonClassNode
  def ===(other); end

  def body(); end

  def class_keyword(); end

  def class_keyword_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), locals: T.unsafe(nil), class_keyword_loc: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil), body: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def expression(); end

  def initialize(source, node_id, location, flags, locals, class_keyword_loc, operator_loc, expression, body, end_keyword_loc); end

  def locals(); end

  def operator(); end

  def operator_loc(); end

  def save_class_keyword_loc(repository); end

  def save_end_keyword_loc(repository); end

  def save_operator_loc(repository); end
end

class Prism::SingletonClassNode
end

class Prism::Source
  def character_column(byte_offset); end

  def character_offset(byte_offset); end

  def code_units_cache(encoding); end

  def code_units_column(byte_offset, encoding); end

  def code_units_offset(byte_offset, encoding); end

  def column(byte_offset); end

  def deep_freeze(); end

  def encoding(); end

  def initialize(source, start_line=T.unsafe(nil), offsets=T.unsafe(nil)); end

  def line(byte_offset); end

  def line_end(byte_offset); end

  def line_start(byte_offset); end

  def lines(); end

  def offsets(); end

  def replace_offsets(offsets); end

  def replace_start_line(start_line); end

  def slice(byte_offset, length); end

  def source(); end

  def start_line(); end
end

class Prism::Source
  def self.for(source, start_line=T.unsafe(nil), offsets=T.unsafe(nil)); end
end

class Prism::SourceEncodingNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::SourceEncodingNode
end

class Prism::SourceFileNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), filepath: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def filepath(); end

  def forced_binary_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(source, node_id, location, flags, filepath); end

  def mutable?(); end
end

class Prism::SourceFileNode
end

class Prism::SourceLineNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::SourceLineNode
end

class Prism::SplatNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), operator_loc: T.unsafe(nil), expression: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def expression(); end

  def initialize(source, node_id, location, flags, operator_loc, expression); end

  def operator(); end

  def operator_loc(); end

  def save_operator_loc(repository); end
end

class Prism::SplatNode
end

class Prism::StatementsNode
  def ===(other); end

  def body(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), body: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, body); end
end

class Prism::StatementsNode
end

module Prism::StringFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
  FROZEN = ::T.let(nil, ::T.untyped)
  MUTABLE = ::T.let(nil, ::T.untyped)
end

module Prism::StringFlags
end

class Prism::StringNode
  include ::Prism::HeredocQuery
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def content(); end

  def content_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def mutable?(); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_content_loc(repository); end

  def save_opening_loc(repository); end

  def to_interpolated(); end

  def unescaped(); end
end

class Prism::StringNode
end

class Prism::StringQuery
  def constant?(); end

  def initialize(string); end

  def local?(); end

  def method_name?(); end

  def string(); end
end

class Prism::StringQuery
  def self.constant?(arg); end

  def self.local?(arg); end

  def self.method_name?(arg); end
end

class Prism::SuperNode
  def ===(other); end

  def arguments(); end

  def block(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil), block: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc, block); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def save_keyword_loc(repository); end

  def save_lparen_loc(repository); end

  def save_rparen_loc(repository); end
end

class Prism::SuperNode
end

module Prism::SymbolFlags
  FORCED_BINARY_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_US_ASCII_ENCODING = ::T.let(nil, ::T.untyped)
  FORCED_UTF8_ENCODING = ::T.let(nil, ::T.untyped)
end

module Prism::SymbolFlags
end

class Prism::SymbolNode
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), value_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_us_ascii_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(source, node_id, location, flags, opening_loc, value_loc, closing_loc, unescaped); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_opening_loc(repository); end

  def save_value_loc(repository); end

  def unescaped(); end

  def value(); end

  def value_loc(); end
end

class Prism::SymbolNode
end

class Prism::Token
  def ==(other); end

  def deconstruct_keys(keys); end

  def deep_freeze(); end

  def initialize(source, type, value, location); end

  def location(); end

  def type(); end

  def value(); end
end

class Prism::Token
end

module Prism::Translation
end

class Prism::Translation::Parser
  def default_encoding(); end

  def initialize(builder=T.unsafe(nil), parser: T.unsafe(nil)); end

  def try_declare_numparam(node); end

  def version(); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class Prism::Translation::Parser::Builder
  def itarg(); end
end

class Prism::Translation::Parser::Builder
end

class Prism::Translation::Parser::PrismDiagnostic
  def initialize(message, level, reason, location); end
end

class Prism::Translation::Parser::PrismDiagnostic
end

class Prism::Translation::Parser
end

class Prism::Translation::Parser33
end

class Prism::Translation::Parser33
end

class Prism::Translation::Parser34
end

class Prism::Translation::Parser34
end

Prism::Translation::Parser35 = Prism::Translation::Parser40

class Prism::Translation::Parser40
end

class Prism::Translation::Parser40
end

class Prism::Translation::Parser41
end

class Prism::Translation::Parser41
end

Prism::Translation::ParserCurrent = Prism::Translation::Parser34

class Prism::Translation::Ripper
  def column(); end

  def error?(); end

  def filename(); end

  def initialize(source, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(); end

  def source(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
end

class Prism::Translation::Ripper::Lexer
end

class Prism::Translation::Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Prism::Translation::Ripper::Lexer::State
end

class Prism::Translation::Ripper::Lexer
end

class Prism::Translation::Ripper::SexpBuilder
  def error(); end

  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Prism::Translation::Ripper::SexpBuilder
end

class Prism::Translation::Ripper::SexpBuilderPP
end

class Prism::Translation::Ripper::SexpBuilderPP
end

class Prism::Translation::Ripper
  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil), raise_errors: T.unsafe(nil)); end

  def self.lex_state_name(state); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.sexp(src, filename=T.unsafe(nil), lineno=T.unsafe(nil), raise_errors: T.unsafe(nil)); end

  def self.sexp_raw(src, filename=T.unsafe(nil), lineno=T.unsafe(nil), raise_errors: T.unsafe(nil)); end
end

class Prism::Translation::RubyParser
  def parse(source, filepath=T.unsafe(nil)); end

  def parse_file(filepath); end

  def process(ruby, file=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Prism::Translation::RubyParser
  def self.parse(source, filepath=T.unsafe(nil)); end

  def self.parse_file(filepath); end
end

module Prism::Translation
end

class Prism::TrueNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags); end
end

class Prism::TrueNode
end

class Prism::UndefNode
  def ===(other); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), names: T.unsafe(nil), keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, names, keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def names(); end

  def save_keyword_loc(repository); end
end

class Prism::UndefNode
end

class Prism::UnlessNode
  def ===(other); end

  def consequent(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), predicate: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil), else_clause: T.unsafe(nil), end_keyword_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def else_clause(); end

  def end_keyword(); end

  def end_keyword_loc(); end

  def initialize(source, node_id, location, flags, keyword_loc, predicate, then_keyword_loc, statements, else_clause, end_keyword_loc); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def save_end_keyword_loc(repository); end

  def save_keyword_loc(repository); end

  def save_then_keyword_loc(repository); end

  def statements(); end

  def then_keyword(); end

  def then_keyword_loc(); end
end

class Prism::UnlessNode
end

class Prism::UntilNode
  def ===(other); end

  def begin_modifier?(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def do_keyword(); end

  def do_keyword_loc(); end

  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def save_closing_loc(repository); end

  def save_do_keyword_loc(repository); end

  def save_keyword_loc(repository); end

  def statements(); end
end

class Prism::UntilNode
end

class Prism::Visitor
  def visit_alias_global_variable_node(node); end

  def visit_alias_method_node(node); end

  def visit_alternation_pattern_node(node); end

  def visit_and_node(node); end

  def visit_arguments_node(node); end

  def visit_array_node(node); end

  def visit_array_pattern_node(node); end

  def visit_assoc_node(node); end

  def visit_assoc_splat_node(node); end

  def visit_back_reference_read_node(node); end

  def visit_begin_node(node); end

  def visit_block_argument_node(node); end

  def visit_block_local_variable_node(node); end

  def visit_block_node(node); end

  def visit_block_parameter_node(node); end

  def visit_block_parameters_node(node); end

  def visit_break_node(node); end

  def visit_call_and_write_node(node); end

  def visit_call_node(node); end

  def visit_call_operator_write_node(node); end

  def visit_call_or_write_node(node); end

  def visit_call_target_node(node); end

  def visit_capture_pattern_node(node); end

  def visit_case_match_node(node); end

  def visit_case_node(node); end

  def visit_class_node(node); end

  def visit_class_variable_and_write_node(node); end

  def visit_class_variable_operator_write_node(node); end

  def visit_class_variable_or_write_node(node); end

  def visit_class_variable_read_node(node); end

  def visit_class_variable_target_node(node); end

  def visit_class_variable_write_node(node); end

  def visit_constant_and_write_node(node); end

  def visit_constant_operator_write_node(node); end

  def visit_constant_or_write_node(node); end

  def visit_constant_path_and_write_node(node); end

  def visit_constant_path_node(node); end

  def visit_constant_path_operator_write_node(node); end

  def visit_constant_path_or_write_node(node); end

  def visit_constant_path_target_node(node); end

  def visit_constant_path_write_node(node); end

  def visit_constant_read_node(node); end

  def visit_constant_target_node(node); end

  def visit_constant_write_node(node); end

  def visit_def_node(node); end

  def visit_defined_node(node); end

  def visit_else_node(node); end

  def visit_embedded_statements_node(node); end

  def visit_embedded_variable_node(node); end

  def visit_ensure_node(node); end

  def visit_false_node(node); end

  def visit_find_pattern_node(node); end

  def visit_flip_flop_node(node); end

  def visit_float_node(node); end

  def visit_for_node(node); end

  def visit_forwarding_arguments_node(node); end

  def visit_forwarding_parameter_node(node); end

  def visit_forwarding_super_node(node); end

  def visit_global_variable_and_write_node(node); end

  def visit_global_variable_operator_write_node(node); end

  def visit_global_variable_or_write_node(node); end

  def visit_global_variable_read_node(node); end

  def visit_global_variable_target_node(node); end

  def visit_global_variable_write_node(node); end

  def visit_hash_node(node); end

  def visit_hash_pattern_node(node); end

  def visit_if_node(node); end

  def visit_imaginary_node(node); end

  def visit_implicit_node(node); end

  def visit_implicit_rest_node(node); end

  def visit_in_node(node); end

  def visit_index_and_write_node(node); end

  def visit_index_operator_write_node(node); end

  def visit_index_or_write_node(node); end

  def visit_index_target_node(node); end

  def visit_instance_variable_and_write_node(node); end

  def visit_instance_variable_operator_write_node(node); end

  def visit_instance_variable_or_write_node(node); end

  def visit_instance_variable_read_node(node); end

  def visit_instance_variable_target_node(node); end

  def visit_instance_variable_write_node(node); end

  def visit_integer_node(node); end

  def visit_interpolated_match_last_line_node(node); end

  def visit_interpolated_regular_expression_node(node); end

  def visit_interpolated_string_node(node); end

  def visit_interpolated_symbol_node(node); end

  def visit_interpolated_x_string_node(node); end

  def visit_it_local_variable_read_node(node); end

  def visit_it_parameters_node(node); end

  def visit_keyword_hash_node(node); end

  def visit_keyword_rest_parameter_node(node); end

  def visit_lambda_node(node); end

  def visit_local_variable_and_write_node(node); end

  def visit_local_variable_operator_write_node(node); end

  def visit_local_variable_or_write_node(node); end

  def visit_local_variable_read_node(node); end

  def visit_local_variable_target_node(node); end

  def visit_local_variable_write_node(node); end

  def visit_match_last_line_node(node); end

  def visit_match_predicate_node(node); end

  def visit_match_required_node(node); end

  def visit_match_write_node(node); end

  def visit_missing_node(node); end

  def visit_module_node(node); end

  def visit_multi_target_node(node); end

  def visit_multi_write_node(node); end

  def visit_next_node(node); end

  def visit_nil_node(node); end

  def visit_no_keywords_parameter_node(node); end

  def visit_numbered_parameters_node(node); end

  def visit_numbered_reference_read_node(node); end

  def visit_optional_keyword_parameter_node(node); end

  def visit_optional_parameter_node(node); end

  def visit_or_node(node); end

  def visit_parameters_node(node); end

  def visit_parentheses_node(node); end

  def visit_pinned_expression_node(node); end

  def visit_pinned_variable_node(node); end

  def visit_post_execution_node(node); end

  def visit_pre_execution_node(node); end

  def visit_program_node(node); end

  def visit_range_node(node); end

  def visit_rational_node(node); end

  def visit_redo_node(node); end

  def visit_regular_expression_node(node); end

  def visit_required_keyword_parameter_node(node); end

  def visit_required_parameter_node(node); end

  def visit_rescue_modifier_node(node); end

  def visit_rescue_node(node); end

  def visit_rest_parameter_node(node); end

  def visit_retry_node(node); end

  def visit_return_node(node); end

  def visit_self_node(node); end

  def visit_shareable_constant_node(node); end

  def visit_singleton_class_node(node); end

  def visit_source_encoding_node(node); end

  def visit_source_file_node(node); end

  def visit_source_line_node(node); end

  def visit_splat_node(node); end

  def visit_statements_node(node); end

  def visit_string_node(node); end

  def visit_super_node(node); end

  def visit_symbol_node(node); end

  def visit_true_node(node); end

  def visit_undef_node(node); end

  def visit_unless_node(node); end

  def visit_until_node(node); end

  def visit_when_node(node); end

  def visit_while_node(node); end

  def visit_x_string_node(node); end

  def visit_yield_node(node); end
end

class Prism::Visitor
end

class Prism::WhenNode
  def ===(other); end

  def conditions(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), conditions: T.unsafe(nil), then_keyword_loc: T.unsafe(nil), statements: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, keyword_loc, conditions, then_keyword_loc, statements); end

  def keyword(); end

  def keyword_loc(); end

  def save_keyword_loc(repository); end

  def save_then_keyword_loc(repository); end

  def statements(); end

  def then_keyword(); end

  def then_keyword_loc(); end
end

class Prism::WhenNode
end

class Prism::WhileNode
  def ===(other); end

  def begin_modifier?(); end

  def closing(); end

  def closing_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), do_keyword_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), predicate: T.unsafe(nil), statements: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def do_keyword(); end

  def do_keyword_loc(); end

  def initialize(source, node_id, location, flags, keyword_loc, do_keyword_loc, closing_loc, predicate, statements); end

  def keyword(); end

  def keyword_loc(); end

  def predicate(); end

  def save_closing_loc(repository); end

  def save_do_keyword_loc(repository); end

  def save_keyword_loc(repository); end

  def statements(); end
end

class Prism::WhileNode
end

class Prism::XStringNode
  include ::Prism::HeredocQuery
  def ===(other); end

  def closing(); end

  def closing_loc(); end

  def content(); end

  def content_loc(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), opening_loc: T.unsafe(nil), content_loc: T.unsafe(nil), closing_loc: T.unsafe(nil), unescaped: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def forced_binary_encoding?(); end

  def forced_utf8_encoding?(); end

  def initialize(source, node_id, location, flags, opening_loc, content_loc, closing_loc, unescaped); end

  def opening(); end

  def opening_loc(); end

  def save_closing_loc(repository); end

  def save_content_loc(repository); end

  def save_opening_loc(repository); end

  def to_interpolated(); end

  def unescaped(); end
end

class Prism::XStringNode
end

class Prism::YieldNode
  def ===(other); end

  def arguments(); end

  def copy(node_id: T.unsafe(nil), location: T.unsafe(nil), flags: T.unsafe(nil), keyword_loc: T.unsafe(nil), lparen_loc: T.unsafe(nil), arguments: T.unsafe(nil), rparen_loc: T.unsafe(nil)); end

  def deconstruct_keys(keys); end

  def initialize(source, node_id, location, flags, keyword_loc, lparen_loc, arguments, rparen_loc); end

  def keyword(); end

  def keyword_loc(); end

  def lparen(); end

  def lparen_loc(); end

  def rparen(); end

  def rparen_loc(); end

  def save_keyword_loc(repository); end

  def save_lparen_loc(repository); end

  def save_rparen_loc(repository); end
end

class Prism::YieldNode
end

module Prism
  def self.dump(*arg); end

  def self.dump_file(*arg); end

  def self.lex(*arg); end

  def self.lex_compat(source, **options); end

  def self.lex_file(*arg); end

  def self.lex_ripper(source); end

  def self.load(source, serialized, freeze=T.unsafe(nil)); end

  def self.parse(*arg); end

  def self.parse_comments(*arg); end

  def self.parse_failure?(*arg); end

  def self.parse_file(*arg); end

  def self.parse_file_comments(*arg); end

  def self.parse_file_failure?(*arg); end

  def self.parse_file_success?(*arg); end

  def self.parse_lex(*arg); end

  def self.parse_lex_file(*arg); end

  def self.parse_stream(*arg); end

  def self.parse_success?(*arg); end

  def self.profile(*arg); end

  def self.profile_file(*arg); end

  def self.scope(locals: T.unsafe(nil), forwarding: T.unsafe(nil)); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

module Process
  CLOCK_TAI = ::T.let(nil, ::T.untyped)
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::FFI::ModernForkTracking
  def self.exit(*arg); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar_component(); end

  def bar_component=(bar_component); end

  def clear(*args, **arg, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, **arg, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage_component(); end

  def percentage_component=(percentage_component); end

  def progress(*args, **arg, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def projector(); end

  def projector=(projector); end

  def rate_component(); end

  def rate_component=(rate_component); end

  def refresh(*args, **arg, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time_component(); end

  def time_component=(time_component); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_component(); end

  def title_component=(title_component); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, **arg, &block); end

  def total=(new_total); end

  def update_progress(*args); end
  RUNNING_AVERAGE_RATE_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  SMOOTHING_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def bar(length); end

  def bar_with_percentage(length); end

  def complete_bar(length); end

  def complete_bar_with_percentage(length); end

  def incomplete_space(length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def justified_percentage(); end

  def justified_percentage_with_precision(); end

  def percentage(); end

  def percentage_with_precision(); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_of_change(format_string=T.unsafe(nil)); end

  def rate_of_change_with_precision(); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_wall_clock(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(out_of_bounds_time_format=T.unsafe(nil)); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def projector(); end

  def projector=(projector); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  WALL_CLOCK_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*arg); end

  def resolve_format(*arg); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

class ProgressBar::Projector
  NAME_TO_PROJECTOR_MAP = ::T.let(nil, ::T.untyped)
end

ProgressBar::Projector::DEFAULT_PROJECTOR = ProgressBar::Projectors::SmoothedAverage

class ProgressBar::Projector
  def self.from_type(name); end
end

module ProgressBar::Projectors
end

class ProgressBar::Projectors::SmoothedAverage
  def decrement(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def progress(); end

  def progress=(new_progress); end

  def projection(); end

  def projection=(projection); end

  def reset(); end

  def samples(); end

  def samples=(samples); end

  def start(options=T.unsafe(nil)); end

  def strength(); end

  def strength=(strength); end

  def total=(_new_total); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRENGTH = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projectors::SmoothedAverage
  def self.calculate(current_projection, new_value, rate); end
end

module ProgressBar::Projectors
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
  ARITY_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def now(); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  LOADER_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::AliasesNotEnabled
  def initialize(); end
end

class Psych::AliasesNotEnabled
end

class Psych::AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::AnchorNotDefined
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(); end

  def self.domain_types=(value); end

  def self.dump_tags(); end

  def self.dump_tags=(value); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(value); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module RBS
  VERSION = ::T.let(nil, ::T.untyped)
end

module RBS::AST
end

class RBS::AST::Annotation
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Annotation
end

class RBS::AST::Comment
  def ==(other); end

  def eql?(other); end

  def initialize(string:, location:); end

  def location(); end

  def string(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Comment
end

module RBS::AST::Declarations
end

class RBS::AST::Declarations::AliasDecl
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(new_name:, old_name:, location:, comment:, annotations: T.unsafe(nil)); end

  def location(); end

  def new_name(); end

  def old_name(); end
end

class RBS::AST::Declarations::AliasDecl
end

class RBS::AST::Declarations::Base
end

class RBS::AST::Declarations::Base
end

class RBS::AST::Declarations::Class
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, super_class:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def super_class(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), super_class: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Class::Super
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Class::Super
end

class RBS::AST::Declarations::Class
end

class RBS::AST::Declarations::ClassAlias
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::ClassAlias
end

class RBS::AST::Declarations::Constant
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:, annotations: T.unsafe(nil)); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Constant
end

class RBS::AST::Declarations::Global
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type:, location:, comment:, annotations: T.unsafe(nil)); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::AST::Declarations::Global
end

class RBS::AST::Declarations::Interface
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Interface
end

module RBS::AST::Declarations::MixinHelper
  def each_mixin(&block); end
end

module RBS::AST::Declarations::MixinHelper
end

class RBS::AST::Declarations::Module
  include ::RBS::AST::Declarations::NestedDeclarationHelper
  include ::RBS::AST::Declarations::MixinHelper
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, members:, self_types:, annotations:, location:, comment:); end

  def location(); end

  def members(); end

  def name(); end

  def self_types(); end

  def to_json(state=T.unsafe(nil)); end

  def type_params(); end

  def update(name: T.unsafe(nil), type_params: T.unsafe(nil), members: T.unsafe(nil), self_types: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil)); end
end

class RBS::AST::Declarations::Module::Self
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, location:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::Module::Self
end

class RBS::AST::Declarations::Module
end

class RBS::AST::Declarations::ModuleAlias
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Declarations::ModuleAlias
end

module RBS::AST::Declarations::NestedDeclarationHelper
  def each_decl(); end

  def each_member(); end
end

module RBS::AST::Declarations::NestedDeclarationHelper
end

class RBS::AST::Declarations::TypeAlias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, type_params:, type:, annotations:, location:, comment:); end

  def location(); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_params(); end
end

class RBS::AST::Declarations::TypeAlias
end

module RBS::AST::Declarations
end

module RBS::AST::Directives
end

class RBS::AST::Directives::Base
end

class RBS::AST::Directives::Base
end

class RBS::AST::Directives::ResolveTypeNames
  def initialize(value:, location:); end

  def location(); end

  def value(); end
end

class RBS::AST::Directives::ResolveTypeNames
end

class RBS::AST::Directives::Use
  def clauses(); end

  def initialize(clauses:, location:); end

  def location(); end
end

class RBS::AST::Directives::Use::SingleClause
  def initialize(type_name:, new_name:, location:); end

  def location(); end

  def new_name(); end

  def type_name(); end
end

class RBS::AST::Directives::Use::SingleClause
end

class RBS::AST::Directives::Use::WildcardClause
  def initialize(namespace:, location:); end

  def location(); end

  def namespace(); end
end

class RBS::AST::Directives::Use::WildcardClause
end

class RBS::AST::Directives::Use
end

module RBS::AST::Directives
end

module RBS::AST::Members
end

class RBS::AST::Members::Alias
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(new_name:, old_name:, kind:, annotations:, location:, comment:); end

  def instance?(); end

  def kind(); end

  def location(); end

  def new_name(); end

  def old_name(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Alias
end

class RBS::AST::Members::AttrAccessor
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrAccessor
end

class RBS::AST::Members::AttrReader
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrReader
end

class RBS::AST::Members::AttrWriter
  include ::RBS::AST::Members::Attribute
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::AttrWriter
end

module RBS::AST::Members::Attribute
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, ivar_name:, kind:, annotations:, location:, comment:, visibility: T.unsafe(nil)); end

  def ivar_name(); end

  def kind(); end

  def location(); end

  def name(); end

  def type(); end

  def update(name: T.unsafe(nil), type: T.unsafe(nil), ivar_name: T.unsafe(nil), kind: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

module RBS::AST::Members::Attribute
end

class RBS::AST::Members::Base
end

class RBS::AST::Members::Base
end

class RBS::AST::Members::ClassInstanceVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::ClassInstanceVariable
end

class RBS::AST::Members::ClassVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::ClassVariable
end

class RBS::AST::Members::Extend
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Extend
end

class RBS::AST::Members::Include
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Include
end

class RBS::AST::Members::InstanceVariable
  include ::RBS::AST::Members::Var
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::InstanceVariable
end

module RBS::AST::Members::LocationOnly
  def ==(other); end

  def eql?(other); end

  def hash(); end

  def initialize(location:); end

  def location(); end
end

module RBS::AST::Members::LocationOnly
end

class RBS::AST::Members::MethodDefinition
  def ==(other); end

  def annotations(); end

  def comment(); end

  def eql?(other); end

  def initialize(name:, kind:, overloads:, annotations:, location:, comment:, overloading:, visibility:); end

  def instance?(); end

  def kind(); end

  def location(); end

  def name(); end

  def overloading(); end

  def overloading?(); end

  def overloads(); end

  def singleton?(); end

  def to_json(state=T.unsafe(nil)); end

  def update(name: T.unsafe(nil), kind: T.unsafe(nil), overloads: T.unsafe(nil), annotations: T.unsafe(nil), location: T.unsafe(nil), comment: T.unsafe(nil), overloading: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

class RBS::AST::Members::MethodDefinition::Overload
  def ==(other); end

  def annotations(); end

  def eql?(other); end

  def initialize(method_type:, annotations:); end

  def method_type(); end

  def sub(subst); end

  def to_json(state=T.unsafe(nil)); end

  def update(annotations: T.unsafe(nil), method_type: T.unsafe(nil)); end
end

class RBS::AST::Members::MethodDefinition::Overload
end

class RBS::AST::Members::MethodDefinition
end

module RBS::AST::Members::Mixin
  def ==(other); end

  def annotations(); end

  def args(); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, args:, annotations:, location:, comment:); end

  def location(); end

  def name(); end
end

module RBS::AST::Members::Mixin
end

class RBS::AST::Members::Prepend
  include ::RBS::AST::Members::Mixin
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Prepend
end

class RBS::AST::Members::Private
  include ::RBS::AST::Members::LocationOnly
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Private
end

class RBS::AST::Members::Public
  include ::RBS::AST::Members::LocationOnly
  def to_json(state=T.unsafe(nil)); end
end

class RBS::AST::Members::Public
end

module RBS::AST::Members::Var
  def ==(other); end

  def comment(); end

  def eql?(other); end

  def hash(); end

  def initialize(name:, type:, location:, comment:); end

  def location(); end

  def name(); end

  def type(); end
end

module RBS::AST::Members::Var
end

module RBS::AST::Members
end

class RBS::AST::TypeParam
  def ==(other); end

  def default_type(); end

  def eql?(other); end

  def initialize(name:, variance:, upper_bound:, location:, default_type: T.unsafe(nil), unchecked: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def unchecked!(value=T.unsafe(nil)); end

  def unchecked?(); end

  def upper_bound(); end

  def upper_bound_type(); end

  def variance(); end
end

class RBS::AST::TypeParam
  def self.application(params, args); end

  def self.normalize_args(params, args); end

  def self.rename(params, new_names:); end

  def self.resolve_variables(params); end

  def self.subst_var(vars, type); end

  def self.validate(type_params); end
end

class RBS::AST::Visitor
  def visit(node); end

  def visit_all(nodes); end

  def visit_declaration_class(node); end

  def visit_declaration_constant(node); end

  def visit_declaration_global(node); end

  def visit_declaration_interface(node); end

  def visit_declaration_module(node); end

  def visit_declaration_type_alias(node); end

  def visit_member_alias(node); end

  def visit_member_attr_accessor(node); end

  def visit_member_attr_reader(node); end

  def visit_member_attr_writer(node); end

  def visit_member_class_instance_variable(node); end

  def visit_member_class_variable(node); end

  def visit_member_extend(node); end

  def visit_member_include(node); end

  def visit_member_instance_variable(node); end

  def visit_member_method_definition(node); end

  def visit_member_prepend(node); end

  def visit_member_private(node); end

  def visit_member_public(node); end
end

class RBS::AST::Visitor
end

module RBS::AST
end

class RBS::AncestorGraph
  def ancestor_builder(); end

  def build(); end

  def build_ancestors(node, ancestors); end

  def children(); end

  def each_ancestor(node, yielded: T.unsafe(nil), &block); end

  def each_child(node, &block); end

  def each_descendant(node, yielded: T.unsafe(nil), &block); end

  def each_parent(node, &block); end

  def env(); end

  def initialize(env:, ancestor_builder: T.unsafe(nil)); end

  def parents(); end

  def register(parent:, child:); end
end

class RBS::AncestorGraph::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::AncestorGraph::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::AncestorGraph::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::AncestorGraph
end

class RBS::BaseError
end

class RBS::BaseError
end

class RBS::Buffer
  def content(); end

  def initialize(name:, content:); end

  def last_position(); end

  def lines(); end

  def loc_to_pos(loc); end

  def name(); end

  def pos_to_loc(pos); end

  def ranges(); end
end

class RBS::Buffer
end

module RBS::BuiltinNames
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  Comparable = ::T.let(nil, ::T.untyped)
  Enumerable = ::T.let(nil, ::T.untyped)
  Enumerator = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Kernel = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  Numeric = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  Set = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class RBS::BuiltinNames::Name
  def initialize(name:); end

  def instance_type(*args); end

  def instance_type?(type); end

  def name(); end

  def singleton_type(); end

  def singleton_type?(type); end
end

class RBS::BuiltinNames::Name
  def self.define(name, namespace: T.unsafe(nil)); end
end

module RBS::BuiltinNames
end

class RBS::CLI
end

class RBS::CLI::ColoredIO
  def initialize(stdout:); end

  def puts(*arg, **arg1, &arg2); end

  def puts_green(string); end

  def puts_red(string); end

  def stdout(); end
end

class RBS::CLI::ColoredIO
end

class RBS::CLI
end

class RBS::ClassInstanceVariableDuplicationError
  def kind(); end
end

class RBS::ClassInstanceVariableDuplicationError
end

module RBS::Collection
end

class RBS::Collection::Cleaner
  def clean(); end

  def initialize(lockfile_path:); end

  def lock(); end

  def needed?(gem_name, version); end
end

class RBS::Collection::Cleaner
end

class RBS::Collection::Config
  def config_path(); end

  def data(); end

  def gem(gem_name); end

  def gems(); end

  def initialize(data, config_path:); end

  def repo_path(); end

  def repo_path_data(); end

  def sources(); end
  PATH = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config::CollectionNotAvailable
  def initialize(); end
end

class RBS::Collection::Config::CollectionNotAvailable
end

class RBS::Collection::Config::Lockfile
  def check_rbs_availability!(); end

  def fullpath(); end

  def gemfile_lock_fullpath(); end

  def gemfile_lock_path(); end

  def gems(); end

  def initialize(lockfile_path:, path:, gemfile_lock_path:); end

  def library_data(lib); end

  def lockfile_dir(); end

  def lockfile_path(); end

  def path(); end

  def sources(); end

  def to_lockfile(); end
end

class RBS::Collection::Config::Lockfile
  def self.from_lockfile(lockfile_path:, data:); end
end

class RBS::Collection::Config::LockfileGenerator
  def config(); end

  def definition(); end

  def existing_lockfile(); end

  def gem_entries(); end

  def gem_hash(); end

  def generate(); end

  def initialize(config:, definition:, with_lockfile:); end

  def lockfile(); end
  ALUMNI_STDLIBS = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError
  def initialize(expected:, actual:); end
end

class RBS::Collection::Config::LockfileGenerator::GemfileLockMismatchError
end

class RBS::Collection::Config::LockfileGenerator
  def self.generate(config:, definition:, with_lockfile: T.unsafe(nil)); end
end

class RBS::Collection::Config
  def self.find_config_path(); end

  def self.from_path(path); end

  def self.generate_lockfile(config_path:, definition:, with_lockfile: T.unsafe(nil)); end

  def self.to_lockfile_path(config_path); end
end

class RBS::Collection::Installer
  def initialize(lockfile_path:, stdout: T.unsafe(nil)); end

  def install_from_lockfile(); end

  def lockfile(); end

  def stdout(); end
end

class RBS::Collection::Installer
end

module RBS::Collection::Sources
end

module RBS::Collection::Sources::Base
  def dependencies_of(name, version); end
end

module RBS::Collection::Sources::Base
end

class RBS::Collection::Sources::Git
  include ::RBS::Collection::Sources::Base
  def has?(name, version); end

  def initialize(name:, revision:, remote:, repo_dir:); end

  def install(dest:, name:, version:, stdout:); end

  def load_metadata(dir:); end

  def manifest_of(name, version); end

  def metadata_content(name:, version:); end

  def name(); end

  def remote(); end

  def repo_dir(); end

  def resolved_revision(); end

  def revision(); end

  def to_lockfile(); end

  def versions(name); end

  def write_metadata(dir:, name:, version:); end
  METADATA_FILENAME = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Git::CommandError
end

class RBS::Collection::Sources::Git::CommandError
end

class RBS::Collection::Sources::Git
end

class RBS::Collection::Sources::Local
  include ::RBS::Collection::Sources::Base
  def full_path(); end

  def has?(name, version); end

  def initialize(path:, base_directory:); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def path(); end

  def to_lockfile(); end

  def versions(name); end
end

class RBS::Collection::Sources::Local
end

class RBS::Collection::Sources::Rubygems
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
  def has?(name, version); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def to_lockfile(); end

  def versions(name); end
end

class RBS::Collection::Sources::Rubygems
  extend ::Singleton::SingletonClassMethods
end

class RBS::Collection::Sources::Stdlib
  include ::RBS::Collection::Sources::Base
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
  def has?(name, version); end

  def install(dest:, name:, version:, stdout:); end

  def manifest_of(name, version); end

  def to_lockfile(); end

  def versions(name); end
  REPO = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Stdlib
  extend ::Singleton::SingletonClassMethods
end

module RBS::Collection::Sources
  def self.from_config_entry(source_entry, base_directory:); end
end

module RBS::Collection
end

class RBS::Constant
  def ==(other); end

  def entry(); end

  def eql?(other); end

  def initialize(name:, type:, entry:); end

  def name(); end

  def type(); end
end

class RBS::Constant
end

class RBS::CyclicClassAliasDefinitionError
  include ::RBS::DetailedMessageable
  def alias_entry(); end

  def initialize(entry); end

  def location(); end
end

class RBS::CyclicClassAliasDefinitionError
end

class RBS::CyclicTypeParameterBound
  include ::RBS::DetailedMessageable
  def initialize(type_name:, method_name:, params:, location:); end

  def location(); end

  def method_name(); end

  def params(); end

  def type_name(); end
end

class RBS::CyclicTypeParameterBound
end

class RBS::Definition
  def ancestors(); end

  def class?(); end

  def class_type?(); end

  def class_variables(); end

  def each_type(&block); end

  def entry(); end

  def initialize(type_name:, entry:, self_type:, ancestors:); end

  def instance_type?(); end

  def interface?(); end

  def interface_type?(); end

  def map_method_type(&block); end

  def methods(); end

  def module?(); end

  def self_type(); end

  def sub(s); end

  def type_name(); end

  def type_params(); end

  def type_params_decl(); end
end

module RBS::Definition::Ancestor
end

class RBS::Definition::Ancestor::Instance
  def ==(other); end

  def args(); end

  def eql?(other); end

  def initialize(name:, args:, source:); end

  def name(); end

  def source(); end
end

class RBS::Definition::Ancestor::Instance
end

class RBS::Definition::Ancestor::Singleton
  def ==(other); end

  def eql?(other); end

  def initialize(name:); end

  def name(); end
end

class RBS::Definition::Ancestor::Singleton
end

module RBS::Definition::Ancestor
end

class RBS::Definition::InstanceAncestors
  def ancestors(); end

  def apply(args, env:, location:); end

  def initialize(type_name:, params:, ancestors:); end

  def params(); end

  def type_name(); end
end

class RBS::Definition::InstanceAncestors
end

class RBS::Definition::Method
  def ==(other); end

  def accessibility(); end

  def alias_member(); end

  def alias_of(); end

  def annotations(); end

  def comments(); end

  def defined_in(); end

  def defs(); end

  def eql?(other); end

  def extra_annotations(); end

  def implemented_in(); end

  def initialize(super_method:, defs:, accessibility:, alias_of:, annotations: T.unsafe(nil), alias_member: T.unsafe(nil)); end

  def map_method_type(&block); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def members(); end

  def method_types(); end

  def private?(); end

  def public?(); end

  def sub(s); end

  def super_method(); end

  def update(super_method: T.unsafe(nil), defs: T.unsafe(nil), accessibility: T.unsafe(nil), alias_of: T.unsafe(nil), annotations: T.unsafe(nil), alias_member: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
  def ==(other); end

  def annotations(); end

  def comment(); end

  def defined_in(); end

  def each_annotation(&block); end

  def eql?(other); end

  def implemented_in(); end

  def initialize(type:, member:, defined_in:, implemented_in:, overload_annotations: T.unsafe(nil)); end

  def member(); end

  def member_annotations(); end

  def overload?(); end

  def overload_annotations(); end

  def type(); end

  def update(type: T.unsafe(nil), member: T.unsafe(nil), defined_in: T.unsafe(nil), implemented_in: T.unsafe(nil)); end
end

class RBS::Definition::Method::TypeDef
end

class RBS::Definition::Method
end

class RBS::Definition::SingletonAncestors
  def ancestors(); end

  def initialize(type_name:, ancestors:); end

  def type_name(); end
end

class RBS::Definition::SingletonAncestors
end

class RBS::Definition::Variable
  def declared_in(); end

  def initialize(parent_variable:, type:, declared_in:, source:); end

  def parent_variable(); end

  def source(); end

  def sub(s); end

  def type(); end
end

class RBS::Definition::Variable
end

class RBS::Definition
end

class RBS::DefinitionBuilder
  def ancestor_builder(); end

  def build_instance(type_name); end

  def build_interface(type_name); end

  def build_singleton(type_name); end

  def build_singleton0(type_name); end

  def define_instance(definition, type_name, subst, define_class_vars:); end

  def define_interface(definition, type_name, subst); end

  def define_method(methods, definition, method, subst, self_type_methods, defined_in:, implemented_in: T.unsafe(nil)); end

  def ensure_namespace!(namespace, location:); end

  def env(); end

  def expand_alias(type_name); end

  def expand_alias1(type_name); end

  def expand_alias2(type_name, args); end

  def import_methods(definition, module_name, module_methods, interfaces_methods, subst, self_type_methods); end

  def initialize(env:, ancestor_builder: T.unsafe(nil), method_builder: T.unsafe(nil)); end

  def insert_variable(type_name, variables, name:, type:, source:); end

  def instance_cache(); end

  def interface_cache(); end

  def interface_methods(interface_ancestors); end

  def method_builder(); end

  def singleton0_cache(); end

  def singleton_cache(); end

  def source_location(source, decl); end

  def tapp_subst(name, args); end

  def try_cache(type_name, cache:); end

  def update(env:, except:, ancestor_builder:); end

  def validate_params_with(type_params, result:); end

  def validate_type_name(name, location); end

  def validate_type_params(definition, ancestors:, methods:); end

  def validate_type_presence(type); end

  def validate_variable(var); end
end

class RBS::DefinitionBuilder::AncestorBuilder
  def env(); end

  def fill_ancestor_source(ancestor, name:, source:, &block); end

  def initialize(env:); end

  def instance_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def instance_ancestors_cache(); end

  def interface_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def interface_ancestors_cache(); end

  def mixin_ancestors(entry, type_name, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def mixin_ancestors0(decl, type_name, align_params:, included_modules:, included_interfaces:, extended_modules:, prepended_modules:, extended_interfaces:); end

  def one_instance_ancestors(type_name); end

  def one_instance_ancestors_cache(); end

  def one_interface_ancestors(type_name); end

  def one_interface_ancestors_cache(); end

  def one_singleton_ancestors(type_name); end

  def one_singleton_ancestors_cache(); end

  def singleton_ancestors(type_name, building_ancestors: T.unsafe(nil)); end

  def singleton_ancestors_cache(); end

  def validate_super_class!(type_name, entry); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def each_ancestor(&block); end

  def each_extended_interface(&block); end

  def each_extended_module(&block); end

  def each_included_interface(&block); end

  def each_included_module(&block); end

  def each_prepended_module(&block); end

  def each_self_type(&block); end

  def extended_interfaces(); end

  def extended_modules(); end

  def included_interfaces(); end

  def included_modules(); end

  def initialize(type_name:, params:, super_class:, self_types:, included_modules:, included_interfaces:, prepended_modules:, extended_modules:, extended_interfaces:); end

  def params(); end

  def prepended_modules(); end

  def self_types(); end

  def super_class(); end

  def type_name(); end
end

class RBS::DefinitionBuilder::AncestorBuilder::OneAncestors
  def self.class_instance(type_name:, params:, super_class:); end

  def self.interface(type_name:, params:); end

  def self.module_instance(type_name:, params:); end

  def self.singleton(type_name:, super_class:); end
end

class RBS::DefinitionBuilder::AncestorBuilder
end

class RBS::DefinitionBuilder::MethodBuilder
  def build_alias(methods, type, member:); end

  def build_attribute(methods, type, member:, accessibility:); end

  def build_instance(type_name); end

  def build_interface(type_name); end

  def build_method(methods, type, member:, accessibility:); end

  def build_singleton(type_name); end

  def each_member_with_accessibility(members, accessibility: T.unsafe(nil)); end

  def env(); end

  def initialize(env:); end

  def instance_methods(); end

  def interface_methods(); end

  def singleton_methods(); end

  def update(env:, except:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
  def each(&blk); end

  def initialize(type:); end

  def methods(); end

  def type(); end

  def validate!(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def accessibility(); end

  def original(); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Definition
  def self.empty(name:, type:); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
  include ::TSort
  def initialize(methods); end

  def methods(); end

  def tsort_each_child(defn); end

  def tsort_each_node(&block); end
end

class RBS::DefinitionBuilder::MethodBuilder::Methods::Sorter
end

class RBS::DefinitionBuilder::MethodBuilder::Methods
end

class RBS::DefinitionBuilder::MethodBuilder
end

class RBS::DefinitionBuilder
end

class RBS::DefinitionError
end

class RBS::DefinitionError
end

module RBS::DetailedMessageable
  def detailed_message(highlight: T.unsafe(nil), **arg); end
end

module RBS::DetailedMessageable
end

class RBS::Diff
  def each_diff(&block); end

  def initialize(type_name:, library_options:, after_path: T.unsafe(nil), before_path: T.unsafe(nil), detail: T.unsafe(nil)); end
end

class RBS::Diff
end

class RBS::DuplicatedDeclarationError
  def decls(); end

  def initialize(name, *decls); end

  def name(); end
end

class RBS::DuplicatedDeclarationError
end

class RBS::DuplicatedInterfaceMethodDefinitionError
  include ::RBS::DetailedMessageable
  def initialize(type:, method_name:, member:); end

  def location(); end

  def member(); end

  def method_name(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::DuplicatedInterfaceMethodDefinitionError
end

class RBS::DuplicatedMethodDefinitionError
  include ::RBS::DetailedMessageable
  def initialize(type:, method_name:, members:); end

  def location(); end

  def members(); end

  def method_name(); end

  def other_locations(); end

  def qualified_method_name(); end

  def type(); end

  def type_name(); end
end

class RBS::DuplicatedMethodDefinitionError
end

class RBS::Environment
  def <<(decl); end

  def absolute_type(resolver, map, type, context:); end

  def absolute_type_name(resolver, map, type_name, context:); end

  def add_signature(buffer:, directives:, decls:); end

  def append_context(context, decl); end

  def buffers(); end

  def class_alias?(name); end

  def class_alias_decls(); end

  def class_decl?(name); end

  def class_decls(); end

  def class_entry(type_name, normalized: T.unsafe(nil)); end

  def constant_decl?(name); end

  def constant_decls(); end

  def constant_entry(type_name, normalized: T.unsafe(nil)); end

  def constant_name?(name); end

  def declarations(); end

  def global_decls(); end

  def insert_decl(decl, outer:, namespace:); end

  def interface_decls(); end

  def interface_name?(name); end

  def module_alias?(name); end

  def module_class_entry(type_name, normalized: T.unsafe(nil)); end

  def module_decl?(name); end

  def module_entry(type_name, normalized: T.unsafe(nil)); end

  def module_name?(name); end

  def normalize_module_name(name); end

  def normalize_module_name!(name); end

  def normalize_module_name?(name); end

  def normalize_type_name(name); end

  def normalize_type_name!(name); end

  def normalize_type_name?(name); end

  def normalized_class_entry(type_name); end

  def normalized_module_class_entry(type_name); end

  def normalized_module_entry(type_name); end

  def normalized_type_name!(name); end

  def normalized_type_name?(type_name); end

  def resolve_declaration(resolver, map, decl, outer:, prefix:); end

  def resolve_member(resolver, map, member, context:); end

  def resolve_method_type(resolver, map, type, context:); end

  def resolve_signature(resolver, table, dirs, decls, only: T.unsafe(nil)); end

  def resolve_type_names(only: T.unsafe(nil)); end

  def resolve_type_params(resolver, map, params, context:); end

  def resolver_context(*nesting); end

  def signatures(); end

  def type_alias_decls(); end

  def type_alias_name?(name); end

  def type_name?(name); end

  def unload(buffers); end

  def validate_type_params(); end
end

class RBS::Environment::ClassAliasEntry
end

class RBS::Environment::ClassAliasEntry
end

class RBS::Environment::ClassEntry
end

class RBS::Environment::ClassEntry
end

class RBS::Environment::ConstantEntry
end

class RBS::Environment::ConstantEntry
end

module RBS::Environment::ContextUtil
  def calculate_context(decls); end
end

module RBS::Environment::ContextUtil
end

class RBS::Environment::GlobalEntry
end

class RBS::Environment::GlobalEntry
end

class RBS::Environment::InterfaceEntry
end

class RBS::Environment::InterfaceEntry
end

class RBS::Environment::ModuleAliasEntry
end

class RBS::Environment::ModuleAliasEntry
end

class RBS::Environment::ModuleEntry
  def self_types(); end
end

class RBS::Environment::ModuleEntry
end

class RBS::Environment::MultiEntry
  def compatible_params?(ps1, ps2); end

  def decls(); end

  def initialize(name:); end

  def insert(decl:, outer:); end

  def name(); end

  def primary(); end

  def type_params(); end

  def validate_type_params(); end
end

class RBS::Environment::MultiEntry::D
  include ::RBS::Environment::ContextUtil
  def context(); end

  def decl(); end

  def decl=(_); end

  def outer(); end

  def outer=(_); end
end

class RBS::Environment::MultiEntry::D
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Environment::MultiEntry
end

class RBS::Environment::SingleEntry
  include ::RBS::Environment::ContextUtil
  def context(); end

  def decl(); end

  def initialize(name:, decl:, outer:); end

  def name(); end

  def outer(); end
end

class RBS::Environment::SingleEntry
end

class RBS::Environment::TypeAliasEntry
end

class RBS::Environment::TypeAliasEntry
end

class RBS::Environment::UseMap
  def build_map(clause); end

  def initialize(table:); end

  def resolve(type_name); end

  def resolve?(type_name); end

  def use_dirs(); end
end

class RBS::Environment::UseMap::Table
  def children(); end

  def compute_children(); end

  def known_types(); end
end

class RBS::Environment::UseMap::Table
end

class RBS::Environment::UseMap
end

class RBS::Environment
  def self.from_loader(loader); end
end

class RBS::EnvironmentLoader
  include ::RBS::FileFinder
  def add(path: T.unsafe(nil), library: T.unsafe(nil), version: T.unsafe(nil), resolve_dependencies: T.unsafe(nil)); end

  def add_collection(lockfile); end

  def core_root(); end

  def dirs(); end

  def each_dir(); end

  def each_signature(); end

  def has_library?(library:, version:); end

  def initialize(core_root: T.unsafe(nil), repository: T.unsafe(nil)); end

  def libs(); end

  def load(env:); end

  def repository(); end

  def resolve_dependencies(library:, version:); end
  DEFAULT_CORE_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::EnvironmentLoader::Library
end

class RBS::EnvironmentLoader::Library
end

class RBS::EnvironmentLoader::UnknownLibraryError
  def initialize(lib:); end

  def library(); end
end

class RBS::EnvironmentLoader::UnknownLibraryError
end

class RBS::EnvironmentLoader
  def self.gem_sig_path(name, version); end
end

class RBS::EnvironmentWalker
  include ::TSort
  def builder(); end

  def each_type_name(type, &block); end

  def each_type_node(type, &block); end

  def env(); end

  def initialize(env:); end

  def only_ancestors!(only=T.unsafe(nil)); end

  def only_ancestors?(); end

  def tsort_each_child(node, &block); end

  def tsort_each_node(&block); end
end

class RBS::EnvironmentWalker::InstanceNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::InstanceNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::SingletonNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::SingletonNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def type_name(); end

  def type_name=(_); end
end

class RBS::EnvironmentWalker::TypeNameNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::EnvironmentWalker
end

class RBS::Factory
  def type_name(string); end
end

class RBS::Factory
end

module RBS::FileFinder
end

module RBS::FileFinder
  def self.each_file(path, skip_hidden:, immediate: T.unsafe(nil), &block); end
end

class RBS::GenericParameterMismatchError
  def decl(); end

  def initialize(name:, decl:); end

  def name(); end
end

class RBS::GenericParameterMismatchError
end

class RBS::InconsistentClassModuleAliasError
  include ::RBS::DetailedMessageable
  def alias_entry(); end

  def initialize(entry); end

  def location(); end
end

class RBS::InconsistentClassModuleAliasError
end

class RBS::InheritModuleError
  include ::RBS::DetailedMessageable
  def initialize(super_decl); end

  def location(); end

  def super_decl(); end
end

class RBS::InheritModuleError
  def self.check!(super_decl, env:); end
end

class RBS::InstanceVariableDuplicationError
  def kind(); end
end

class RBS::InstanceVariableDuplicationError
end

class RBS::InvalidOverloadMethodError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, method_name:, kind:, members:); end

  def kind(); end

  def location(); end

  def members(); end

  def method_name(); end

  def type_name(); end
end

class RBS::InvalidOverloadMethodError
end

class RBS::InvalidTypeApplicationError
  def args(); end

  def initialize(type_name:, args:, params:, location:); end

  def location(); end

  def params(); end

  def type_name(); end

  def type_params(); end
end

class RBS::InvalidTypeApplicationError
  def self.check!(type_name:, args:, params:, location:); end

  def self.check2!(env:, type_name:, args:, location:); end
end

class RBS::InvalidVarianceAnnotationError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, param:, location:); end

  def location(); end

  def param(); end

  def type_name(); end
end

class RBS::InvalidVarianceAnnotationError
end

class RBS::LoadingError
end

class RBS::LoadingError
end

class RBS::Location
  def ==(other); end

  def [](arg); end

  def _add_optional_child(arg, arg1, arg2); end

  def _add_optional_no_child(arg); end

  def _add_required_child(arg, arg1, arg2); end

  def _optional_keys(); end

  def _required_keys(); end

  def add_optional_child(name, range); end

  def add_required_child(name, range); end

  def aref(arg); end

  def buffer(); end

  def each_optional_key(&block); end

  def each_required_key(&block); end

  def end_column(); end

  def end_line(); end

  def end_loc(); end

  def end_pos(); end

  def initialize(arg, arg1, arg2); end

  def key?(name); end

  def name(); end

  def optional_key?(name); end

  def range(); end

  def required_key?(name); end

  def source(); end

  def start_column(); end

  def start_line(); end

  def start_loc(); end

  def start_pos(); end

  def to_json(state=T.unsafe(nil)); end
end

RBS::Location::WithChildren = RBS::Location

class RBS::Location
  def self.new(buffer_=T.unsafe(nil), start_pos_=T.unsafe(nil), end_pos_=T.unsafe(nil), buffer: T.unsafe(nil), start_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def self.to_string(location, default: T.unsafe(nil)); end
end

class RBS::Locator
  def buffer(); end

  def decls(); end

  def dirs(); end

  def find(line:, column:); end

  def find2(line:, column:); end

  def find_in_decl(pos, decl:, array:); end

  def find_in_directive(pos, dir, array); end

  def find_in_loc(pos, location:, array:); end

  def find_in_member(pos, member:, array:); end

  def find_in_method_type(pos, method_type:, array:); end

  def find_in_type(pos, type:, array:); end

  def find_in_type_param(pos, type_param:, array:); end

  def initialize(buffer:, dirs:, decls:); end

  def test_loc(pos, location:); end
end

class RBS::Locator
end

module RBS::MethodNameHelper
  def method_name_string(); end
end

module RBS::MethodNameHelper
end

class RBS::MethodType
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(type_params:, type:, block:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_bound(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end

  def type_param_names(); end

  def type_params(); end

  def update(type_params: T.unsafe(nil), type: T.unsafe(nil), block: T.unsafe(nil), location: T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::MethodType
end

class RBS::MixinClassError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::MixinClassError
  def self.check!(type_name:, env:, member:); end
end

class RBS::Namespace
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def append(component); end

  def ascend(); end

  def empty?(); end

  def eql?(other); end

  def initialize(path:, absolute:); end

  def parent(); end

  def path(); end

  def relative!(); end

  def relative?(); end

  def split(); end

  def to_type_name(); end
end

class RBS::Namespace
  def self.empty(); end

  def self.parse(string); end

  def self.root(); end
end

class RBS::NoMixinFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, member:); end

  def location(); end

  def member(); end

  def type_name(); end
end

class RBS::NoMixinFoundError
  def self.check!(type_name, env:, member:); end
end

class RBS::NoSelfTypeFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSelfTypeFoundError
  def self.check!(self_type, env:); end
end

class RBS::NoSuperclassFoundError
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoSuperclassFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NoTypeFoundError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, location:); end

  def location(); end

  def type_name(); end
end

class RBS::NoTypeFoundError
  def self.check!(type_name, env:, location:); end
end

class RBS::NonregularTypeAliasError
  include ::RBS::DetailedMessageable
  def diagnostic(); end

  def initialize(diagnostic:, location:); end

  def location(); end
end

class RBS::NonregularTypeAliasError
end

class RBS::Parser
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class RBS::Parser::LexResult
  def buffer(); end

  def initialize(buffer:, value:); end

  def value(); end
end

class RBS::Parser::LexResult
end

class RBS::Parser::Token
  def comment?(); end

  def initialize(type:, location:); end

  def location(); end

  def type(); end

  def value(); end
end

class RBS::Parser::Token
end

class RBS::Parser
  def self._lex(arg, arg1); end

  def self._parse_method_type(arg, arg1, arg2, arg3, arg4); end

  def self._parse_signature(arg, arg1, arg2); end

  def self._parse_type(arg, arg1, arg2, arg3, arg4); end

  def self._parse_type_params(arg, arg1, arg2, arg3); end

  def self.buffer(source); end

  def self.lex(source); end

  def self.magic_comment(buf); end

  def self.parse_method_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end

  def self.parse_signature(source); end

  def self.parse_type(source, range: T.unsafe(nil), variables: T.unsafe(nil), require_eof: T.unsafe(nil)); end

  def self.parse_type_params(source, module_type_params: T.unsafe(nil)); end
end

class RBS::ParsingError
  include ::RBS::DetailedMessageable
  def error_message(); end

  def initialize(location, error_message, token_type); end

  def location(); end

  def token_type(); end
end

class RBS::ParsingError
end

module RBS::Prototype
end

module RBS::Prototype::Helpers
end

module RBS::Prototype::Helpers
end

class RBS::Prototype::NodeUsage
  include ::RBS::Prototype::Helpers
  def calculate(node, conditional:); end

  def conditional_nodes(); end

  def each_conditional_node(&block); end

  def initialize(node); end
end

class RBS::Prototype::NodeUsage
end

class RBS::Prototype::RB
  include ::RBS::Prototype::Helpers
  def block_type(node); end

  def body_type(node); end

  def const_to_name(node, context:); end

  def const_to_name!(node, context: T.unsafe(nil)); end

  def current_accessibility(decls, index=T.unsafe(nil)); end

  def decls(); end

  def find_def_index_by_name(decls, name); end

  def function_return_type_from_body(node); end

  def function_type_from_body(node, def_name); end

  def if_unless_type(node); end

  def is_accessibility?(decl); end

  def literal_to_symbol(node); end

  def literal_to_type(node); end

  def node_type(node, default: T.unsafe(nil)); end

  def param_type(node, default: T.unsafe(nil)); end

  def parse(string); end

  def private(); end

  def process(node, decls:, comments:, context:); end

  def process_children(node, decls:, comments:, context:); end

  def public(); end

  def range_element_type(types); end

  def remove_unnecessary_accessibility_methods!(decls); end

  def sort_members!(decls); end

  def source_decls(); end

  def toplevel_members(); end

  def types_to_union_type(types); end
end

class RBS::Prototype::RB::Context
  def attribute_kind(); end

  def enter_namespace(namespace); end

  def method_kind(); end

  def update(module_function: T.unsafe(nil), singleton: T.unsafe(nil), in_def: T.unsafe(nil)); end
end

class RBS::Prototype::RB::Context
  def self.initial(namespace: T.unsafe(nil)); end
end

class RBS::Prototype::RB
end

class RBS::Prototype::RBI
  include ::RBS::Prototype::Helpers
  def call_node?(node, name:, receiver: T.unsafe(nil), args: T.unsafe(nil)); end

  def const_to_name(node); end

  def current_module(); end

  def current_module!(); end

  def current_namespace(); end

  def decls(); end

  def each_arg(array, &block); end

  def each_child(node); end

  def join_comments(nodes, comments); end

  def last_sig(); end

  def method_type(args_node, type_node, variables:, overloads:); end

  def modules(); end

  def nested_name(name); end

  def node_to_hash(node); end

  def parse(string); end

  def parse_params(args_node, args, method_type, variables:, overloads:); end

  def pop_sig(); end

  def proc_type?(type_node); end

  def process(node, comments:, outer: T.unsafe(nil)); end

  def push_class(name, super_class, comment:); end

  def push_module(name, comment:); end

  def push_sig(node); end

  def type_of(type_node, variables:); end

  def type_of0(type_node, variables:); end
end

class RBS::Prototype::RBI
end

class RBS::Prototype::Runtime
  include ::RBS::Prototype::Helpers
  include ::RBS::Prototype::Runtime::Helpers
  def block_from_ast_of(method); end

  def builder(); end

  def decls(); end

  def ensure_outer_module_declarations(mod); end

  def env(); end

  def generate_class(mod); end

  def generate_constants(mod, decls); end

  def generate_methods(mod, module_name, members); end

  def generate_mixin(mod, decl, type_name, type_name_absolute); end

  def generate_module(mod); end

  def generate_super_class(mod); end

  def initialize(patterns:, env:, merge:, todo: T.unsafe(nil), owners_included: T.unsafe(nil)); end

  def merge(); end

  def merge_rbs(module_name, members, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def method_type(method); end

  def outline(); end

  def outline=(outline); end

  def owners_included(); end

  def parse(file); end

  def patterns(); end

  def target?(const); end

  def target_method?(mod, instance: T.unsafe(nil), singleton: T.unsafe(nil)); end

  def todo(); end

  def todo_object(); end

  def type_args(type_name); end

  def type_params(mod); end
end

class RBS::Prototype::Runtime::DataGenerator
end

class RBS::Prototype::Runtime::DataGenerator
  def self.generatable?(target); end
end

module RBS::Prototype::Runtime::Helpers
end

module RBS::Prototype::Runtime::Helpers
end

module RBS::Prototype::Runtime::Reflection
end

module RBS::Prototype::Runtime::Reflection
  def self.constants_of(mod, inherit=T.unsafe(nil)); end

  def self.object_class(value); end
end

class RBS::Prototype::Runtime::StructGenerator
  CAN_CALL_KEYWORD_INIT_P = ::T.let(nil, ::T.untyped)
end

class RBS::Prototype::Runtime::StructGenerator
  def self.generatable?(target); end
end

class RBS::Prototype::Runtime::ValueObjectBase
  include ::RBS::Prototype::Runtime::Helpers
  def build_decl(); end

  def initialize(target_class); end
end

class RBS::Prototype::Runtime::ValueObjectBase
end

class RBS::Prototype::Runtime
end

module RBS::Prototype
end

class RBS::RecursiveAliasDefinitionError
  include ::RBS::DetailedMessageable
  def defs(); end

  def initialize(type:, defs:); end

  def location(); end

  def type(); end
end

class RBS::RecursiveAliasDefinitionError
end

class RBS::RecursiveAncestorError
  def ancestors(); end

  def initialize(ancestors:, location:); end

  def location(); end
end

class RBS::RecursiveAncestorError
  def self.check!(self_ancestor, ancestors:, location:); end
end

class RBS::RecursiveTypeAliasError
  include ::RBS::DetailedMessageable
  def alias_names(); end

  def initialize(alias_names:, location:); end

  def location(); end

  def name(); end
end

class RBS::RecursiveTypeAliasError
end

class RBS::Repository
  def add(dir); end

  def dirs(); end

  def gems(); end

  def initialize(no_stdlib: T.unsafe(nil)); end

  def lookup(gem, version); end

  def lookup_path(gem, version); end
  DEFAULT_STDLIB_ROOT = ::T.let(nil, ::T.untyped)
end

class RBS::Repository::GemRBS
  def empty?(); end

  def find_best_version(version); end

  def initialize(name:); end

  def latest_version(); end

  def load!(); end

  def name(); end

  def oldest_version(); end

  def paths(); end

  def version_names(); end

  def versions(); end
end

class RBS::Repository::GemRBS
end

class RBS::Repository::VersionPath
  def gem(); end

  def gem=(_); end

  def path(); end

  def path=(_); end

  def version(); end

  def version=(_); end
end

class RBS::Repository::VersionPath
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RBS::Repository
  def self.default(); end

  def self.find_best_version(version, candidates); end
end

module RBS::Resolver
end

class RBS::Resolver::ConstantResolver
  def builder(); end

  def child_constants_cache(); end

  def children(module_name); end

  def constants(context); end

  def constants_from_ancestors(module_name, constants:); end

  def constants_from_context(context, constants:); end

  def constants_itself(context, constants:); end

  def context_constants_cache(); end

  def initialize(builder:); end

  def load_child_constants(name); end

  def load_context_constants(context); end

  def resolve(name, context:); end

  def resolve_child(module_name, name); end

  def table(); end
end

class RBS::Resolver::ConstantResolver::Table
  def children(name); end

  def children_table(); end

  def constant(name); end

  def constant_of_constant(name, entry); end

  def constant_of_module(name, entry); end

  def constants_table(); end

  def initialize(environment); end

  def toplevel(); end
end

class RBS::Resolver::ConstantResolver::Table
end

class RBS::Resolver::ConstantResolver
end

class RBS::Resolver::TypeNameResolver
  def aliased_name?(type_name); end

  def aliases(); end

  def all_names(); end

  def cache(); end

  def has_type_name?(full_name); end

  def initialize(all_names, aliases); end

  def normalize_namespace(type_name, rhs, context, visited); end

  def resolve(type_name, context:); end

  def resolve_head_namespace(head, context); end

  def resolve_namespace(type_name, context:); end

  def resolve_namespace0(type_name, context, visited); end

  def resolve_type_name(type_name, context); end

  def try_cache(query); end
end

class RBS::Resolver::TypeNameResolver
  def self.build(env); end

  def self.new(*args); end
end

module RBS::Resolver
end

class RBS::Substitution
  def +(other); end

  def [](ty); end

  def add(from:, to:); end

  def apply(ty); end

  def empty?(); end

  def instance_type(); end

  def instance_type=(instance_type); end

  def mapping(); end

  def without(*vars); end
end

class RBS::Substitution
  def self.build(variables, types, instance_type: T.unsafe(nil), &block); end
end

class RBS::Subtractor
  def call(minuend=T.unsafe(nil), context: T.unsafe(nil)); end

  def initialize(minuend, subtrahend); end
end

class RBS::Subtractor
end

class RBS::SuperclassMismatchError
  def entry(); end

  def initialize(name:, entry:); end

  def name(); end
end

class RBS::SuperclassMismatchError
end

class RBS::TypeAliasDependency
  def build_dependencies(); end

  def circular_definition?(alias_name); end

  def dependencies(); end

  def dependencies_of(name); end

  def direct_dependencies(); end

  def direct_dependencies_of(name); end

  def env(); end

  def initialize(env:); end

  def transitive_closure(); end
end

class RBS::TypeAliasDependency
end

class RBS::TypeAliasRegularity
  def build_alias_type(name); end

  def builder(); end

  def compatible_args?(args1, args2); end

  def diagnostics(); end

  def each_alias_type(type, &block); end

  def each_mutual_alias_defs(&block); end

  def env(); end

  def initialize(env:); end

  def nonregular?(type_name); end

  def validate(); end

  def validate_alias_type(alias_type, names, types); end
end

class RBS::TypeAliasRegularity::Diagnostic
  def initialize(type_name:, nonregular_type:); end

  def nonregular_type(); end

  def type_name(); end
end

class RBS::TypeAliasRegularity::Diagnostic
end

class RBS::TypeAliasRegularity
  def self.validate(env:); end
end

class RBS::TypeName
  def +(other); end

  def ==(other); end

  def absolute!(); end

  def absolute?(); end

  def alias?(); end

  def class?(); end

  def eql?(other); end

  def initialize(namespace:, name:); end

  def interface?(); end

  def kind(); end

  def name(); end

  def namespace(); end

  def relative!(); end

  def split(); end

  def to_json(state=T.unsafe(nil)); end

  def to_namespace(); end

  def with_prefix(namespace); end
end

class RBS::TypeName
  def self.parse(string); end
end

class RBS::TypeParamDefaultReferenceError
  include ::RBS::DetailedMessageable
  def initialize(type_param, location:); end

  def location(); end

  def type_param(); end
end

class RBS::TypeParamDefaultReferenceError
  def self.check!(type_params); end
end

module RBS::Types
end

class RBS::Types::Alias
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::Alias
end

module RBS::Types::Application
  def ==(other); end

  def args(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def hash(); end

  def name(); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

module RBS::Types::Application
end

module RBS::Types::Bases
end

class RBS::Types::Bases::Any
  def initialize(location:, todo: T.unsafe(nil)); end
end

class RBS::Types::Bases::Any
end

class RBS::Types::Bases::Base
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Bases::Base
end

class RBS::Types::Bases::Bool
end

class RBS::Types::Bases::Bool
end

class RBS::Types::Bases::Bottom
end

class RBS::Types::Bases::Bottom
end

class RBS::Types::Bases::Class
end

class RBS::Types::Bases::Class
end

class RBS::Types::Bases::Instance
end

class RBS::Types::Bases::Instance
end

class RBS::Types::Bases::Nil
end

class RBS::Types::Bases::Nil
end

class RBS::Types::Bases::Self
end

class RBS::Types::Bases::Self
end

class RBS::Types::Bases::Top
end

class RBS::Types::Bases::Top
end

class RBS::Types::Bases::Void
end

class RBS::Types::Bases::Void
end

module RBS::Types::Bases
end

class RBS::Types::Block
  def ==(other); end

  def initialize(type:, required:, location: T.unsafe(nil), self_type: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def required(); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Block
end

class RBS::Types::ClassInstance
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::ClassInstance
end

class RBS::Types::ClassSingleton
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(name:, location:); end

  def location(); end

  def map_type_name(&arg); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::ClassSingleton
end

module RBS::Types::EmptyEachType
  def each_type(); end

  def map_type(&block); end
end

module RBS::Types::EmptyEachType
end

class RBS::Types::Function
  def ==(other); end

  def amap(array, &block); end

  def drop_head(); end

  def drop_tail(); end

  def each_param(&block); end

  def each_type(); end

  def empty?(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_keyword?(); end

  def has_self_type?(); end

  def hmapv(hash, &block); end

  def initialize(required_positionals:, optional_positionals:, rest_positionals:, trailing_positionals:, required_keywords:, optional_keywords:, rest_keywords:, return_type:); end

  def map_type(&block); end

  def map_type_name(&block); end

  def optional_keywords(); end

  def optional_positionals(); end

  def param_to_s(); end

  def required_keywords(); end

  def required_positionals(); end

  def rest_keywords(); end

  def rest_positionals(); end

  def return_to_s(); end

  def return_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def trailing_positionals(); end

  def update(required_positionals: T.unsafe(nil), optional_positionals: T.unsafe(nil), rest_positionals: T.unsafe(nil), trailing_positionals: T.unsafe(nil), required_keywords: T.unsafe(nil), optional_keywords: T.unsafe(nil), rest_keywords: T.unsafe(nil), return_type: T.unsafe(nil)); end

  def with_nonreturn_void?(); end

  def with_return_type(type); end
end

class RBS::Types::Function::Param
  def ==(other); end

  def eql?(other); end

  def initialize(type:, name:, location: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def name(); end

  def to_json(state=T.unsafe(nil)); end

  def type(); end
end

class RBS::Types::Function::Param
end

class RBS::Types::Function
  def self.empty(return_type); end
end

class RBS::Types::Interface
  include ::RBS::Types::Application
  def initialize(name:, args:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end
end

class RBS::Types::Interface
end

class RBS::Types::Intersection
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Intersection
end

class RBS::Types::Literal
  include ::RBS::Types::NoFreeVariables
  include ::RBS::Types::NoSubst
  include ::RBS::Types::EmptyEachType
  include ::RBS::Types::NoTypeName
  def ==(other); end

  def eql?(other); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(literal:, location:); end

  def literal(); end

  def location(); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
  TABLE = ::T.let(nil, ::T.untyped)
end

class RBS::Types::Literal
  def self.unescape_string(string, is_double_quote); end
end

module RBS::Types::NoFreeVariables
  def free_variables(set=T.unsafe(nil)); end
end

module RBS::Types::NoFreeVariables
end

module RBS::Types::NoSubst
  def sub(s); end
end

module RBS::Types::NoSubst
end

module RBS::Types::NoTypeName
  def map_type_name(&arg); end
end

module RBS::Types::NoTypeName
end

class RBS::Types::Optional
  def ==(other); end

  def each_type(); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(type:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Optional
end

class RBS::Types::Proc
  def ==(other); end

  def block(); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:, type:, block:, self_type: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def self_type(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def type(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Proc
end

class RBS::Types::Record
  def ==(other); end

  def all_fields(); end

  def each_type(&block); end

  def eql?(other); end

  def fields(); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(location:, all_fields: T.unsafe(nil), fields: T.unsafe(nil)); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def optional_fields(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Record
end

module RBS::Types::SelfTypeBindingHelper
end

module RBS::Types::SelfTypeBindingHelper
  def self.self_type_binding_to_s(t); end
end

class RBS::Types::Tuple
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Tuple
end

class RBS::Types::Union
  def ==(other); end

  def each_type(&block); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(types:, location:); end

  def location(); end

  def map_type(&block); end

  def map_type_name(&block); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def types(); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Union
end

class RBS::Types::UntypedFunction
  def ==(other); end

  def each_param(&block); end

  def each_type(&block); end

  def empty?(); end

  def eql?(other); end

  def free_variables(acc=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(return_type:); end

  def map_type(&block); end

  def map_type_name(&block); end

  def param_to_s(); end

  def return_to_s(); end

  def return_type(); end

  def sub(subst); end

  def to_json(state=T.unsafe(nil)); end

  def update(return_type: T.unsafe(nil)); end

  def with_nonreturn_void?(); end

  def with_return_type(ty); end
end

class RBS::Types::UntypedFunction
end

class RBS::Types::Variable
  include ::RBS::Types::NoTypeName
  include ::RBS::Types::EmptyEachType
  def ==(other); end

  def eql?(other); end

  def free_variables(set=T.unsafe(nil)); end

  def has_classish_type?(); end

  def has_self_type?(); end

  def initialize(name:, location:); end

  def location(); end

  def name(); end

  def sub(s); end

  def to_json(state=T.unsafe(nil)); end

  def to_s(level=T.unsafe(nil)); end

  def with_nonreturn_void?(); end
end

class RBS::Types::Variable
  def self.build(v); end

  def self.fresh(v=T.unsafe(nil)); end
end

module RBS::Types
end

class RBS::UnknownMethodAliasError
  include ::RBS::DetailedMessageable
  def aliased_name(); end

  def initialize(type_name:, original_name:, aliased_name:, location:); end

  def location(); end

  def original_name(); end

  def type_name(); end
end

class RBS::UnknownMethodAliasError
end

class RBS::Validator
  def absolute_type(type, context:, &block); end

  def definition_builder(); end

  def env(); end

  def initialize(env:, resolver: T.unsafe(nil)); end

  def resolver(); end

  def type_alias_dependency(); end

  def type_alias_regularity(); end

  def validate_class_alias(entry:); end

  def validate_method_definition(method_def, type_name:); end

  def validate_type(type, context:); end

  def validate_type_alias(entry:); end

  def validate_type_params(params, type_name:, location:, method_name: T.unsafe(nil)); end

  def validate_variable(var); end
end

class RBS::Validator
end

class RBS::VariableDuplicationError
  include ::RBS::DetailedMessageable
  def initialize(type_name:, variable_name:, location:); end

  def location(); end

  def type_name(); end

  def variable_name(); end
end

class RBS::VariableDuplicationError
end

class RBS::VarianceCalculator
  def builder(); end

  def env(); end

  def function(type, result:, context:); end

  def in_inherit(name:, args:, variables:); end

  def in_method_type(method_type:, variables:); end

  def in_type_alias(name:); end

  def initialize(builder:); end

  def negate(variance); end

  def type(type, result:, context:); end
end

class RBS::VarianceCalculator::Result
  def compatible?(var, with_annotation:); end

  def contravariant(x); end

  def covariant(x); end

  def each(&block); end

  def include?(name); end

  def incompatible?(params); end

  def initialize(variables:); end

  def invariant(x); end

  def result(); end
end

class RBS::VarianceCalculator::Result
end

class RBS::VarianceCalculator
end

class RBS::Vendorer
  def clean!(); end

  def copy!(); end

  def ensure_dir(); end

  def initialize(vendor_dir:, loader:); end

  def loader(); end

  def vendor_dir(); end
end

class RBS::Vendorer
end

class RBS::WillSyntaxError
  include ::RBS::DetailedMessageable
  def initialize(message, location:); end

  def location(); end
end

class RBS::WillSyntaxError
end

class RBS::Writer
  def attribute(kind, attr); end

  def format_annotation(annotation); end

  def indent(size=T.unsafe(nil)); end

  def indentation(); end

  def initialize(out:); end

  def method_name(name); end

  def name_and_args(name, args); end

  def name_and_params(name, params); end

  def out(); end

  def prefix(); end

  def preserve!(preserve: T.unsafe(nil)); end

  def preserve?(); end

  def preserve_empty_line(prev, decl); end

  def put_lines(lines, leading_spaces:); end

  def puts(string=T.unsafe(nil)); end

  def write(contents); end

  def write_annotation(annotations); end

  def write_comment(comment); end

  def write_decl(decl); end

  def write_def(member); end

  def write_loc_source(located); end

  def write_member(member); end

  def write_use_directive(dir); end
end

class RBS::Writer
end

module RBS
  def self.logger(); end

  def self.logger_level(); end

  def self.logger_level=(level); end

  def self.logger_output(); end

  def self.logger_output=(val); end

  def self.print_warning(); end
end

module RDoc::Text
  def language(); end

  def language=(language); end
  SPACE_SEPARATED_LETTER_CLASS = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

module RSpec::Core::Bisect
end

class RSpec::Core::Bisect::BisectFailedError
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
  MARSHAL_DUMP_ENCODING = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Bisect::Channel
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Bisect::Notifier
end

module RSpec::Core::Bisect
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_exit_code=(error_exit_code); end

  def error_exit_code?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_cause_backtrace=(full_cause_backtrace); end

  def full_cause_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def pending_failure_output=(mode); end

  def pending_failure_output?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples(); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_exit_code(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def full_cause_backtrace(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def pending_failure_output(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_alias(name, alias_name); end

  def self.define_predicate(name); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ==(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def eql?(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def ruby2_keywords(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.descendants(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*arg); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util
  include ::ERB::Escape
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(group_notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct_keys(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*arg); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*arg); end

  def self.from_hash(data); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*arg); end

  def self.for(example); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Delayed
  def initialize(registry, name); end

  def order(list); end
end

class RSpec::Core::Ordering::Delayed
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::RecentlyModified
  def order(list); end
end

class RSpec::Core::Ordering::RecentlyModified
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def has_strategy?(name); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def method_missing(name, *args, &block); end

  def nread(*args, &block); end

  def output(); end

  def output=(output); end

  def path(*args, &block); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def set_encoding_by_bom(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def timeout(*args, &block); end

  def timeout=(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def to_path(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_priority(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil), &_block); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(notification); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def exit_code(examples_passed=T.unsafe(nil)); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(in: T.unsafe(nil)); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def rspec_is_quitting(); end

  def rspec_is_quitting=(rspec_is_quitting); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(&_block); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def initialize(*arg); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def strict_predicate_matchers(); end

  def strict_predicate_matchers=(value); end

  def strict_predicate_matchers?(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
  AGGREGATED_FAILURE = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator::AggregatedFailure
  MESSAGE = ::T.let(nil, ::T.untyped)
end

class RSpec::Expectations::FailureAggregator::AggregatedFailure
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

class RSpec::Expectations::ValueExpectationTarget
end

class RSpec::Expectations::ValueExpectationTarget
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, **arg, &block); end

  def a_block_outputting(*args, **arg, &block); end

  def a_block_raising(*args, **arg, &block); end

  def a_block_throwing(*args, **arg, &block); end

  def a_block_yielding_control(*args, **arg, &block); end

  def a_block_yielding_successive_args(*args, **arg, &block); end

  def a_block_yielding_with_args(*args, **arg, &block); end

  def a_block_yielding_with_no_args(*args, **arg, &block); end

  def a_collection_containing_exactly(*args, **arg, &block); end

  def a_collection_ending_with(*args, **arg, &block); end

  def a_collection_including(*args, **arg, &block); end

  def a_collection_starting_with(*args, **arg, &block); end

  def a_falsey_value(*args, **arg, &block); end

  def a_falsy_value(*args, **arg, &block); end

  def a_hash_including(*args, **arg, &block); end

  def a_kind_of(*args, **arg, &block); end

  def a_nil_value(*args, **arg, &block); end

  def a_range_covering(*args, **arg, &block); end

  def a_string_ending_with(*args, **arg, &block); end

  def a_string_including(*args, **arg, &block); end

  def a_string_matching(*args, **arg, &block); end

  def a_string_starting_with(*args, **arg, &block); end

  def a_truthy_value(*args, **arg, &block); end

  def a_value(*args, **arg, &block); end

  def a_value_between(*args, **arg, &block); end

  def a_value_within(*args, **arg, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_array_matching(*args, **arg, &block); end

  def an_instance_of(*args, **arg, &block); end

  def an_object_eq_to(*args, **arg, &block); end

  def an_object_eql_to(*args, **arg, &block); end

  def an_object_equal_to(*args, **arg, &block); end

  def an_object_existing(*args, **arg, &block); end

  def an_object_having_attributes(*args, **arg, &block); end

  def an_object_matching(*args, **arg, &block); end

  def an_object_responding_to(*args, **arg, &block); end

  def an_object_satisfying(*args, **arg, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, **arg, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, **arg, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, **arg, &block); end

  def cover(*values); end

  def covering(*args, **arg, &block); end

  def end_with(*expected); end

  def ending_with(*args, **arg, &block); end

  def eq(expected); end

  def eq_to(*args, **arg, &block); end

  def eql(expected); end

  def eql_to(*args, **arg, &block); end

  def equal(expected); end

  def equal_to(*args, **arg, &block); end

  def exist(*args); end

  def existing(*args, **arg, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, **arg, &block); end

  def include(*expected); end

  def including(*args, **arg, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, **arg, &block); end

  def matching(*args, **arg, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, **arg, &block); end

  def respond_to(*names); end

  def responding_to(*args, **arg, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, **arg, &block); end

  def start_with(*expected); end

  def starting_with(*args, **arg, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, **arg, &block); end

  def within(*args, **arg, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, **arg, &block); end

  def yielding_successive_args(*args, **arg, &block); end

  def yielding_with_args(*args, **arg, &block); end

  def yielding_with_no_args(*args, **arg, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*arg); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

class RSpec::Matchers::BaseDelegator
end

class RSpec::Matchers::BaseDelegator
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::StringEncodingFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def rescued_exception(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::StringEncodingFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::StringEncodingFormatting
  def self.format_encoding(value); end

  def self.string_encoding_differs?(); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual); end

  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

module RSpec::Matchers::BuiltIn::ChangeDetails::UNDEFINED
end

module RSpec::Matchers::BuiltIn::ChangeDetails::UNDEFINED
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *arg); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

module RSpec::Matchers::BuiltIn::CountExpectation
  def at_least(number); end

  def at_most(number); end

  def count_expectation_type(); end

  def exactly(number); end

  def expected_count(); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

module RSpec::Matchers::BuiltIn::CountExpectation
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, **arg, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message, expected_message, &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end

  def with_message(expected_message); end
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
  def initialize(expected_arity, expected_keywords, arbitrary_keywords, unlimited_arguments); end

  def matches?(actual, name); end

  def method_signature_for(actual, name); end

  def verifier_for(actual, name); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end

  def supports_value_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

class RSpec::Matchers::MultiMatcherDiff
  def initialize(expected_list); end

  def message_with_diff(message, differ); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::MultiMatcherDiff
  def self.for_many_matchers(matchers); end

  def self.from(expected, actual); end
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndInvokeImplementation
  def call(*args, **arg, &block); end

  def initialize(procs_to_invoke); end
end

class RSpec::Mocks::AndInvokeImplementation
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, **arg, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def present?(); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*actual_args, **arg); end

  def expected_args(); end

  def initialize(*expected_args, **arg); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_excluding(*args); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
  def ===(_other); end

  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
end

class RSpec::Mocks::ArgumentMatchers::ArrayExcludingMatcher
  def ===(actual); end

  def description(); end

  def initialize(unexpected); end
end

class RSpec::Mocks::ArgumentMatchers::ArrayExcludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
  def ===(actual); end

  def description(); end

  def initialize(expected); end
end

class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(predicate, actual); end

  def description(name); end

  def initialize(expected); end
end

class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
  def ===(value); end

  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
end

class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
  def ===(value); end

  def description(); end

  def initialize(*methods_to_respond_to); end
end

class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
end

class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
  def ===(actual); end

  def description(); end
end

class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
  def ===(actual); end

  def description(); end
end

class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::InstanceOf
  def ===(actual); end

  def description(); end

  def initialize(klass); end
end

class RSpec::Mocks::ArgumentMatchers::InstanceOf
end

class RSpec::Mocks::ArgumentMatchers::KindOf
  def ===(actual); end

  def description(); end

  def initialize(klass); end
end

class RSpec::Mocks::ArgumentMatchers::KindOf
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
end

class RSpec::Mocks::ArgumentMatchers::SingletonMatcher
end

class RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def self.inherited(subklass); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
  CLASS_NEW = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end

  def self.uses_class_new?(klass); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash, &_block); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, **arg, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def present?(); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, **arg, &block); end

  def and_invoke(*args, **arg, &block); end

  def and_raise(*args, **arg, &block); end

  def and_return(*args, **arg, &block); end

  def and_throw(*args, **arg, &block); end

  def and_wrap_original(*args, **arg, &block); end

  def and_yield(*args, **arg, &block); end

  def at_least(*args, **arg, &block); end

  def at_most(*args, **arg, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, **arg, &block); end

  def initialize(message, block); end

  def inspect(*args, **arg, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def never(*args, **arg, &block); end

  def once(*args, **arg, &block); end

  def ordered(*args, **arg, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, **arg, &block); end

  def time(*args, **arg, &block); end

  def times(*args, **arg, &block); end

  def to_s(*args, **arg, &block); end

  def twice(*args, **arg, &block); end

  def with(*args, **arg, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_invoke(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matcher_name(); end

  def matches?(subject, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matcher_name(); end

  def matches?(subject); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_invoke(first_proc, *procs, &_block); end

  def and_raise(*args); end

  def and_return(first_value, *values, &_block); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, **arg, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, **arg, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, **arg, &block); end

  def matches?(message, *args, **arg); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, **arg, &block); end

  def safe_invoke_without_incrementing_received_count(parent_stub, *args, **arg, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def message_expectation_class(); end

  def method_missing_block(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, **arg, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
  FROZEN_ERROR_MSG = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_can_be_proxied!(object); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, **arg, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, **arg, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, **arg, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, **arg, &block); end
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, **arg, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::HunkGenerator
  def hunks(); end

  def initialize(actual, expected); end
end

class RSpec::Support::HunkGenerator
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*arg); end

  def self.can_inspect?(_object); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.distincts_kw_args_from_positional_hash?(); end

  def self.fork_supported?(); end

  def self.kw_arg_separation?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_syntax_suggest?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support::WithKeywordsWhenNeeded
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, **arg, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.current_scope(); end

  def self.current_scope=(scope); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.[](sym); end

  def self.[]=(sym, val); end

  def self._require(feature); end

  def self.main?(); end

  def self.new(*args, name: T.unsafe(nil), &block); end

  def self.store_if_absent(sym); end
end

module RactorLocalSingleton
  extend ::Singleton::SingletonClassProperties
  def self.module_with_class_methods(); end
end

module Rainbow
end

class Rainbow::Color
  def ground(); end
end

class Rainbow::Color::Indexed
  def codes(); end

  def initialize(ground, num); end

  def num(); end
end

class Rainbow::Color::Indexed
end

class Rainbow::Color::Named
  def initialize(ground, name); end
  NAMES = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color::RGB
  def b(); end

  def g(); end

  def initialize(ground, *values); end

  def r(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::Color::X11Named
  include ::Rainbow::X11ColorNames
  def initialize(ground, name); end
end

class Rainbow::Color::X11Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color
  def self.build(ground, values); end

  def self.parse_hex_color(hex); end
end

class Rainbow::NullPresenter
  def background(*_values); end

  def bg(*_values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*_values); end

  def cross_out(); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*_values); end

  def foreground(*_values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def strike(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

class Rainbow::NullPresenter
end

class Rainbow::Presenter
  def background(*values); end

  def bg(*values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*values); end

  def cross_out(); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*values); end

  def foreground(*values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def strike(); end

  def underline(); end

  def white(); end

  def yellow(); end
  TERM_EFFECTS = ::T.let(nil, ::T.untyped)
end

class Rainbow::Presenter
end

class Rainbow::StringUtils
end

class Rainbow::StringUtils
  def self.uncolor(string); end

  def self.wrap_with_sgr(string, codes); end
end

class Rainbow::Wrapper
  def enabled(); end

  def enabled=(enabled); end

  def initialize(enabled=T.unsafe(nil)); end

  def wrap(string); end
end

class Rainbow::Wrapper
end

module Rainbow::X11ColorNames
  NAMES = ::T.let(nil, ::T.untyped)
end

module Rainbow::X11ColorNames
end

module Rainbow
  def self.enabled(); end

  def self.enabled=(value); end

  def self.global(); end

  def self.new(); end

  def self.uncolor(string); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def intersect?(*args, &block); end

  def intersection(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def ln_sr(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
  include ::Singleton::SingletonInstanceMethods
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def deconstruct_keys(keys); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

module Random::Formatter
  def uuid_v4(); end

  def uuid_v7(extra_timestamp_bits: T.unsafe(nil)); end
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def reverse_each(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end
end

class Refinement
  def target(); end
end

class Regexp
  def timeout(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
end

Regexp::Expression::Backref = Regexp::Expression::Backreference

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
  def match_length(); end
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Base
  include ::Regexp::Expression::Shared
  include ::Regexp::Expression::ReferencedExpressions
  include ::RuboCop::Ext::RegexpParser::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def quantify(*args); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::Base
  extend ::Regexp::Expression::Shared::ClassMethods
end

class Regexp::Expression::CharacterSet
  include ::RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negative(); end

  def negative=(negative); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
end

Regexp::Expression::Escape = Regexp::Expression::EscapeSequence

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoint(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::UTF8Hex
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::UTF8Hex
end

class Regexp::Expression::EscapeSequence::VerticalTab
  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::FreeSpace
  def match_length(); end

  def quantify(*_args); end
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
  def implicit=(implicit); end

  def implicit?(); end

  def initialize(*arg); end
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Literal
  def match_length(); end
end

class Regexp::Expression::Literal
end

Regexp::Expression::MatchLength = Regexp::MatchLength

Regexp::Expression::Nonposixclass = Regexp::Expression::PosixClass

Regexp::Expression::Nonproperty = Regexp::Expression::UnicodeProperty

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end
end

class Regexp::Expression::PosixClass
end

Regexp::Expression::Posixclass = Regexp::Expression::PosixClass

Regexp::Expression::Property = Regexp::Expression::UnicodeProperty

class Regexp::Expression::Quantifier
  include ::Regexp::Expression::Shared
  include ::RuboCop::Ext::RegexpParser::Expression::Base
  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def custom_to_s_handling(); end

  def custom_to_s_handling=(custom_to_s_handling); end

  def greedy?(); end

  def initialize(*args); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def max(); end

  def min(); end

  def mode(); end

  def nesting_level(); end

  def options(); end

  def options=(options); end

  def parent(); end

  def parent=(parent); end

  def possessive?(); end

  def pre_quantifier_decorations(); end

  def pre_quantifier_decorations=(pre_quantifier_decorations); end

  def quantifier(); end

  def reluctant?(); end

  def set_level(); end

  def set_level=(set_level); end

  def te(); end

  def te=(te); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
  extend ::Regexp::Expression::Shared::ClassMethods
end

module Regexp::Expression::ReferencedExpressions
  def referenced_expression(); end

  def referenced_expressions(); end

  def referenced_expressions=(referenced_expressions); end
end

module Regexp::Expression::ReferencedExpressions
end

class Regexp::Expression::Root
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end
end

class Regexp::Expression::Sequence
  def quantify(token, *args); end
end

class Regexp::Expression::Sequence
  def self.add_to(exp, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil), params=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

Regexp::Expression::Set = Regexp::Expression::CharacterSet

module Regexp::Expression::Shared
  def ==(other); end

  def ===(other); end

  def base_length(); end

  def capturing?(); end

  def coded_offset(); end

  def comment?(); end

  def decorative?(); end

  def ends_at(include_quantifier=T.unsafe(nil)); end

  def eql?(other); end

  def full_length(); end

  def human_name(); end

  def inspect(); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def negated?(); end

  def negative?(); end

  def nesting_level=(lvl); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def optional?(); end

  def parts(); end

  def pre_quantifier_decoration(expression_format=T.unsafe(nil)); end

  def pretty_print(q); end

  def pretty_print_instance_variables(); end

  def quantified?(); end

  def quantifier=(qtf); end

  def quantifier_affix(expression_format=T.unsafe(nil)); end

  def referential?(); end

  def starts_at(); end

  def terminal?(); end

  def to_s(format=T.unsafe(nil)); end

  def to_str(format=T.unsafe(nil)); end

  def token_class(); end

  def type?(test_type); end
end

module Regexp::Expression::Shared::ClassMethods
  def capturing?(); end

  def comment?(); end

  def construct(params=T.unsafe(nil)); end

  def construct_defaults(); end

  def decorative?(); end

  def referential?(); end

  def terminal?(); end

  def token_class(); end
end

module Regexp::Expression::Shared::ClassMethods
end

module Regexp::Expression::Shared
  def self.included(mod); end
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def each_expression_with_index(&block); end

  def each_expression_without_index(&block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def extract_quantifier_target(quantifier_description); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Enumerated
end

class Regexp::Expression::UnicodeProperty::Enumerated
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
end

class Regexp::Lexer
  def emit(token); end

  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  CONDITION_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  include ::Enumerable
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  include ::Regexp::Expression
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::Error
end

class Regexp::Parser::Error
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

Regexp::Parser::UP = Regexp::Expression::UnicodeProperty

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def capturing_group_count(); end

  def capturing_group_count=(capturing_group_count); end

  def emit(type, token, text); end

  def literal_run(); end

  def literal_run=(literal_run); end

  def scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end
  POSIX_CLASSES = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownPosixClassError
  def initialize(text, _); end
end

class Regexp::Scanner::UnknownPosixClassError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name, _); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner::ValidationError
  def self.for(type, problem, reason=T.unsafe(nil)); end

  def self.types(); end
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.parse_prop_map(name); end

  def self.scan(input_object, options: T.unsafe(nil), collect_tokens: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
  def self.implements?(_type, _token); end
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def method_missing(name, *args); end
end

class Regexp::Syntax::Base
  def self.added_features(); end

  def self.check!(type, token); end

  def self.check?(type, token); end

  def self.excludes(type, tokens); end

  def self.features(); end

  def self.features=(features); end

  def self.implementations(type); end

  def self.implements(type, tokens); end

  def self.implements!(type, token); end

  def self.implements?(type, token); end

  def self.inherited(subclass); end

  def self.normalize(type, token); end

  def self.normalize_backref(type, token); end

  def self.normalize_group(type, token); end

  def self.removed_features(); end
end

Regexp::Syntax::CURRENT = Regexp::Syntax::V3_2_0

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Alternation
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Alternation
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
end

Regexp::Syntax::Token::Backref = Regexp::Syntax::Token::Backreference

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  NumberRef = ::T.let(nil, ::T.untyped)
  Plain = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V1_9_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
end

Regexp::Syntax::Token::EscapeSequence = Regexp::Syntax::Token::Escape

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Alternation = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
end

Regexp::Syntax::Token::Property = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
end

Regexp::Syntax::Token::Set = Regexp::Syntax::Token::CharacterSet

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  Age_V3_1_0 = ::T.let(nil, ::T.untyped)
  Age_V3_2_0 = ::T.let(nil, ::T.untyped)
  Age_V3_5_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived_V3_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji_V2_6_0 = ::T.let(nil, ::T.untyped)
  Enumerated = ::T.let(nil, ::T.untyped)
  Enumerated_V2_4_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Script_V3_1_0 = ::T.let(nil, ::T.untyped)
  Script_V3_2_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_1_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_5_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
  V3_1_0 = ::T.let(nil, ::T.untyped)
  V3_2_0 = ::T.let(nil, ::T.untyped)
  V3_5_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
end

module Regexp::Syntax::Token::UnicodeProperty
end

module Regexp::Syntax::Token
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V3_1_0
end

class Regexp::Syntax::V3_1_0
end

class Regexp::Syntax::V3_2_0
end

class Regexp::Syntax::V3_2_0
end

class Regexp::Syntax::V3_5_0
end

class Regexp::Syntax::V3_5_0
end

module Regexp::Syntax
  def self.comparable(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.for(name); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(arg); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Regexp
  def self.linear_time?(*arg); end
end

class Resolv
  VERSION = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end

  def use_ipv6?(); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_list(); end

  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CAA
  def critical?(); end

  def flags(); end

  def initialize(flags, tag, value); end

  def tag(); end

  def value(); end
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CAA
end

Resolv::DNS::Resource::IN::CAA = Resolv::DNS::Resource::Type257_Class1

class Resolv::DNS::Resource::IN::HTTPS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HTTPS
end

class Resolv::DNS::Resource::IN::SVCB
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SVCB
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def alias_mode?(); end

  def encode_rdata(msg); end

  def initialize(priority, target, params=T.unsafe(nil)); end

  def params(); end

  def priority(); end

  def service_mode?(); end

  def target(); end
end

class Resolv::DNS::Resource::IN::ServiceBinding
  def self.decode_rdata(msg); end
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

Resolv::DNS::Resource::Type11_Class1 = Resolv::DNS::Resource::IN::WKS

class Resolv::DNS::Resource::Type12_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type12_Class1
end

class Resolv::DNS::Resource::Type13_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type13_Class1
end

class Resolv::DNS::Resource::Type14_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type14_Class1
end

class Resolv::DNS::Resource::Type15_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type15_Class1
end

class Resolv::DNS::Resource::Type16_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type16_Class1
end

Resolv::DNS::Resource::Type1_Class1 = Resolv::DNS::Resource::IN::A

class Resolv::DNS::Resource::Type255_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type255_Class1
end

class Resolv::DNS::Resource::Type257_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type257_Class1
end

Resolv::DNS::Resource::Type28_Class1 = Resolv::DNS::Resource::IN::AAAA

class Resolv::DNS::Resource::Type29_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type29_Class1
end

class Resolv::DNS::Resource::Type2_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type2_Class1
end

Resolv::DNS::Resource::Type33_Class1 = Resolv::DNS::Resource::IN::SRV

class Resolv::DNS::Resource::Type5_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type5_Class1
end

Resolv::DNS::Resource::Type64_Class1 = Resolv::DNS::Resource::IN::SVCB

Resolv::DNS::Resource::Type65_Class1 = Resolv::DNS::Resource::IN::HTTPS

class Resolv::DNS::Resource::Type6_Class1
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Type6_Class1
end

class Resolv::DNS::SvcParam
  ClassHash = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def encode(msg); end

  def initialize(protocol_ids); end

  def protocol_ids(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::ALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::DoHPath
  def encode(msg); end

  def initialize(template); end

  def template(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::DoHPath
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Generic
  def encode(msg); end

  def initialize(value); end

  def value(); end
end

class Resolv::DNS::SvcParam::Generic
  def self.create(key_number); end

  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv4Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv4Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::IPv6Hint
  def addresses(); end

  def encode(msg); end

  def initialize(addresses); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::IPv6Hint
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Mandatory
  def encode(msg); end

  def initialize(keys); end

  def keys(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Mandatory
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def encode(msg); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::NoDefaultALPN
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam::Port
  def encode(msg); end

  def initialize(port); end

  def port(); end
  KeyName = ::T.let(nil, ::T.untyped)
  KeyNumber = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::SvcParam::Port
  def self.decode(msg); end
end

class Resolv::DNS::SvcParam
  def self.key_name(); end

  def self.key_number(); end
end

class Resolv::DNS::SvcParams
  include ::Enumerable
  def [](key); end

  def add(param); end

  def count(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def encode(msg); end

  def initialize(params=T.unsafe(nil)); end
end

class Resolv::DNS::SvcParams
  def self.decode(msg); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::IPv6
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndAsgnNode
end

class RuboCop::AST::AndAsgnNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgNode
  def default?(); end

  def default_value(); end

  def name(); end
end

class RuboCop::AST::ArgNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def argument_list(); end

  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
end

class RuboCop::AST::ArrayNode
end

class RuboCop::AST::AsgnNode
  def expression(); end

  def lhs(); end

  def name(); end

  def rhs(); end
end

class RuboCop::AST::AsgnNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_list(); end

  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def first_argument(); end

  def keywords?(); end

  def lambda?(); end

  def last_argument(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  include ::RuboCop::AST::BuilderExtensions
end

class RuboCop::AST::Builder
end

module RuboCop::AST::BuilderExtensions
  def n(type, children, source_map); end

  def string_value(token); end
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::BuilderExtensions
  def self.included(base); end
end

class RuboCop::AST::BuilderPrism
  include ::RuboCop::AST::BuilderExtensions
end

class RuboCop::AST::BuilderPrism
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def branches(); end

  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::CasgnNode
  include ::RuboCop::AST::ConstantNode
  def expression(); end

  def lhs(); end

  def name(); end

  def rhs(); end
end

class RuboCop::AST::CasgnNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*arg, **arg1, &arg2); end

  def *(*arg, **arg1, &arg2); end

  def +(*arg, **arg1, &arg2); end

  def -(*arg, **arg1, &arg2); end

  def <<(*arg, **arg1, &arg2); end

  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def all?(*arg, **arg1, &arg2); end

  def any?(*arg, **arg1, &arg2); end

  def append(*arg, **arg1, &arg2); end

  def assoc(*arg, **arg1, &arg2); end

  def at(*arg, **arg1, &arg2); end

  def bsearch(*arg, **arg1, &arg2); end

  def bsearch_index(*arg, **arg1, &arg2); end

  def chain(*arg, **arg1, &arg2); end

  def chunk(*arg, **arg1, &arg2); end

  def chunk_while(*arg, **arg1, &arg2); end

  def clear(*arg, **arg1, &arg2); end

  def collect(*arg, **arg1, &arg2); end

  def collect!(*arg, **arg1, &arg2); end

  def collect_concat(*arg, **arg1, &arg2); end

  def combination(*arg, **arg1, &arg2); end

  def compact(*arg, **arg1, &arg2); end

  def compact!(*arg, **arg1, &arg2); end

  def concat(*arg, **arg1, &arg2); end

  def count(*arg, **arg1, &arg2); end

  def cycle(*arg, **arg1, &arg2); end

  def deconstruct(*arg, **arg1, &arg2); end

  def delete(*arg, **arg1, &arg2); end

  def delete_at(*arg, **arg1, &arg2); end

  def delete_if(*arg, **arg1, &arg2); end

  def detect(*arg, **arg1, &arg2); end

  def difference(*arg, **arg1, &arg2); end

  def dig(*arg, **arg1, &arg2); end

  def drop(*arg, **arg1, &arg2); end

  def drop_while(*arg, **arg1, &arg2); end

  def each(*arg, **arg1, &arg2); end

  def each_cons(*arg, **arg1, &arg2); end

  def each_entry(*arg, **arg1, &arg2); end

  def each_index(*arg, **arg1, &arg2); end

  def each_slice(*arg, **arg1, &arg2); end

  def each_with_index(*arg, **arg1, &arg2); end

  def each_with_object(*arg, **arg1, &arg2); end

  def empty?(*arg, **arg1, &arg2); end

  def entries(*arg, **arg1, &arg2); end

  def fetch(*arg, **arg1, &arg2); end

  def fetch_values(*arg, **arg1, &arg2); end

  def fill(*arg, **arg1, &arg2); end

  def filter(*arg, **arg1, &arg2); end

  def filter!(*arg, **arg1, &arg2); end

  def filter_map(*arg, **arg1, &arg2); end

  def find(*arg, **arg1, &arg2); end

  def find_all(*arg, **arg1, &arg2); end

  def find_index(*arg, **arg1, &arg2); end

  def first(*arg, **arg1, &arg2); end

  def flat_map(*arg, **arg1, &arg2); end

  def flatten(*arg, **arg1, &arg2); end

  def flatten!(*arg, **arg1, &arg2); end

  def grep(*arg, **arg1, &arg2); end

  def grep_v(*arg, **arg1, &arg2); end

  def group_by(*arg, **arg1, &arg2); end

  def include?(*arg, **arg1, &arg2); end

  def index(*arg, **arg1, &arg2); end

  def inject(*arg, **arg1, &arg2); end

  def insert(*arg, **arg1, &arg2); end

  def intersect?(*arg, **arg1, &arg2); end

  def intersection(*arg, **arg1, &arg2); end

  def join(*arg, **arg1, &arg2); end

  def keep_if(*arg, **arg1, &arg2); end

  def last(*arg, **arg1, &arg2); end

  def lazy(*arg, **arg1, &arg2); end

  def length(*arg, **arg1, &arg2); end

  def map(*arg, **arg1, &arg2); end

  def map!(*arg, **arg1, &arg2); end

  def max(*arg, **arg1, &arg2); end

  def max_by(*arg, **arg1, &arg2); end

  def member?(*arg, **arg1, &arg2); end

  def min(*arg, **arg1, &arg2); end

  def min_by(*arg, **arg1, &arg2); end

  def minmax(*arg, **arg1, &arg2); end

  def minmax_by(*arg, **arg1, &arg2); end

  def none?(*arg, **arg1, &arg2); end

  def one?(*arg, **arg1, &arg2); end

  def pack(*arg, **arg1, &arg2); end

  def partition(*arg, **arg1, &arg2); end

  def permutation(*arg, **arg1, &arg2); end

  def pop(*arg, **arg1, &arg2); end

  def prepend(*arg, **arg1, &arg2); end

  def product(*arg, **arg1, &arg2); end

  def push(*arg, **arg1, &arg2); end

  def rassoc(*arg, **arg1, &arg2); end

  def reduce(*arg, **arg1, &arg2); end

  def reject(*arg, **arg1, &arg2); end

  def reject!(*arg, **arg1, &arg2); end

  def repeated_combination(*arg, **arg1, &arg2); end

  def repeated_permutation(*arg, **arg1, &arg2); end

  def replace(*arg, **arg1, &arg2); end

  def reverse(*arg, **arg1, &arg2); end

  def reverse!(*arg, **arg1, &arg2); end

  def reverse_each(*arg, **arg1, &arg2); end

  def rindex(*arg, **arg1, &arg2); end

  def rotate(*arg, **arg1, &arg2); end

  def rotate!(*arg, **arg1, &arg2); end

  def sample(*arg, **arg1, &arg2); end

  def select(*arg, **arg1, &arg2); end

  def select!(*arg, **arg1, &arg2); end

  def shelljoin(*arg, **arg1, &arg2); end

  def shift(*arg, **arg1, &arg2); end

  def shuffle(*arg, **arg1, &arg2); end

  def shuffle!(*arg, **arg1, &arg2); end

  def size(*arg, **arg1, &arg2); end

  def slice(*arg, **arg1, &arg2); end

  def slice!(*arg, **arg1, &arg2); end

  def slice_after(*arg, **arg1, &arg2); end

  def slice_before(*arg, **arg1, &arg2); end

  def slice_when(*arg, **arg1, &arg2); end

  def sort(*arg, **arg1, &arg2); end

  def sort!(*arg, **arg1, &arg2); end

  def sort_by(*arg, **arg1, &arg2); end

  def sort_by!(*arg, **arg1, &arg2); end

  def sum(*arg, **arg1, &arg2); end

  def take(*arg, **arg1, &arg2); end

  def take_while(*arg, **arg1, &arg2); end

  def tally(*arg, **arg1, &arg2); end

  def to_ary(*arg, **arg1, &arg2); end

  def to_h(*arg, **arg1, &arg2); end

  def to_set(*arg, **arg1, &arg2); end

  def transpose(*arg, **arg1, &arg2); end

  def union(*arg, **arg1, &arg2); end

  def uniq(*arg, **arg1, &arg2); end

  def uniq!(*arg, **arg1, &arg2); end

  def unshift(*arg, **arg1, &arg2); end

  def values_at(*arg, **arg1, &arg2); end

  def zip(*arg, **arg1, &arg2); end

  def |(*arg, **arg1, &arg2); end
end

module RuboCop::AST::CollectionNode
  extend ::RuboCop::SimpleForwardable
end

class RuboCop::AST::ComplexNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::ComplexNode
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::ConstNode
  include ::RuboCop::AST::ConstantNode
end

class RuboCop::AST::ConstNode
end

module RuboCop::AST::ConstantNode
  def absolute?(); end

  def class_name?(); end

  def each_path(&block); end

  def module_name?(); end

  def namespace(); end

  def relative?(); end

  def short_name(); end
end

module RuboCop::AST::ConstantNode
end

class RuboCop::AST::CsendNode
end

class RuboCop::AST::CsendNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def endless?(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::DefinedNode
end

module RuboCop::AST::Descendence
  def child_nodes(); end

  def descendants(); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def visit_descendants(types, &block); end
end

module RuboCop::AST::Descendence
end

class RuboCop::AST::DstrNode
end

class RuboCop::AST::DstrNode
end

class RuboCop::AST::EnsureNode
  def body(); end

  def branch(); end

  def rescue_node(); end

  def void_context?(); end
end

class RuboCop::AST::EnsureNode
end

module RuboCop::AST::Ext
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

module RuboCop::AST::Ext::Range
end

module RuboCop::AST::Ext
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def then?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::InPatternNode
  def body(); end

  def branch_index(); end

  def pattern(); end

  def then?(); end
end

class RuboCop::AST::InPatternNode
end

class RuboCop::AST::IndexNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexNode
end

class RuboCop::AST::IndexasgnNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordBeginNode
  def body(); end

  def ensure_node(); end

  def rescue_node(); end
end

class RuboCop::AST::KeywordBeginNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
end

class RuboCop::AST::KeywordSplatNode
end

class RuboCop::AST::LambdaNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::LambdaNode
end

class RuboCop::AST::MasgnNode
  def assignments(); end

  def expression(); end

  def lhs(); end

  def names(); end

  def rhs(); end

  def values(); end
end

class RuboCop::AST::MasgnNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(param0=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier(node=T.unsafe(nil)); end

  def def_modifier?(node=T.unsafe(nil)); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def in_macro_scope?(param0=T.unsafe(nil)); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def selector(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
end

module RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::MlhsNode
  def assignments(); end
end

class RuboCop::AST::MlhsNode
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::NextNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::NextNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  include ::RuboCop::AST::Descendence
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def any_block_type?(); end

  def any_def_type?(); end

  def any_match_pattern_type?(); end

  def any_str_type?(); end

  def any_sym_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(param0=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def class_constructor?(param0=T.unsafe(nil)); end

  def class_definition?(param0=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def forwarded_kwrestarg_type?(); end

  def forwarded_restarg_type?(); end

  def global_const?(param0=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def itarg_type?(); end

  def itblock_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwargs_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(param0=T.unsafe(nil)); end

  def lambda_or_proc?(param0=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def left_sibling(); end

  def left_siblings(); end

  def line_count(); end

  def literal?(); end

  def loc?(which_loc); end

  def loc_is?(which_loc, str); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(param0=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_pattern_p_type?(); end

  def match_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(param0=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(param0=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent?(); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(param0=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(param0=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def right_sibling(); end

  def right_siblings(); end

  def root?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(param0=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(param0=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def type?(*types); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::AST::NodePattern
  include ::RuboCop::AST::NodePattern::MethodDefiner
  def ==(other); end

  def as_json(_options=T.unsafe(nil)); end

  def ast(); end

  def captures(*arg, **arg1, &arg2); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def initialize(str, compiler: T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest, &block); end

  def match_code(); end

  def named_parameters(*arg, **arg1, &arg2); end

  def pattern(); end

  def positional_parameters(*arg, **arg1, &arg2); end
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Builder
  def emit_atom(type, value); end

  def emit_call(type, selector, args=T.unsafe(nil)); end

  def emit_capture(capture_token, node); end

  def emit_list(type, _begin, children, _end); end

  def emit_subsequence(node_list); end

  def emit_unary_op(type, _operator=T.unsafe(nil), *children); end

  def emit_union(begin_t, pattern_lists, end_t); end
end

class RuboCop::AST::NodePattern::Builder
end

class RuboCop::AST::NodePattern::Comment
  def ==(other); end

  def initialize(range); end

  def loc(); end

  def location(); end

  def text(); end
end

class RuboCop::AST::NodePattern::Comment
end

class RuboCop::AST::NodePattern::Compiler
  def bind(*arg, **arg1, &arg2); end

  def captures(); end

  def compile_as_atom(node); end

  def compile_as_node_pattern(node, **options); end

  def compile_sequence(sequence, var:); end

  def each_union(enum, &block); end

  def named_parameter(name); end

  def named_parameters(); end

  def next_capture(); end

  def parser(); end

  def positional_parameter(number); end

  def positional_parameters(); end

  def with_temp_variables(*names, &block); end
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Binding
  def bind(name); end

  def union_bind(enum); end
end

class RuboCop::AST::NodePattern::Compiler::Binding
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*arg, **arg1, &arg2); end

  def node_ids(); end

  def tokens(*arg, **arg1, &arg2); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  def access(); end

  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  def seq_head(); end
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  def compile_sequence(); end

  def compile_terms(children=T.unsafe(nil), last_arity=T.unsafe(nil)); end

  def cur_index(); end

  def in_sync(); end

  def initialize(compiler, sequence:, var:); end

  def sync(); end
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def compile(node); end

  def compiler(); end

  def initialize(compiler); end
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def self.inherited(base); end

  def self.method_added(method); end

  def self.registry(); end
end

class RuboCop::AST::NodePattern::Compiler
  extend ::RuboCop::SimpleForwardable
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Lexer
  def comments(); end

  def initialize(source); end

  def source_buffer(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern::LexerRex
  def action(); end

  def filename(); end

  def filename=(filename); end

  def location(); end

  def match(); end

  def matches(); end

  def next_token(); end

  def parse(str); end

  def parse_file(path); end

  def scanner_class(); end

  def ss(); end

  def ss=(ss); end

  def state(); end

  def state=(state); end
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::NodePattern::MethodDefiner
  def as_lambda(); end

  def compile_as_lambda(); end

  def def_node_matcher(base, method_name, **defaults); end

  def def_node_search(base, method_name, **defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
end

class RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::Descendence
  def arity(); end

  def arity_range(); end

  def capture?(); end

  def child(); end

  def children_nodes(); end

  def in_sequence_head(); end

  def matches_within_set?(); end

  def nb_captures(); end

  def rest?(); end

  def source_range(); end

  def variadic?(); end

  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::AnyOrder
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def ends_with_rest?(); end

  def rest_node(); end

  def term_nodes(); end
end

class RuboCop::AST::NodePattern::Node::AnyOrder
end

class RuboCop::AST::NodePattern::Node::Capture
  def arity(*arg, **arg1, &arg2); end

  def rest?(*arg, **arg1, &arg2); end
end

class RuboCop::AST::NodePattern::Node::Capture
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def in_sequence_head(); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Predicate
  def arg_list(); end

  def method_name(); end
end

class RuboCop::AST::NodePattern::Node::Predicate
end

class RuboCop::AST::NodePattern::Node::Repetition
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def operator(); end
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Sequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Sequence
end

class RuboCop::AST::NodePattern::Node::Subsequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Subsequence
end

class RuboCop::AST::NodePattern::Node::Union
end

class RuboCop::AST::NodePattern::Node::Union
end

class RuboCop::AST::NodePattern::Node
  extend ::RuboCop::SimpleForwardable
end

class RuboCop::AST::NodePattern::Parser
  def _reduce_10(val, _values); end

  def _reduce_11(val, _values); end

  def _reduce_13(val, _values); end

  def _reduce_14(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_19(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_20(val, _values); end

  def _reduce_21(val, _values); end

  def _reduce_22(val, _values); end

  def _reduce_25(val, _values); end

  def _reduce_26(val, _values); end

  def _reduce_3(val, _values); end

  def _reduce_33(val, _values); end

  def _reduce_37(val, _values); end

  def _reduce_38(val, _values); end

  def _reduce_39(val, _values); end

  def _reduce_4(val, _values); end

  def _reduce_40(val, _values); end

  def _reduce_41(val, _values); end

  def _reduce_42(val, _values); end

  def _reduce_43(val, _values); end

  def _reduce_44(val, _values); end

  def _reduce_45(val, _values); end

  def _reduce_46(val, _values); end

  def _reduce_5(val, _values); end

  def _reduce_6(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def emit_atom(*arg, **arg1, &arg2); end

  def emit_call(*arg, **arg1, &arg2); end

  def emit_capture(*arg, **arg1, &arg2); end

  def emit_list(*arg, **arg1, &arg2); end

  def emit_unary_op(*arg, **arg1, &arg2); end

  def emit_union(*arg, **arg1, &arg2); end

  def initialize(builder=T.unsafe(nil)); end

  def next_token(*arg, **arg1, &arg2); end

  def parse(source); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

class RuboCop::AST::NodePattern::Parser
  extend ::RuboCop::SimpleForwardable
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY_NONE_ETC = ::T.let(nil, ::T.untyped)
  SET_ANY_NONE = ::T.let(nil, ::T.untyped)
  SET_ARRAY_HASH = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BRANCH_REF_TAG = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CLONE_DUP_FREEZE = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXIST_EXISTS = ::T.let(nil, ::T.untyped)
  SET_FILETEST_FILE_DIR_SHELL = ::T.let(nil, ::T.untyped)
  SET_FILE_DIR = ::T.let(nil, ::T.untyped)
  SET_FILE_FILETEST = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GETHOSTBYADDR_GETHOSTBYNAME = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_INTEGER_BIGDECIMAL_COMPLEX_RATIONAL = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_MAP_FILTER_MAP = ::T.let(nil, ::T.untyped)
  SET_MODULE_FUNCTION_RUBY2_KEYWORDS = ::T.let(nil, ::T.untyped)
  SET_NEW_ = ::T.let(nil, ::T.untyped)
  SET_NEW_COMPILE = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PRIVATE_CLASS_METHOD = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_READ_BINREAD = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_FILTER_FIND_ALL = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT_FILTER_FILTER = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SET_SORTEDSET = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_H_TO_HASH = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C_TO_R = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__FETCH = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET__PUSH_APPEND = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___8 = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____2 = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
  SET____ETC_4 = ::T.let(nil, ::T.untyped)
  SET_____2 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  def self.[](set); end

  def self.name(set); end

  def self.uniq(name); end
end

class RuboCop::AST::NodePattern
  extend ::RuboCop::SimpleForwardable
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OpAsgnNode
  def assignment_node(); end

  def expression(); end

  def lhs(); end

  def name(); end

  def operator(); end

  def rhs(); end
end

class RuboCop::AST::OpAsgnNode
end

class RuboCop::AST::OrAsgnNode
end

class RuboCop::AST::OrAsgnNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_omission?(); end

  def value_on_new_line?(); end
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
  EMPTY_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::ParameterizedNode::RestArguments
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::PrismPreparsed
  def initialize(prism_result); end

  def parse_lex(_source, **_prism_options); end
end

class RuboCop::AST::PrismPreparsed
end

class RuboCop::AST::Procarg0Node
end

class RuboCop::AST::Procarg0Node
end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def blank?(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def first_token_of(range_or_node); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil), parser_engine: T.unsafe(nil), prism_result: T.unsafe(nil)); end

  def last_token_of(range_or_node); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_engine(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def sorted_tokens(); end

  def start_with?(string); end

  def tokens(); end

  def tokens_within(range_or_node); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version, parser_engine: T.unsafe(nil)); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RationalNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::RationalNode
end

class RuboCop::AST::RegexpNode
  include ::RuboCop::Ext::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def fixed_encoding?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def options(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def branch_index(); end

  def exception_variable(); end

  def exceptions(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RescueNode
  def body(); end

  def branches(); end

  def else?(); end

  def else_branch(); end

  def resbody_branches(); end
end

class RuboCop::AST::RescueNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

module RuboCop::AST::RuboCopCompatibility
  def rubocop_loaded(); end
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(param0=T.unsafe(nil)); end
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def character_literal?(); end

  def double_quoted?(); end

  def heredoc?(); end

  def percent_literal?(type=T.unsafe(nil)); end

  def single_quoted?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def dot?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def new_line?(); end

  def pos(); end

  def regexp_dots?(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
  LEFT_CURLY_TYPES = ::T.let(nil, ::T.untyped)
  LEFT_PAREN_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on_(node); end

  def on___ENCODING__(node); end

  def on___FILE__(node); end

  def on___LINE__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_forwarded_kwrestarg(node); end

  def on_forwarded_restarg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_itblock(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwnilarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Traversal::DebugError
end

class RuboCop::AST::Traversal::DebugError
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::VarNode
  def name(); end
end

class RuboCop::AST::VarNode
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
  extend ::RuboCop::AST::RuboCopCompatibility
end

class RuboCop::ArgumentsEnv
end

class RuboCop::ArgumentsEnv
  def self.read_as_arguments(); end
end

class RuboCop::ArgumentsFile
end

class RuboCop::ArgumentsFile
  def self.read_as_arguments(); end
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  DEFAULT_PARALLEL_OPTIONS = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

module RuboCop::CLI::Command
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_COPS = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED_ONLY_EXCLUDE = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
  YAML_OPTIONAL_DOC_START = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
end

class RuboCop::CLI::Command::LSP
  def run(); end
end

class RuboCop::CLI::Command::LSP
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops::ExactMatcher
  def match?(name); end

  def pattern(); end

  def pattern=(_); end
end

class RuboCop::CLI::Command::ShowCops::ExactMatcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CLI::Command::ShowCops::WildcardMatcher
  def match?(name); end

  def pattern(); end

  def pattern=(_); end
end

class RuboCop::CLI::Command::ShowCops::WildcardMatcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::ShowDocsUrl
  def run(); end
end

class RuboCop::CLI::Command::ShowDocsUrl
end

class RuboCop::CLI::Command::SuggestExtensions
  def run(); end
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CacheConfig
end

class RuboCop::CacheConfig
  def self.root_dir(); end
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def comment_only_line?(line_number); end

  def config(*arg, **arg1, &arg2); end

  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def cop_opted_in?(cop); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end

  def registry(*arg, **arg1, &arg2); end
  CONFIG_DISABLED_LINE_RANGE_MIN = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment
  include ::RuboCop::Ext::Comment
  def initialize(cop_name); end

  def line_number(); end

  def loc(); end

  def text(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def line(); end

  def line=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Expression
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def expression(); end

  def expression=(_); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment::Loc
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig::ConfigDisabledCopDirectiveComment
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::CommentConfig
  extend ::RuboCop::SimpleForwardable
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*arg, **arg1, &arg2); end

  def []=(*arg, **arg1, &arg2); end

  def active_support_extensions_enabled?(); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def clusivity_config_for_badge?(badge); end

  def cop_enabled?(name); end

  def delete(*arg, **arg1, &arg2); end

  def deprecation_check(); end

  def dig(*arg, **arg1, &arg2); end

  def disabled_new_cops?(); end

  def each(*arg, **arg1, &arg2); end

  def each_key(*arg, **arg1, &arg2); end

  def enabled_new_cops?(); end

  def fetch(*arg, **arg1, &arg2); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def for_enabled_cop(cop); end

  def gem_versions_in_target(); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*arg, **arg1, &arg2); end

  def keys(*arg, **arg1, &arg2); end

  def loaded_features(); end

  def loaded_path(); end

  def loaded_plugins(); end

  def make_excludes_absolute(); end

  def map(*arg, **arg1, &arg2); end

  def merge(*arg, **arg1, &arg2); end

  def parser_engine(); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def replace(*arg, **arg1, &arg2); end

  def signature(); end

  def smart_loaded_path(); end

  def string_literals_frozen_by_default?(); end

  def target_rails_version(); end

  def target_ruby_version(*arg, **arg1, &arg2); end

  def to_h(*arg, **arg1, &arg2); end

  def to_hash(*arg, **arg1, &arg2); end

  def transform_values(*arg, **arg1, &arg2); end

  def validate(*arg, **arg1, &arg2); end

  def validate_after_resolution(); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
  EMPTY_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Config
  extend ::RuboCop::SimpleForwardable
  def self.create(hash, path, check: T.unsafe(nil)); end
end

class RuboCop::ConfigFinder
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder
  def self.find_config_path(target_dir); end

  def self.project_root(); end

  def self.project_root=(project_root); end
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_loaded_features(loaded_features); end

  def self.add_loaded_plugins(loaded_plugins); end

  def self.add_missing_namespaces(path, hash); end

  def self.cache_root(); end

  def self.cache_root=(cache_root); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file, check: T.unsafe(nil)); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.ignore_unrecognized_cops(); end

  def self.ignore_unrecognized_cops=(ignore_unrecognized_cops); end

  def self.inject_defaults!(config_yml_path); end

  def self.load_file(file, check: T.unsafe(nil)); end

  def self.load_yaml_configuration(absolute_path); end

  def self.loaded_features(); end

  def self.loaded_plugins(); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.project_root(); end
end

class RuboCop::ConfigLoaderResolver
  def fix_include_paths(base_config_path, hash, path, key, value); end

  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def override_enabled_for_disabled_departments(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_plugins(rubocop_config, plugins); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def deprecated_cop_name?(name); end

  def initialize(config); end

  def legacy_cop_names(); end

  def reject_obsolete!(); end

  def rules(); end

  def warnings(); end
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
end

class RuboCop::ConfigObsoletion::ChangedParameter
  def message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
end

class RuboCop::ConfigObsoletion::CopRule
  def initialize(config, old_name); end

  def message(); end

  def old_name(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::CopRule
end

class RuboCop::ConfigObsoletion::ExtractedCop
  def department(); end

  def gem(); end

  def initialize(config, old_name, gem); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::ExtractedCop
end

class RuboCop::ConfigObsoletion::ParameterRule
  def cop(); end

  def initialize(config, cop, parameter, metadata); end

  def metadata(); end

  def parameter(); end

  def warning?(); end
end

class RuboCop::ConfigObsoletion::ParameterRule
end

class RuboCop::ConfigObsoletion::RemovedCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RemovedCop
end

class RuboCop::ConfigObsoletion::RenamedCop
  def initialize(config, old_name, name_or_hash); end

  def metadata(); end

  def new_name(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::RenamedCop
end

class RuboCop::ConfigObsoletion::Rule
  def cop_rule?(); end

  def initialize(config); end

  def parameter_rule?(); end

  def violated?(); end
end

class RuboCop::ConfigObsoletion::Rule
end

class RuboCop::ConfigObsoletion::SplitCop
  def initialize(config, old_name, metadata); end

  def metadata(); end

  def rule_message(); end
end

class RuboCop::ConfigObsoletion::SplitCop
end

class RuboCop::ConfigObsoletion
  def self.deprecated_cop_name?(name); end

  def self.deprecated_names_for(cop); end

  def self.files(); end

  def self.files=(files); end

  def self.global(); end

  def self.legacy_cop_names(); end

  def self.reset!(); end

  def self.rules_cache_key(); end
end

class RuboCop::ConfigRegeneration
  def options(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
end

class RuboCop::ConfigStore
  def apply_options!(options); end

  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end

  def unvalidated(); end

  def validated(); end

  def validated?(); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*arg, **arg1, &arg2); end

  def initialize(config); end

  def smart_loaded_path(*arg, **arg1, &arg2); end

  def target_ruby_version(); end

  def validate(); end

  def validate_after_resolution(); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  CONFIG_CHECK_AUTOCORRECTS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::RuboCop::SimpleForwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(corrector, processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedIdentifiers
  def allowed_identifier?(name); end

  def allowed_identifiers(); end
  SIGILS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::AllowedIdentifiers
end

module RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::AllowedPattern
end

module RuboCop::Cop::AllowedPattern
end

module RuboCop::Cop::AllowedReceivers
  def allowed_receiver?(receiver); end

  def allowed_receivers(); end

  def receiver_name(receiver); end
end

module RuboCop::Cop::AllowedReceivers
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

class RuboCop::Cop::AnnotationComment
  def annotation?(); end

  def bounds(); end

  def colon(); end

  def comment(); end

  def correct?(colon:); end

  def initialize(comment, keywords); end

  def keyword(); end

  def margin(); end

  def note(); end

  def space(); end
end

class RuboCop::Cop::AnnotationComment
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def autocorrect_with_disable_uncorrectable?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def department_name(); end

  def eql?(other); end

  def initialize(class_name_parts); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge
  def self.camel_case(name_part); end

  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def active_support_extensions_enabled?(); end

  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def always_autocorrect?(); end

  def begin_investigation(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def callbacks_needed(); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def contextual_autocorrect?(); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def parse(source, path=T.unsafe(nil)); end

  def parser_engine(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def string_literals_frozen_by_default?(); end

  def target_gem_version(gem_name); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Base
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.callbacks_needed(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(config=T.unsafe(nil)); end

  def self.exclude_from_registry(); end

  def self.gem_requirements(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.requires_gem(gem_name, *version_requirements); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::DuplicatedGroup
  include ::RuboCop::Cop::RangeHelp
  def group_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  SOURCE_BLOCK_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGroup
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::GemDeclaration
  def on_send(node); end
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::GemFilename
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  GEMFILE_FILES = ::T.let(nil, ::T.untyped)
  GEMS_RB_FILES = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_REQUIRED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemFilename
end

class RuboCop::Cop::Bundler::GemVersion
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemDeclaration
  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemVersion
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  def insecure_protocol_source?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_HTTP_PROTOCOL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::OrderedGemNode
  def gem_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::CheckSingleLineSuitability
  def suitable_as_single_line?(node); end
end

module RuboCop::Cop::CheckSingleLineSuitability
end

module RuboCop::Cop::CodeLength
  def max=(value); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
  extend ::RuboCop::ExcludeLimit
end

module RuboCop::Cop::CommentsHelp
  def comments_contain_disables?(node, cop_name); end

  def comments_in_range(node); end

  def contains_comments?(node); end

  def source_range_with_comment(node); end
end

module RuboCop::Cop::CommentsHelp
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.inherited(_subclass); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end

  def swap(node_or_range1, node_or_range2); end
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DefNode
  include ::RuboCop::Cop::VisibilityHelp
  def non_public_modifier?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::DigHelp
  def dig?(param0=T.unsafe(nil)); end

  def single_argument_dig?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::DigHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Documentation
end

module RuboCop::Cop::Documentation
  def self.base_url_for(cop_class, config); end

  def self.builtin?(cop_class); end

  def self.default_base_url(); end

  def self.default_extension(); end

  def self.department_to_basename(department); end

  def self.extension_for(cop_class, config); end

  def self.url_for(cop_class, config=T.unsafe(nil)); end
end

module RuboCop::Cop::DocumentationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EndlessMethodRewriter
  def correct_to_multiline(corrector, node); end
end

module RuboCop::Cop::EndlessMethodRewriter
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::ForbiddenIdentifiers
  def forbidden_identifier?(name); end

  def forbidden_identifiers(); end
  SIGILS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ForbiddenIdentifiers
end

module RuboCop::Cop::ForbiddenPattern
  def forbidden_pattern?(name); end

  def forbidden_patterns(); end
end

module RuboCop::Cop::ForbiddenPattern
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force::HookError
  def initialize(joining_cop); end

  def joining_cop(); end
end

class RuboCop::Cop::Force::HookError
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::GemDeclaration
  def gem_declaration?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::GemDeclaration
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::AddRuntimeDependency
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::AddRuntimeDependency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Gemspec::AttributeAssignment
  include ::RuboCop::Cop::GemspecHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::AttributeAssignment
end

class RuboCop::Cop::Gemspec::DependencyVersion
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::GemspecHelp
  def add_dependency_method_declaration?(param0=T.unsafe(nil)); end

  def includes_commit_reference?(param0=T.unsafe(nil)); end

  def includes_version_specification?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ADD_DEPENDENCY_METHODS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DependencyVersion
end

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment
  include ::RuboCop::Cop::RangeHelp
  def gem_specification(param0=T.unsafe(nil)); end

  def on_block(block_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Gemspec::DevelopmentDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def add_development_dependency?(param0=T.unsafe(nil)); end

  def gem?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DevelopmentDependencies
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::GemspecHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::OrderedGemNode
  def dependency_declarations(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Gemspec::RequireMFA
  include ::RuboCop::Cop::GemspecHelp
  def metadata(param0=T.unsafe(nil)); end

  def metadata_assignment(param0); end

  def on_block(node); end

  def rubygems_mfa_required(param0); end

  def true_string?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequireMFA
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def defined_ruby_version(param0=T.unsafe(nil)); end

  def on_send(node); end

  def required_ruby_version?(param0); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  include ::RuboCop::Cop::GemspecHelp
  def on_const(node); end

  def ruby_version?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

module RuboCop::Cop::GemspecHelp
  def assignment_method_declarations(param0); end

  def gem_specification(param0); end

  def gem_specification?(param0=T.unsafe(nil)); end

  def indexed_assignment_method_declarations(param0); end

  def match_block_variable_name?(receiver_name); end
end

module RuboCop::Cop::GemspecHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Generator
  def initialize(name, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added: T.unsafe(nil)); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
  def deltas(first_pair, current_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::KeywordSplatAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(_first_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashShorthandSyntax
  def on_hash_for_mixed_shorthand(hash_node); end

  def on_pair(node); end
  DO_NOT_MIX_EXPLICIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_MSG_PREFIX = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_OMIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  EXPLICIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
  OMIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def first_argument(); end

  def last_argument(); end

  def node(); end

  def node=(_); end

  def selector(); end
end

class RuboCop::Cop::HashShorthandSyntax::DefNode
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::HashShorthandSyntax
end

module RuboCop::Cop::HashSubset
  include ::RuboCop::Cop::RangeHelp
  def block_with_first_arg_check?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  ACTIVE_SUPPORT_SUBSET_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SUBSET_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashSubset
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::HashTransformMethod
  def array_receiver?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*arg); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end

  def use_transformed_argname?(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

class RuboCop::Cop::IfThenCorrector
  def call(corrector); end

  def initialize(if_node, indentation: T.unsafe(nil)); end
  DEFAULT_INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IfThenCorrector
end

RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BeginEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def block_end_align_target?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end

  def on_case_match(case_match_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClassStructure
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::CommentsHelp
  def on_class(class_node); end

  def on_sclass(class_node); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ConditionPosition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_DIRECTIVE_COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(corrector, prev_def, node, count); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAfterModuleInclusion
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MODULE_INCLUSION_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAfterModuleInclusion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_class(node); end

  def on_itblock(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(param0=T.unsafe(nil)); end

  def empty_line_required?(param0=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_case_match(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def eligible_method_call?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  include ::RuboCop::Cop::AllowedMethods
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offenses_by(); end

  def offenses_by=(offenses_by); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  SEPARATOR_ALIGNMENT_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::AllowedPattern
  def access_modifier?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_case(case_node); end

  def on_case_match(case_match); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_itblock(node); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineContinuationLeadingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_dstr(node); end
end

class RuboCop::Cop::Layout::LineContinuationLeadingSpace
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineContinuationSpacing
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::LineContinuationSpacing
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  def autocorrect(corrector, node); end

  def on_dstr(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
  PARENT_TYPES_FOR_INDENTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def max=(value); end

  def on_array(node); end

  def on_block(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_hash(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::RedundantLineBreak
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::CheckSingleLineSuitability
  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RedundantLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token, next_token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token, _next_token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_in_pattern(node); end

  def on_kwbegin(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::RangeHelp
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_pattern(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_setter_method(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end

  def on_array_pattern(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end

  def on_hash_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Heredoc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::Legacy::CorrectionsProxy
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousAssignment
  include ::RuboCop::Cop::RangeHelp
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MISTAKES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousAssignment
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  def on_and(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousRange
  include ::RuboCop::Cop::RationalLiteral
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRange
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ArrayLiteralInRegexp
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end
  MSG_ALTERNATION = ::T.let(nil, ::T.untyped)
  MSG_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  MSG_UNKNOWN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ArrayLiteralInRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(param0=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  include ::RuboCop::Cop::AllowedMethods
  def constant_assigned_in_block?(param0=T.unsafe(nil)); end

  def module_defined_in_block?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
end

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue
  include ::RuboCop::Cop::RangeHelp
  def on_resbody(node); end

  def overwritten_constant(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ConstantReassignment
  def on_casgn(node); end

  def on_send(node); end

  def remove_constant(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantReassignment
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
end

class RuboCop::Cop::Lint::CopDirectiveSyntax
  COMMON_MSG = ::T.let(nil, ::T.untyped)
  INVALID_MODE_NAME_MSG = ::T.let(nil, ::T.untyped)
  MALFORMED_COP_NAMES_MSG = ::T.let(nil, ::T.untyped)
  MISSING_COP_NAME_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MODE_NAME_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CopDirectiveSyntax
end

class RuboCop::Cop::Lint::Debugger
  def on_send(node); end
  BLOCK_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def deprecated_class_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  DIR_ENV_FILE_CONSTANTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DeprecatedConstants
  def on_const(node); end
  DO_NOT_USE_MSG = ::T.let(nil, ::T.untyped)
  SUGGEST_GOOD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedConstants
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  include ::RuboCop::Cop::RangeHelp
  def algorithm_const(param0=T.unsafe(nil)); end

  def digest_const?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_ARG_ALGORITHM = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateBranch
  def on_branching_statement(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
end

class RuboCop::Cop::Lint::DuplicateMagicComment
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMagicComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateMatchPattern
  def on_case_match(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMatchPattern
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(param0=T.unsafe(nil)); end

  def delegate_method?(param0=T.unsafe(nil)); end

  def method_alias?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  include ::RuboCop::Cop::RangeHelp
  def each_repeated_character_class_element_loc(node); end

  def on_regexp(node); end
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateRequire
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateRescueException
  include ::RuboCop::Cop::RescueNode
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
end

class RuboCop::Cop::Lint::DuplicateSetElement
  def on_csend(node); end

  def on_send(node); end

  def set_init_elements(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateSetElement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyBlock
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
end

class RuboCop::Cop::Lint::EmptyClass
  def on_class(node); end

  def on_sclass(node); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  include ::RuboCop::Cop::CommentsHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
end

class RuboCop::Cop::Lint::EmptyInPattern
  include ::RuboCop::Cop::CommentsHelp
  def on_case_match(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInPattern
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyWhen
  include ::RuboCop::Cop::CommentsHelp
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def erb_new_with_non_keyword_arguments(param0=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGE_EOUTVAR = ::T.let(nil, ::T.untyped)
  MESSAGE_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  MESSAGE_TRIM_MODE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatComparison
  def on_case(node); end

  def on_csend(node); end

  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG_CASE = ::T.let(nil, ::T.untyped)
  MSG_EQUALITY = ::T.let(nil, ::T.untyped)
  MSG_INEQUALITY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  def id_as_hash_key?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
end

class RuboCop::Cop::Lint::HashNewWithKeywordArgumentsAsDefault
  def hash_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashNewWithKeywordArgumentsAsDefault
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::IdentityComparison
  def object_id_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  def io_select(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(param0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def class_new_call?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ItWithoutArgumentsInBlock
  include ::RuboCop::AST::NodePattern::Macros
  def deprecated_it_method?(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ItWithoutArgumentsInBlock
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  def lambda_with_symbol_proc?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::LiteralAsCondition
  include ::RuboCop::Cop::RangeHelp
  def message(node); end

  def on_and(node); end

  def on_case(case_node); end

  def on_case_match(case_match_node); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::LiteralAssignmentInCondition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAssignmentInCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MissingSuper
  def class_new_block(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
end

class RuboCop::Cop::Lint::MixedCaseRange
  include ::RuboCop::Cop::RangeHelp
  def each_unsafe_regexp_range(node); end

  def on_erange(node); end

  def on_irange(node); end

  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RANGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedCaseRange
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(param0=T.unsafe(nil)); end

  def on_send(node); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SET_OPERATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def eval_call?(param0=T.unsafe(nil)); end

  def exec_call?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_block_body_of_reduce(param0=T.unsafe(nil)); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
end

class RuboCop::Cop::Lint::NonAtomicFileOperation
  def explicit_not_force?(param0); end

  def force?(param0); end

  def on_send(node); end

  def receiver_and_method_name(param0=T.unsafe(nil)); end

  def send_exist_node(param0); end
  MAKE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  MAKE_METHODS = ::T.let(nil, ::T.untyped)
  MSG_CHANGE_FORCE_METHOD = ::T.let(nil, ::T.untyped)
  MSG_REMOVE_FILE_EXIST_CHECK = ::T.let(nil, ::T.untyped)
  RECURSIVE_REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonAtomicFileOperation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(param0=T.unsafe(nil)); end

  def method_require?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_numblock(node); end

  def unsorted_dir_block?(param0=T.unsafe(nil)); end

  def unsorted_dir_each?(param0=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(param0=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(param0=T.unsafe(nil)); end

  def var_is_required?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_csend(node); end

  def on_send(node); end

  def to_method(param0=T.unsafe(nil)); end

  def to_method_symbol(param0=T.unsafe(nil)); end
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
  def on_lvasgn(node); end
  LVAR_MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_RANGE = ::T.let(nil, ::T.untyped)
  NUM_PARAM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
end

class RuboCop::Cop::Lint::NumericOperationWithConstantResult
  def abbreviated_assignment_with_constant_result?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_op_asgn(node); end

  def on_send(node); end

  def operation_with_constant_result?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumericOperationWithConstantResult
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def after_csend(node); end

  def after_send(node); end

  def on_in_pattern(node); end

  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(param0=T.unsafe(nil)); end

  def exception_new_with_message?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::Cop::RangeHelp
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
  COP_NAME = ::T.let(nil, ::T.untyped)
  DEPARTMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  def on_send(node); end
  GLOB_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::RedundantRegexpQuantifiers
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
  MSG_REDUNDANT_QUANTIFIER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRegexpQuantifiers
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def redundant_require_statement?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  RUBY_22_LOADED_FEATURES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  include ::RuboCop::Cop::AllowedMethods
  def conversion_with_default?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_or(node); end

  def respond_to_nil_specific_method?(param0=T.unsafe(nil)); end
  GUARANTEED_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL = ::T.let(nil, ::T.untyped)
  MSG_NON_NIL = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(param0=T.unsafe(nil)); end

  def literal_expansion(param0=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end

  def on_send(node); end

  def to_s_without_args?(param0=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantTypeConversion
  def array_constructor?(param0=T.unsafe(nil)); end

  def bigdecimal_constructor?(param0=T.unsafe(nil)); end

  def complex_constructor?(param0=T.unsafe(nil)); end

  def exception_false_keyword_argument?(param0=T.unsafe(nil)); end

  def float_constructor?(param0=T.unsafe(nil)); end

  def hash_constructor?(param0=T.unsafe(nil)); end

  def integer_constructor?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def rational_constructor?(param0=T.unsafe(nil)); end

  def set_constructor?(param0=T.unsafe(nil)); end

  def string_constructor?(param0=T.unsafe(nil)); end

  def type_constructor?(param0=T.unsafe(nil), param1); end
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TYPED_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantTypeConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def redundant_with_index?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def redundant_with_object?(param0=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RefinementImportMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RefinementImportMethods
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RequireRangeParentheses
  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRangeParentheses
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  def autocorrect(corrector, node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
  SCOPE_CHANGING_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def bad_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLUS_MINUS_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def on_and(node); end

  def on_or(node); end
  USE_DOT_MSG = ::T.let(nil, ::T.untyped)
  USE_SAFE_NAVIGATION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_csend(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def send_with_mixin_argument?(param0=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(param0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def ractor_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::SharedMutableDefault
  def capacity_keyword_argument?(param0=T.unsafe(nil)); end

  def hash_initialized_with_mutable_shared_object?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SharedMutableDefault
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
end

class RuboCop::Cop::Lint::SuppressedExceptionInNumberConversion
  def begin_numeric_constructor_rescue_nil(param0=T.unsafe(nil)); end

  def constructor_receiver?(param0=T.unsafe(nil)); end

  def numeric_constructor_rescue_nil(param0=T.unsafe(nil)); end

  def numeric_method?(param0=T.unsafe(nil)); end

  def on_rescue(node); end
  EXPECTED_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedExceptionInNumberConversion
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::SymbolConversion
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  def on_hash(node); end

  def on_send(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CONSISTENCY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SymbolConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Syntax
  LEVELS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax
end

class RuboCop::Cop::Lint::ToEnumArguments
  def enum_conversion_call?(param0=T.unsafe(nil)); end

  def method_name?(param0=T.unsafe(nil), param1); end

  def on_send(node); end

  def passing_keyword_arg?(param0=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TripleQuotes
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TripleQuotes
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnescapedBracketInRegexp
  def on_regexp(node); end

  def on_send(node); end

  def regexp_constructor(param0); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnescapedBracketInRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(param0=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  def accumulator_index?(param0=T.unsafe(nil), param1); end

  def element_modified?(param0, param1); end

  def expression_values(param0); end

  def lvar_used?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_numblock(node); end

  def reduce_with_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
end

class RuboCop::Cop::Lint::UnreachableCode
  def after_block(node); end

  def flow_command?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_block(node); end

  def on_itblock(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

class RuboCop::Cop::Lint::UnreachableLoop
  include ::RuboCop::Cop::AllowedPattern
  def break_command?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  CONTINUE_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def not_implemented?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(param0=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end

  def uri_constant?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAccessModifier
  include ::RuboCop::Cop::RangeHelp
  def class_or_instance_eval?(param0=T.unsafe(nil)); end

  def dynamic_method_definition?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_block(node); end

  def on_class(node); end

  def on_itblock(node); end

  def on_module(node); end

  def on_numblock(node); end

  def on_sclass(node); end

  def static_method_definition?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::Cop::RangeHelp
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(corrector, assignment); end

  def chained_assignment?(node); end

  def check_for_unused_assignment(variable, assignment); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def ignored_assignment?(variable, assignment_node, assignment); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def offense_range(assignment); end

  def operator_assignment_message(scope, assignment); end

  def remove_exception_assignment_part(corrector, node); end

  def remove_local_variable_assignment_part(corrector, node); end

  def remove_trailing_character_from_operator(corrector, node); end

  def rename_variable_with_underscore(corrector, node); end

  def replace_named_capture_group_with_non_capturing_group(corrector, node, variable_name); end

  def return_value_node_of_scope(scope); end

  def sequential_assignment?(node); end

  def similar_name_message(variable); end

  def variable_in_loop_condition?(assignment_node, variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessConstantScoping
  def on_casgn(node); end

  def private_constants(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessConstantScoping
end

class RuboCop::Cop::Lint::UselessDefaultValueArgument
  include ::RuboCop::Cop::AllowedReceivers
  def default_value_argument_and_block(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessDefaultValueArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessDefined
  def on_defined?(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessDefined
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessNumericOperation
  def on_csend(node); end

  def on_op_asgn(node); end

  def on_send(node); end

  def useless_abbreviated_assignment?(param0=T.unsafe(nil)); end

  def useless_operation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessNumericOperation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessOr
  def on_or(node); end

  def truthy_return_value_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  TRUTHY_RETURN_VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessOr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessRescue
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRescue
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
  def method_definition(param0=T.unsafe(nil), param1); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(param0=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessTimes
  include ::RuboCop::Cop::RangeHelp
  def block_arg(param0=T.unsafe(nil)); end

  def block_reassigns_arg?(param0, param1); end

  def on_send(node); end

  def times_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Lint::Utils
end

class RuboCop::Cop::Lint::Utils::NilReceiverChecker
  def cant_be_nil?(); end

  def initialize(receiver, additional_nil_methods); end
  NIL_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Utils::NilReceiverChecker
end

module RuboCop::Cop::Lint::Utils
end

class RuboCop::Cop::Lint::Void
  include ::RuboCop::Cop::RangeHelp
  def on_begin(node); end

  def on_block(node); end

  def on_ensure(node); end

  def on_itblock(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  CONST_MSG = ::T.let(nil, ::T.untyped)
  EXPRESSION_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  METHODS_REPLACEABLE_BY_EACH = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS_WITH_BANG_VERSION = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def define_method?(param0=T.unsafe(nil)); end

  def max=(value); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_itblock(node); end

  def on_numblock(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::AST::NodePattern::Macros
  extend ::RuboCop::ExcludeLimit
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  def max=(value); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::CodeLength
  def on_casgn(node); end

  def on_class(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CollectionLiteralLength
  def on_array(node); end

  def on_hash(node); end

  def on_index(node); end

  def on_send(node); end

  def set_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CollectionLiteralLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::CodeLength
  def module_definition?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  def argument_to_lambda_or_proc?(param0=T.unsafe(nil)); end

  def max=(value); end

  def max_optional_parameters=(value); end

  def on_args(node); end

  def on_def(node); end

  def on_defs(node); end

  def struct_new_or_data_define_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def calculate(); end

  def else_branch?(node); end

  def evaluate_condition_node(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node, discount_repeated_attributes: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
  def attribute_call?(param0=T.unsafe(nil)); end

  def calculate_node(node); end

  def discount_repeated_attributes?(); end

  def evaluate_branch_nodes(node); end

  def initialize(node, discount_repeated_attributes: T.unsafe(nil)); end

  def root_node?(param0=T.unsafe(nil)); end
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::Migration
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Migration
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBranchesCount
end

module RuboCop::Cop::MinBranchesCount
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_csend(node); end

  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(param0=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::BlockForwarding
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockForwarding
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(param0=T.unsafe(nil)); end

  def literal_receiver?(param0=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  def struct_definition(param0=T.unsafe(nil)); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::InclusiveLanguage
  include ::RuboCop::Cop::RangeHelp
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def position(); end

  def position=(_); end

  def word(); end

  def word=(_); end
end

class RuboCop::Cop::Naming::InclusiveLanguage::WordLocation
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::Naming::InclusiveLanguage
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def defined_memoized?(param0=T.unsafe(nil), param1); end

  def method_definition?(param0=T.unsafe(nil)); end

  def on_defined?(node); end

  def on_or_asgn(node); end
  DYNAMIC_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
  INITIALIZE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ForbiddenIdentifiers
  include ::RuboCop::Cop::ForbiddenPattern
  def define_data?(param0=T.unsafe(nil)); end

  def new_struct?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(param0=T.unsafe(nil)); end

  def sym_name(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FORBIDDEN = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateMethod
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_def(node); end

  def on_defs(node); end
  MSG_NON_PREDICATE = ::T.let(nil, ::T.untyped)
  MSG_PREDICATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::PredicateMethod
end

class RuboCop::Cop::Naming::PredicatePrefix
  include ::RuboCop::Cop::AllowedMethods
  def dynamic_method_define(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sorbet_return_type(param0=T.unsafe(nil)); end

  def validate_config(); end
end

class RuboCop::Cop::Naming::PredicatePrefix
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::ForbiddenIdentifiers
  include ::RuboCop::Cop::ForbiddenPattern
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FORBIDDEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::AllowedIdentifiers
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedPattern
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(param0=T.unsafe(nil)); end

  def single_negative?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, node); end
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
  ASSIGNMENT_OR_COMPARISON_TOKENS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp::NOT_GIVEN
end

module RuboCop::Cop::RangeHelp::NOT_GIVEN
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Registry
  include ::Enumerable
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def cops_for_department(department); end

  def department?(name); end

  def department_missing?(badge, name); end

  def departments(); end

  def disabled(config); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config); end

  def enabled?(cop, config); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def find_cops_by_directive(directive); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def names_for_department(department); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def qualify_badge(badge); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop?(name); end

  def self.qualified_cop_name(name, origin, warn: T.unsafe(nil)); end

  def self.reset!(); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RequireLibrary
  def ensure_required(corrector, node, library_name); end

  def on_send(node); end

  def remove_subsequent_requires(corrector, node, library_name); end

  def require_any_library?(param0=T.unsafe(nil)); end

  def require_library_name?(param0=T.unsafe(nil), param1); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RequireLibrary
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::RequireLibraryCorrector
end

class RuboCop::Cop::RequireLibraryCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, node, library_name); end

  def self.require_statement(library_name); end
end

module RuboCop::Cop::RescueNode
  def modifier_locations(); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(param0=T.unsafe(nil)); end

  def safe_assignment?(param0=T.unsafe(nil)); end

  def setter_method?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::CompoundHash
  def bad_hash_combinator?(param0=T.unsafe(nil)); end

  def contained_in_hash_method?(node, &block); end

  def dynamic_hash_method_definition?(param0=T.unsafe(nil)); end

  def hash_method_definition?(param0=T.unsafe(nil)); end

  def monuple_hash?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_op_asgn(node); end

  def on_send(node); end

  def outer_bad_hash_combinator?(node); end

  def redundant_hash?(param0=T.unsafe(nil)); end

  def static_hash_method_definition?(param0=T.unsafe(nil)); end
  COMBINATOR_IN_HASH_MSG = ::T.let(nil, ::T.untyped)
  MONUPLE_HASH_MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::CompoundHash
end

class RuboCop::Cop::Security::Eval
  def eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::IoMethods
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::IoMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Security::JSONLoad
  def insecure_json_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def on_new_investigation(); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(corrector, node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def access_modifier_with_alias_method?(param0=T.unsafe(nil)); end

  def access_modifier_with_attr?(param0=T.unsafe(nil)); end

  def access_modifier_with_symbol?(param0=T.unsafe(nil)); end

  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AccessorGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AmbiguousEndlessMethodDefinition
  include ::RuboCop::Cop::EndlessMethodRewriter
  include ::RuboCop::Cop::RangeHelp
  def ambiguous_endless_method_body(param0=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AmbiguousEndlessMethodDefinition
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArgumentsForwarding
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  ARGS_MSG = ::T.let(nil, ::T.untyped)
  BLOCK_MSG = ::T.let(nil, ::T.untyped)
  FORWARDING_LVAR_TYPES = ::T.let(nil, ::T.untyped)
  FORWARDING_MSG = ::T.let(nil, ::T.untyped)
  KWARGS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding::SendNodeClassifier
  def classification(); end

  def def_all_anonymous_args?(param0=T.unsafe(nil)); end

  def extract_forwarded_kwrest_arg(param0=T.unsafe(nil), param1); end

  def forwarded_block_arg(); end

  def forwarded_block_arg?(param0=T.unsafe(nil), param1); end

  def forwarded_kwrest_arg(); end

  def forwarded_rest_arg(); end

  def forwarded_rest_arg?(param0=T.unsafe(nil), param1); end

  def initialize(def_node, send_node, referenced_lvars, forwardable_args, **config); end

  def send_all_anonymous_args?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ArgumentsForwarding::SendNodeClassifier
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Style::ArgumentsForwarding
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(param0=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayFirstLast
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayFirstLast
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayIntersect
  def any_none_block_intersection(param0=T.unsafe(nil)); end

  def bad_intersection_check?(param0=T.unsafe(nil), param1); end

  def intersection_size_check?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  ACTIVE_SUPPORT_PREDICATES = ::T.let(nil, ::T.untyped)
  ARRAY_SIZE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_METHODS = ::T.let(nil, ::T.untyped)
  PREDICATES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRAIGHT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayIntersect
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::ArrayIntersectWithSingleElement
  def on_csend(node); end

  def on_send(node); end

  def single_element(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayIntersectWithSingleElement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def class_eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def file_open_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  include ::RuboCop::Cop::RangeHelp
  def after_class(class_node); end

  def after_module(class_node); end

  def after_sclass(class_node); end

  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  include ::RuboCop::Cop::VisibilityHelp
  def all_bisected?(); end

  def attr_names(); end

  def attrs(); end

  def bisect(*names); end

  def bisected_names(); end

  def bisection(); end

  def initialize(node); end

  def node(); end

  def reader?(); end

  def rest(); end

  def visibility(); end

  def writer?(); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor::Macro
  def self.macro?(node); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BitwisePredicate
  def allbits?(param0=T.unsafe(nil)); end

  def anybits?(param0=T.unsafe(nil)); end

  def bit_operation?(param0=T.unsafe(nil)); end

  def nobits?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BitwisePredicate
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def self_class?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseLikeIf
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MinBranchesCount
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(corrector, node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassEqualityComparison
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def class_comparison_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  CLASS_NAME_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::RangeHelp
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionCompact
  include ::RuboCop::Cop::AllowedReceivers
  include ::RuboCop::Cop::RangeHelp
  def grep_v_with_nil?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def reject_method?(param0=T.unsafe(nil)); end

  def reject_method_with_block_pass?(param0=T.unsafe(nil)); end

  def select_method?(param0=T.unsafe(nil)); end
  FILTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TO_ENUM_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CollectionQuerying
  include ::RuboCop::Cop::RangeHelp
  def count_predicate(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionQuerying
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CombinableDefined
  include ::RuboCop::Cop::RangeHelp
  def on_and(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableDefined
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::RangeHelp
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG_COLON_STYLE = ::T.let(nil, ::T.untyped)
  MSG_SPACE_STYLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentedKeyword
  include ::RuboCop::Cop::RangeHelp
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  METHOD_OR_END_DEFINITIONS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STEEP_REGEXP = ::T.let(nil, ::T.untyped)
  SUBCLASS_DEFINITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ComparableBetween
  def logical_comparison_between_by_max_first?(param0=T.unsafe(nil)); end

  def logical_comparison_between_by_min_first?(param0=T.unsafe(nil)); end

  def on_and(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ComparableBetween
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ComparableClamp
  include ::RuboCop::Cop::Alignment
  def array_min_max?(param0=T.unsafe(nil)); end

  def if_elsif_else_condition?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MIN_MAX = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ComparableClamp
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::ConcatArrayLiterals
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_PERCENT_LITERALS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConcatArrayLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(param0=T.unsafe(nil)); end

  def candidate_condition?(param0=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def same_line?(node1, node2); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DataInheritance
  include ::RuboCop::Cop::RangeHelp
  def data_define?(param0=T.unsafe(nil)); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DataInheritance
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::DateTime
  def date_time?(param0=T.unsafe(nil)); end

  def historic_date?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def to_datetime?(param0=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DefWithParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DigChain
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::DigHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DigChain
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::DirEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DirEmpty
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  def on_send(node); end
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(param0=T.unsafe(nil)); end

  def constant_visibility_declaration?(param0=T.unsafe(nil)); end

  def include_statement?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::DefNode
  include ::RuboCop::Cop::VisibilityHelp
  def modifier_node?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DoubleNegation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def double_negative?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def each_range(param0=T.unsafe(nil)); end

  def each_range_with_zero_origin?(param0=T.unsafe(nil)); end

  def each_range_without_block_argument?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def each_with_object_block_candidate?(param0=T.unsafe(nil)); end

  def each_with_object_numblock_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_numblock(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_PARENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_normal_if_unless(node); end
  EMPTY_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NIL_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyHeredoc
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyHeredoc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  def array_node(param0=T.unsafe(nil)); end

  def array_with_block(param0=T.unsafe(nil)); end

  def array_with_index(param0=T.unsafe(nil)); end

  def hash_node(param0=T.unsafe(nil)); end

  def hash_with_block(param0=T.unsafe(nil)); end

  def hash_with_index(param0=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(param0=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyStringInsideInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(node); end
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
  MSG_TRAILING_CONDITIONAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyStringInsideInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EndlessMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::EndlessMethodRewriter
  def on_def(node); end
  CORRECTION_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_ALWAYS = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndlessMethod
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EnvHome
  def env_home?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EnvHome
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EvalWithLocation
  def line_with_offset?(param0=T.unsafe(nil), param1, param2); end

  def on_send(node); end

  def valid_eval_receiver?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EVAL = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_FILE = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExactRegexpMatch
  def exact_regexp_match(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExactRegexpMatch
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def file_expand_path(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(param0=T.unsafe(nil)); end

  def pathname_parent_expand_path(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  include ::RuboCop::Cop::RangeHelp
  def on_yield(node); end

  def yielding_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FetchEnvVar
  def env_with_bracket?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_WITHOUT_NIL = ::T.let(nil, ::T.untyped)
  MSG_WITH_NIL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FetchEnvVar
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FileEmpty
  def offensive?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileEmpty
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::FileNull
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileNull
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FileRead
  include ::RuboCop::Cop::RangeHelp
  def block_read?(param0=T.unsafe(nil)); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  READ_FILE_START_TO_FINISH_MODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileRead
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FileTouch
  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end
  APPEND_FILE_MODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileTouch
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FileWrite
  include ::RuboCop::Cop::RangeHelp
  def block_write?(param0=T.unsafe(nil)); end

  def evidence(node); end

  def file_open?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def send_write?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TRUNCATING_WRITE_MODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileWrite
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(param0=T.unsafe(nil)); end

  def both_coerce?(param0=T.unsafe(nil)); end

  def left_coerce?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def regexp_last_match?(param0=T.unsafe(nil)); end

  def right_coerce?(param0=T.unsafe(nil)); end

  def to_f_method?(param0=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_for(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def formatter(param0=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(param0=T.unsafe(nil)); end
  AUTOCORRECTABLE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def format_string_in_typical_context?(param0=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(param0=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashConversion
  def hash_from_array?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_LITERAL_HASH_ARG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL_MULTI_ARG = ::T.let(nil, ::T.untyped)
  MSG_SPLAT = ::T.let(nil, ::T.untyped)
  MSG_TO_H = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::AllowedReceivers
  include ::RuboCop::Cop::Lint::UnusedArgument
  def check_unused_block_args(node, key, value); end

  def each_arguments(param0=T.unsafe(nil)); end

  def hash_mutated?(param0=T.unsafe(nil), param1); end

  def kv_each(param0=T.unsafe(nil)); end

  def kv_each_with_block_pass(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  ARRAY_CONVERTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNUSED_BLOCK_ARG_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashExcept
  include ::RuboCop::Cop::HashSubset
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::HashExcept
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashFetchChain
  def diggable?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashFetchChain
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::HashLikeCase
  include ::RuboCop::Cop::MinBranchesCount
  def hash_like_case?(param0=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
end

class RuboCop::Cop::Style::HashSlice
  include ::RuboCop::Cop::HashSubset
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::HashSlice
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::HashShorthandSyntax
  include ::RuboCop::Cop::RangeHelp
  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
  NO_MIXED_KEYS_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_case_match(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::IfInsideElse
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::CommentsHelp
  def on_if(node); end
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  include ::RuboCop::Cop::AllowedMethods
  def double_negative?(param0=T.unsafe(nil)); end

  def if_with_boolean_literal_branches?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_ELSIF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_NEWLINE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InPatternThen
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InPatternThen
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::InfiniteLoop
  include ::RuboCop::Cop::Alignment
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def inverse_block?(param0=T.unsafe(nil)); end

  def inverse_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION_INCOMPATIBLE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::InvertibleUnlessCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InvertibleUnlessCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::ItAssignment
  def on_arg(node); end

  def on_blockarg(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ItAssignment
end

class RuboCop::Cop::Style::ItBlockParameter
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG_AVOID_IT_PARAMETER = ::T.let(nil, ::T.untyped)
  MSG_AVOID_IT_PARAMETER_MULTILINE = ::T.let(nil, ::T.untyped)
  MSG_USE_IT_PARAMETER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ItBlockParameter
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::KeywordArgumentsMerging
  def merge_kwargs?(param0=T.unsafe(nil)); end

  def on_kwsplat(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordArgumentsMerging
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::KeywordParametersOrder
  include ::RuboCop::Cop::RangeHelp
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MagicCommentFormat
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  KEBAB_SEPARATOR = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_VALUE = ::T.let(nil, ::T.untyped)
  SNAKE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  def comment(); end

  def directives(); end

  def initialize(comment); end

  def loc(*arg, **arg1, &arg2); end

  def text(*arg, **arg1, &arg2); end

  def values(); end
  DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  VALUE_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  extend ::RuboCop::SimpleForwardable
end

class RuboCop::Cop::Style::MagicCommentFormat
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MapCompactWithConditionalBlock
  def conditional_block(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapCompactWithConditionalBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MapIntoArray
  include ::RuboCop::Cop::RangeHelp
  def after_leaving_scope(scope, _variable_table); end

  def each_block_with_push?(param0=T.unsafe(nil)); end

  def empty_array_asgn?(param0=T.unsafe(nil)); end

  def empty_array_tap(param0=T.unsafe(nil)); end

  def lvar_ref?(param0=T.unsafe(nil), param1); end

  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def suitable_argument_node?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapIntoArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MapToHash
  include ::RuboCop::Cop::RangeHelp
  def destructuring_argument(param0=T.unsafe(nil)); end

  def map_to_h(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToHash
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::MapToSet
  include ::RuboCop::Cop::RangeHelp
  def map_to_set?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToSet
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  include ::RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  include ::RuboCop::Cop::RangeHelp
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MinMaxComparison
  include ::RuboCop::Cop::RangeHelp
  def comparison_condition(param0=T.unsafe(nil)); end

  def on_if(node); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  GREATER_OPERATORS = ::T.let(nil, ::T.untyped)
  LESS_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMaxComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_case_match(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MixinUsage
  def in_top_level_scope?(param0=T.unsafe(nil)); end

  def include_statement(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def extend_self_node?(param0=T.unsafe(nil)); end

  def module_function_node?(param0=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(param0=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ModuleMemberExistenceCheck
  def instance_methods_inclusion?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleMemberExistenceCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineInPatternThen
  include ::RuboCop::Cop::RangeHelp
  def on_in_pattern(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineInPatternThen
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMethodSignature
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  include ::RuboCop::Cop::CommentsHelp
  def on_if(node); end
  MSG_IF = ::T.let(nil, ::T.untyped)
  MSG_SINGLE_LINE = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison_lhs(param0=T.unsafe(nil)); end

  def simple_comparison_rhs(param0=T.unsafe(nil)); end

  def simple_double_comparison?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_casgn(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(param0=T.unsafe(nil)); end

  def splat_value(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
end

module RuboCop::Cop::Style::MutableConstant::ShareableConstantValue
  def self.magic_comment_in_scope(node); end

  def self.recent_shareable_value?(node); end
end

class RuboCop::Cop::Style::MutableConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  include ::RuboCop::Cop::RangeHelp
  def double_negation?(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedFileDirname
  include ::RuboCop::Cop::RangeHelp
  def file_dirname?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedFileDirname
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedTernaryOperator
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def nil_check?(param0=T.unsafe(nil)); end

  def nil_comparison?(param0=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilLambda
  include ::RuboCop::Cop::RangeHelp
  def nil_return?(param0=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(param0=T.unsafe(nil)); end

  def not_and_nil_check?(param0=T.unsafe(nil)); end

  def not_equal_to_nil?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(param0=T.unsafe(nil)); end
  MSG_FOR_REDUNDANCY = ::T.let(nil, ::T.untyped)
  MSG_FOR_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumberedParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_numblock(node); end
  MSG_DISALLOW = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParameters
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::NumberedParametersLimit
  def max=(value); end

  def on_numblock(node); end
  DEFAULT_MAX_VALUE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParametersLimit
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::IntegerNode
  include ::RuboCop::Cop::AllowedPattern
  def min_digits=(value); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def comparison(param0=T.unsafe(nil)); end

  def inverted_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ObjectThen
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_csend(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ObjectThen
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG_MULTILINE = ::T.let(nil, ::T.untyped)
  MSG_SUFFIX = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OpenStructUse
  def on_const(node); end

  def uses_open_struct?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OpenStructUse
end

class RuboCop::Cop::Style::OperatorMethodCall
  def on_send(node); end
  INVALID_SYNTAX_ARG_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OperatorMethodCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  include ::RuboCop::Cop::AllowedMethods
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(param0=T.unsafe(nil)); end

  def unless_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def implicit_self_getter?(param0=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  def accesses?(rhs, lhs); end

  def dependencies_for_assignment(assignment); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(param0, param1, param2); end

  def tsort(); end

  def uses_var?(param0, param1); end

  def var_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, rhs, modifier, config, new_elements); end

  def node(); end

  def rescue_result(); end

  def rhs(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  include ::RuboCop::Cop::RangeHelp
  def control_op_condition(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_back_ref(node); end

  def on_gvar(node); end

  def on_nth_ref(node); end
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def proc_new?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::QuotedSymbols
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SymbolHelp
  include ::RuboCop::Cop::StringLiteralsHelp
  def on_sym(node); end
  MSG_DOUBLE = ::T.let(nil, ::T.untyped)
  MSG_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::QuotedSymbols
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  ACCEPTABLE_ARG_TYPES = ::T.let(nil, ::T.untyped)
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(param0=T.unsafe(nil)); end

  def rand_op_integer?(param0=T.unsafe(nil)); end

  def random_call(param0=T.unsafe(nil)); end

  def to_int(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantArgument
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NO_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantArrayConstructor
  def on_send(node); end

  def redundant_array_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArrayConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantArrayFlatten
  def flatten_join?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArrayFlatten
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantBegin
  include ::RuboCop::Cop::RangeHelp
  def offensive_kwbegins(param0); end

  def on_block(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_itblock(node); end

  def on_kwbegin(node); end

  def on_numblock(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  ARGUMENT_WITH_OPERATOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def on_if(node); end

  def redundant_condition?(param0=T.unsafe(nil)); end

  def redundant_condition_inverted?(param0=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantConstantBase
  def on_cbase(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConstantBase
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCurrentDirectoryInPath
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  CURRENT_DIRECTORY_PREFIX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CURRENT_DIRECTORY_PREFIX = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCurrentDirectoryInPath
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces
  def on_hash(node); end
  MERGE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantEach
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantEach
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantException
  def compact?(param0=T.unsafe(nil)); end

  def exploded?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFetchBlock
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def rails_cache?(param0=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFilterChain
  def on_csend(node); end

  def on_send(node); end

  def select_predicate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RAILS_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFilterChain
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFormat
  def complex_number?(param0=T.unsafe(nil)); end

  def find_hash_value_node(param0, param1); end

  def format_without_additional_args?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rational_number?(param0=T.unsafe(nil)); end

  def splatted_arguments?(param0=T.unsafe(nil)); end
  ACCEPTABLE_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFormat
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def on_send(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInitialize
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  def initialize_forwards?(param0=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInitialize
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInterpolationUnfreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolationUnfreeze
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::RedundantLineContinuation
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
  ALLOWED_STRING_TOKENS = ::T.let(nil, ::T.untyped)
  ARGUMENT_TAKING_FLOW_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ARITHMETIC_OPERATOR_TOKENS = ::T.let(nil, ::T.untyped)
  LINE_CONTINUATION = ::T.let(nil, ::T.untyped)
  LINE_CONTINUATION_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantLineContinuation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def allowed_pin_operator?(param0=T.unsafe(nil)); end

  def first_send_argument?(param0=T.unsafe(nil)); end

  def first_super_argument?(param0=T.unsafe(nil)); end

  def first_yield_argument?(param0=T.unsafe(nil)); end

  def interpolation?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def rescue?(param0=T.unsafe(nil)); end

  def square_brackets?(param0=T.unsafe(nil)); end
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantPercentQ
  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpArgument
  include ::RuboCop::Cop::StringLiteralsHelp
  def on_csend(node); end

  def on_send(node); end
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_SPECIAL_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  def on_regexp(node); end
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpConstructor
  def on_send(node); end

  def redundant_regexp_constructor(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  INTERPOLATION_SIGILS = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelf
  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end

  def on_in_pattern(node); end

  def on_itblock(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end

  def on_until(node); end

  def on_while(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_self_assignment?(param0=T.unsafe(nil), param1, param2); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  def bad_method?(param0=T.unsafe(nil)); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end

  def redundant_sort?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def redundant_sort_by_block(param0=T.unsafe(nil)); end

  def redundant_sort_by_itblock(param0=T.unsafe(nil)); end

  def redundant_sort_by_numblock(param0=T.unsafe(nil)); end
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_ITBLOCK = ::T.let(nil, ::T.untyped)
  MSG_NUMBLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantStringEscape
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantStringEscape
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RequireOrder
  include ::RuboCop::Cop::RangeHelp
  def if_inside_only_require(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RequireOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RescueNode
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_resbody(node); end

  def rescue_standard_error?(param0=T.unsafe(nil)); end

  def rescue_without_error_class?(param0=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(param0=T.unsafe(nil)); end

  def return_node?(param0=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def on_def(node); end

  def on_defs(node); end

  def return_nil?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNilInPredicateMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def and_inside_begin?(param0=T.unsafe(nil)); end

  def and_with_rhs_or?(param0=T.unsafe(nil)); end

  def modifier_if_safe_navigation_candidate(param0=T.unsafe(nil)); end

  def not_nil_check?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def strip_begin(param0=T.unsafe(nil)); end

  def ternary_safe_navigation_candidate(param0=T.unsafe(nil)); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SafeNavigationChainLength
  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigationChainLength
end

class RuboCop::Cop::Style::Sample
  def on_csend(node); end

  def on_send(node); end

  def sample_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SelectByRegexp
  include ::RuboCop::Cop::RangeHelp
  def calls_lvar?(param0=T.unsafe(nil), param1); end

  def creates_hash?(param0=T.unsafe(nil)); end

  def env_const?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def regexp_match?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  REGEXP_METHODS = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelectByRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SendWithLiteralMethodName
  def on_csend(node); end

  def on_send(node); end
  METHOD_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STATIC_METHOD_NAME_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SendWithLiteralMethodName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def custom_fail_methods(param0); end

  def kernel_call?(param0=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleArgumentDig
  include ::RuboCop::Cop::DigHelp
  def on_send(node); end
  IGNORED_ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineDoEndBlock
  include ::RuboCop::Cop::CheckSingleLineSuitability
  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineDoEndBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_csend(node); end

  def on_send(node); end

  def range_from_zero?(param0=T.unsafe(nil)); end

  def range_from_zero_till_minus_one?(param0=T.unsafe(nil)); end

  def range_till_minus_one?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_USELESS_RANGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SoleNestedConditional
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RequireLibrary
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
  BUILTIN_VARS = ::T.let(nil, ::T.untyped)
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
  STYLE_VARS_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StaticClass
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def stderr_puts?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringChars
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  BAD_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringChars
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(param0=T.unsafe(nil)); end

  def string_hash_key?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(corrector, node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def lstrip_rstrip(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StructInheritance
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def struct_constructor?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SuperArguments
  def on_super(super_node); end
  ASSIGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INLINE_BLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SuperArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SuperWithArgsParentheses
  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SuperWithArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SwapValues
  include ::RuboCop::Cop::RangeHelp
  def on_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  DELIMITERS = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
  REDEFINABLE_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_GVARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::AllowedPattern
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def proc_node?(param0=T.unsafe(nil)); end

  def symbol_proc?(param0=T.unsafe(nil)); end

  def symbol_proc_receiver?(param0=T.unsafe(nil)); end
  LAMBDA_OR_PROC = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def method_name(param0=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
  def define_method_block?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_itblock(node); end

  def on_numblock(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_class(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrivialAccessors
  include ::RuboCop::Cop::AllowedMethods
  def looks_like_trivial_writer?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnlessElse
  def on_if(node); end

  def range_between_condition_and_else(node); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnlessLogicalOperators
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def and_with_or?(param0=T.unsafe(nil)); end

  def logical_operator?(param0=T.unsafe(nil)); end

  def on_if(node); end

  def or_with_and?(param0=T.unsafe(nil)); end
  FORBID_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  FORBID_MIXED_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessLogicalOperators
end

class RuboCop::Cop::Style::UnpackFirst
  def on_csend(node); end

  def on_send(node); end

  def unpack_and_first_element?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YAMLFileRead
  def on_send(node); end

  def yaml_file_read?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YAMLFileRead
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_constant_equal_program_name?(param0=T.unsafe(nil)); end

  def on_send(node); end
  ENFORCE_YODA_STYLES = ::T.let(nil, ::T.untyped)
  EQUALITY_ONLY_STYLES = ::T.let(nil, ::T.untyped)
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::YodaExpression
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaExpression
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(param0=T.unsafe(nil)); end

  def nonzero_length_comparison(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def other_length_node(param0=T.unsafe(nil)); end

  def zero_length_comparison(param0=T.unsafe(nil)); end

  def zero_length_node(param0=T.unsafe(nil)); end

  def zero_length_predicate?(param0=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::SymbolHelp
  def hash_key?(node); end
end

module RuboCop::Cop::SymbolHelp
end

module RuboCop::Cop::TargetRubyVersion
  def maximum_target_ruby_version(version); end

  def minimum_target_ruby_version(version); end

  def required_maximum_ruby_version(); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source, offset: T.unsafe(nil), original: T.unsafe(nil)); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.any_descendant?(node, *types); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.indent(node, offset: T.unsafe(nil)); end

  def self.interpret_string_escapes(string); end

  def self.line(node_or_range); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.parse_regexp(text); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interpolation_escape_character(str); end
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  INTERPOLATION = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arg_number(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def variable_width?(); end

  def variable_width_argument_number(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::Utils::FormatString
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  PATTERN_MATCH_VARIABLE_TYPE = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  REST_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def exception_assignment?(); end

  def for_assignment?(); end

  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reassigned(); end

  def reassigned!(); end

  def reassigned?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def rest_assignment?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*arg); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch
  def else_body?(); end

  def in_pattern?(); end

  def target?(); end
end

class RuboCop::Cop::VariableForce::Branch::CaseMatch
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_conditional?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def mark_last_as_reassigned!(assignment); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(param0=T.unsafe(nil)); end

  def visibility_inline_on_def?(param0=T.unsafe(nil)); end

  def visibility_inline_on_method_name?(param0=T.unsafe(nil), method_name:); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop
end

class RuboCop::DirectiveComment
  def all_cops?(); end

  def comment(); end

  def cop_names(); end

  def cop_registry(); end

  def cops(); end

  def department_names(); end

  def directive_count(); end

  def disabled?(); end

  def disabled_all?(); end

  def enabled?(); end

  def enabled_all?(); end

  def in_directive_department?(cop); end

  def initialize(comment, cop_registry=T.unsafe(nil)); end

  def line_number(); end

  def malformed?(); end

  def match?(cop_names); end

  def match_captures(); end

  def missing_cop_name?(); end

  def mode(); end

  def overridden_by_department?(cop); end

  def pop?(); end

  def push?(); end

  def push_args(); end

  def range(); end

  def raw_cop_names(); end

  def single_line?(); end

  def start_with_marker?(); end
  AVAILABLE_MODES = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN_NC = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN_NC = ::T.let(nil, ::T.untyped)
  DIRECTIVE_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  DIRECTIVE_HEADER_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_MARKER_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_MARKER_REGEXP = ::T.let(nil, ::T.untyped)
  LINT_DEPARTMENT = ::T.let(nil, ::T.untyped)
  LINT_REDUNDANT_DIRECTIVE_COP = ::T.let(nil, ::T.untyped)
  LINT_SYNTAX_COP = ::T.let(nil, ::T.untyped)
  MALFORMED_DIRECTIVE_WITHOUT_COP_NAME_REGEXP = ::T.let(nil, ::T.untyped)
  PUSH_POP_ARGS_PATTERN = ::T.let(nil, ::T.untyped)
  TRAILING_COMMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  def self.before_comment(line); end
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::ExcludeLimit
  def exclude_limit(parameter_name, method_name: T.unsafe(nil)); end
end

module RuboCop::ExcludeLimit
end

module RuboCop::Ext
end

module RuboCop::Ext::Comment
  def source(); end

  def source_range(); end
end

module RuboCop::Ext::Comment
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def config(); end

  def config=(config); end

  def disabled_line_ranges(); end

  def registry(); end

  def registry=(registry); end
end

module RuboCop::Ext::ProcessedSource
end

module RuboCop::Ext::Range
  def single_line?(); end
end

module RuboCop::Ext::Range
end

module RuboCop::Ext::RegexpNode
  def assign_properties(*arg); end

  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpNode
end

module RuboCop::Ext::RegexpParser
end

module RuboCop::Ext::RegexpParser::Expression
end

module RuboCop::Ext::RegexpParser::Expression::Base
  def expression(); end

  def loc(); end

  def origin(); end

  def origin=(origin); end
end

module RuboCop::Ext::RegexpParser::Expression::Base
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
  def build_location(); end
end

module RuboCop::Ext::RegexpParser::Expression::CharacterSet
end

module RuboCop::Ext::RegexpParser::Expression
end

class RuboCop::Ext::RegexpParser::Map
  def begin(); end

  def body(); end

  def end(); end

  def initialize(expression, body:, quantifier: T.unsafe(nil), begin_l: T.unsafe(nil), end_l: T.unsafe(nil)); end

  def quantifier(); end
end

class RuboCop::Ext::RegexpParser::Map
end

module RuboCop::Ext::RegexpParser
end

module RuboCop::Ext
end

class RuboCop::FeatureLoader
  def initialize(config_directory_path:, feature:); end

  def load(); end
end

class RuboCop::FeatureLoader
  def self.load(config_directory_path:, feature:); end
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def traverse_directories_upwards(start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level(); end

  def self.root_level=(root_level); end
end

class RuboCop::FilePatterns
  def initialize(patterns); end

  def match?(path); end
end

class RuboCop::FilePatterns
  def self.from(patterns); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  include ::RuboCop::PathUtil
  def file_started(_file, options); end

  def finished(_inspected_files); end
  EXCLUDED_CONFIG_KEYS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  BUILTIN_FORMATTER_NAMES = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::GitHubActionsFormatter
  def finished(_inspected_files); end

  def started(_target_files); end
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  CSS_PATH = ::T.let(nil, ::T.untyped)
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::CSSContext
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::CSSContext
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlight_source_tag(offense); end

  def highlighted_source_line(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def render_css(); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def offenses(); end

  def offenses=(_); end

  def path(); end

  def path=(_); end
end

class RuboCop::Formatter::HTMLFormatter::FileOffenses
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def inspected_files(); end

  def inspected_files=(_); end

  def offense_count(); end

  def offense_count=(_); end

  def target_files(); end

  def target_files=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Summary
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def finished(_inspected_files); end
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::JUnitFormatter::FailureElement
  def initialize(type:, message:, text:); end

  def message(); end

  def text(); end

  def type(); end
end

class RuboCop::Formatter::JUnitFormatter::FailureElement
end

class RuboCop::Formatter::JUnitFormatter::TestCaseElement
  def classname(); end

  def failures(); end

  def initialize(classname:, name:); end

  def name(); end
end

class RuboCop::Formatter::JUnitFormatter::TestCaseElement
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::MarkdownFormatter
  include ::RuboCop::Formatter::TextUtil
  include ::RuboCop::PathUtil
  def files(); end

  def summary(); end
end

class RuboCop::Formatter::MarkdownFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def cop_information(cop_name); end

  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts, offending_files_count); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_autocorrect: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

module RuboCop::LSP
end

module RuboCop::LSP
  def self.disable(&block); end

  def self.enable(); end

  def self.enabled?(); end
end

class RuboCop::Lockfile
  def dependencies(); end

  def gem_versions(include_transitive_dependencies: T.unsafe(nil)); end

  def gems(); end

  def includes_gem?(name); end

  def initialize(lockfile_path=T.unsafe(nil)); end
end

class RuboCop::Lockfile
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def rbs_inline_specified?(); end

  def shareable_constant_value(); end

  def shareable_constant_value_specified?(); end

  def typed(); end

  def typed_specified?(); end

  def valid?(); end

  def valid_literal_value?(); end

  def valid_rbs_inline_value?(); end

  def valid_shareable_constant_value?(); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
  def encoding(); end

  def without(type); end
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def new_frozen_string_literal(value); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end

  def new_frozen_string_literal(value); end

  def without(type); end
  FSTRING_LITERAL_COMMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def extract_rbs_inline_value(); end

  def extract_typed(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def disable_parallel_when_invalid_option_combo(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def invalid_arguments_for_parallel(); end

  def only_includes_redundant_disable?(); end

  def validate_auto_gen_config(); end

  def validate_autocorrect(); end

  def validate_cache_enabled_for_cache_root(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_correctable_and_autocorrect(); end

  def validate_display_only_failed(); end

  def validate_display_only_failed_and_display_only_correctable(); end

  def validate_exclude_limit_option(); end

  def validate_lsp_and_editor_mode(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
  HIDDEN_FILE_PATTERN = ::T.let(nil, ::T.untyped)
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.glob?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.relative_paths_cache(); end

  def self.relative_paths_cache=(relative_paths_cache); end

  def self.remote_file?(uri); end

  def self.smart_path(path); end
end

class RuboCop::PendingCopsReporter
end

class RuboCop::PendingCopsReporter
  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.warn_if_needed(config); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

module RuboCop::Plugin
  BUILTIN_INTERNAL_PLUGINS = ::T.let(nil, ::T.untyped)
  INTERNAL_AFFAIRS_PLUGIN_NAME = ::T.let(nil, ::T.untyped)
  OBSOLETE_INTERNAL_AFFAIRS_PLUGIN_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Plugin::ConfigurationIntegrator
end

class RuboCop::Plugin::ConfigurationIntegrator
  def self.integrate_plugins_into_rubocop_config(rubocop_config, plugins); end
end

class RuboCop::Plugin::LoadError
  def initialize(plugin_name); end
end

class RuboCop::Plugin::LoadError
end

class RuboCop::Plugin::Loader
  DEFAULT_PLUGIN_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Plugin::Loader
  def self.load(plugins); end
end

class RuboCop::Plugin::NotSupportedError
  def initialize(unsupported_plugins); end
end

class RuboCop::Plugin::NotSupportedError
end

module RuboCop::Plugin
  def self.integrate_plugins(rubocop_config, plugins); end

  def self.plugin_capable?(feature_name); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file); end

  def initialize(url, cache_root); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def debug?(); end

  def initialize(file, team, options, config_store, cache_root_override=T.unsafe(nil)); end

  def load(); end

  def path(); end

  def save(offenses); end

  def valid?(); end
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store, cache_root_override=T.unsafe(nil)); end

  def self.cleanup(config_store, verbose, cache_root_override=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.rubocop_required_features(); end

  def self.rubocop_required_features=(rubocop_required_features); end

  def self.source_checksum(); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
  REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
  def self.ruby_extractors(); end
end

module RuboCop::SimpleForwardable
  def def_delegators(accessor, *methods); end
end

module RuboCop::SimpleForwardable
end

class RuboCop::StringInterpreter
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def find(args, mode); end

  def find_files(base_dir, flags); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::GemspecFile
  def gem_requirement_versions(param0=T.unsafe(nil)); end

  def required_ruby_version(param0); end
end

class RuboCop::TargetRuby::GemspecFile
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopEnvVar
end

class RuboCop::TargetRuby::RuboCopEnvVar
end

class RuboCop::TargetRuby::RubyVersionFile
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby::ToolVersionsFile
  TOOL_VERSIONS_FILENAME = ::T.let(nil, ::T.untyped)
  TOOL_VERSIONS_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::ToolVersionsFile
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Util
end

module RuboCop::Util
  def self.silence_warnings(); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  EXTENSION_PATH_NAMES = ::T.let(nil, ::T.untyped)
  MINIMUM_PARSABLE_PRISM_VERSION = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.config_for_pwd(env); end

  def self.document_version(); end

  def self.extension_versions(env); end

  def self.feature_version(feature); end

  def self.parser_version(target_ruby_version); end

  def self.server_mode(); end

  def self.target_ruby_version(env); end

  def self.verbose(env: T.unsafe(nil)); end

  def self.version(debug: T.unsafe(nil), env: T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

class RuboCop::YAMLDuplicationChecker::DuplicationCheckHandler
  def initialize(&block); end
end

class RuboCop::YAMLDuplicationChecker::DuplicationCheckHandler
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyLsp
  VERSION = ::T.let(nil, ::T.untyped)
end

module RubyLsp
end

class RubyVM::AbstractSyntaxTree::Location
  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end
end

class RubyVM::AbstractSyntaxTree::Location
end

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def locations(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

class RubyVM::InstructionSequence
  def self.compile_file_prism(*arg); end

  def self.compile_parsey(*arg); end

  def self.compile_prism(*arg); end
end

module RubyVM::RJIT
end

module RubyVM::RJIT
  def self.enable(); end

  def self.enabled?(); end
end

module RubyVM::YJIT
  def self.disasm(iseq); end

  def self.exit_locations(); end

  def self.insns_compiled(iseq); end

  def self.log_enabled?(); end

  def self.simulate_oom!(); end

  def self.trace_exit_locations_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

ScanError = StringScanner::Error

module SecureRandom
  VERSION = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sexp
  def /(pattern); end

  def ==(obj); end

  def =~(pattern); end

  def _concat(*arg); end

  def array_type?(); end

  def comments(); end

  def comments=(comments); end

  def deep_each(&block); end

  def depth(); end

  def each_of_type(t, &b); end

  def each_sexp(); end

  def eql?(o); end

  def file(); end

  def file=(file); end

  def find_and_replace_all(from, to); end

  def find_node(name, delete=T.unsafe(nil)); end

  def find_nodes(name); end

  def gsub(pattern, repl); end

  def head(); end

  def initialize(*args); end

  def line(n=T.unsafe(nil)); end

  def line=(line); end

  def line_max(); end

  def line_max=(line_max); end

  def map(&blk); end

  def mass(); end

  def method_missing(meth, delete=T.unsafe(nil)); end

  def new(*body); end

  def replace_sexp(pattern, &block); end

  def respond_to?(msg, private=T.unsafe(nil)); end

  def rest(from=T.unsafe(nil)); end

  def satisfy?(pattern); end

  def search_each(pattern, &block); end

  def sexp_body(from=T.unsafe(nil)); end

  def sexp_body=(v); end

  def sexp_type(); end

  def sexp_type=(v); end

  def structure(); end

  def sub(pattern, repl); end

  def value(); end
  UNASSIGNED = ::T.let(nil, ::T.untyped)
end

class Sexp::All
  def ==(o); end

  def initialize(*options); end

  def options(); end
end

class Sexp::All
end

class Sexp::Any
  def ==(o); end

  def initialize(*options); end

  def options(); end
end

class Sexp::Any
end

class Sexp::Atom
end

class Sexp::Atom
end

class Sexp::Child
  def ==(o); end

  def child(); end

  def initialize(child); end
end

class Sexp::Child
end

class Sexp::Include
  def ==(o); end

  def initialize(value); end
end

class Sexp::Include
end

class Sexp::Klass
end

class Sexp::Klass
end

class Sexp::MatchCollection
  def /(pattern); end
end

class Sexp::MatchCollection
end

class Sexp::Matcher
  def &(other); end

  def -@(); end

  def /(sexp); end

  def ===(sexp); end

  def =~(sexp); end

  def >>(other); end

  def greedy?(); end

  def satisfy?(o); end

  def |(other); end
end

class Sexp::Matcher::Parser
  def initialize(s); end

  def lex(s); end

  def next_token(); end

  def parse(); end

  def parse_cmd(); end

  def parse_list(); end

  def parse_sexp(); end

  def peek_token(); end

  def tokens(); end

  def tokens=(tokens); end
  ALLOWED = ::T.let(nil, ::T.untyped)
end

class Sexp::Matcher::Parser
end

class Sexp::Matcher
  def self.match_subs=(o); end

  def self.match_subs?(); end

  def self.parse(s); end
end

class Sexp::Not
  def ==(o); end

  def initialize(value); end
end

class Sexp::Not
end

class Sexp::Pattern
  def ==(o); end

  def initialize(pattern); end

  def pattern(); end
end

class Sexp::Pattern
end

class Sexp::Remaining
end

class Sexp::Remaining
end

class Sexp::Sibling
  def ==(o); end

  def distance(); end

  def initialize(subject, sibling, distance=T.unsafe(nil)); end

  def sibling(); end

  def subject(); end
end

class Sexp::Sibling
end

class Sexp::Type
  def ==(o); end

  def initialize(type); end
end

class Sexp::Type
end

class Sexp::Wild
end

class Sexp::Wild
end

class Sexp
  def self.-(arg); end

  def self._(); end

  def self.___(); end

  def self.all(*args); end

  def self.any(*args); end

  def self.atom(); end

  def self.child(child); end

  def self.from_array(a); end

  def self.include(child); end

  def self.k(klass); end

  def self.m(*values); end

  def self.not?(arg); end

  def self.q(*args); end

  def self.s(*args); end

  def self.t(name); end
end

class SexpInterpreter
end

class SexpInterpreter
end

class SexpProcessor
  def assert_empty(meth, exp, exp_orig); end

  def assert_type(list, typ); end

  def auto_shift_type(); end

  def auto_shift_type=(auto_shift_type); end

  def context(); end

  def debug(); end

  def debug=(debug); end

  def default_method(); end

  def default_method=(default_method); end

  def env(); end

  def error_handler(type, exp=T.unsafe(nil)); end

  def expected(); end

  def expected=(expected); end

  def in_context(type); end

  def on_error_in(node_type, &block); end

  def process(exp); end

  def process_dummy(exp); end

  def require_empty(); end

  def require_empty=(require_empty); end

  def rewrite(exp); end

  def scope(&block); end

  def strict(); end

  def strict=(strict); end

  def unsupported(); end

  def unsupported=(unsupported); end

  def warn_on_default(); end

  def warn_on_default=(warn_on_default); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SexpProcessor::Environment
  def [](name); end

  def []=(name, val); end

  def all(); end

  def current(); end

  def depth(); end

  def scope(); end
end

class SexpProcessor::Environment
end

class SexpProcessor
  def self.expand_dirs_to_files(*dirs); end

  def self.processors(); end

  def self.rewriters(); end
end

class SexpProcessorError
end

class SexpProcessorError
end

class SexpTypeError
end

class SexpTypeError
end

module Shellwords
  VERSION = ::T.let(nil, ::T.untyped)
end

module SimpleCov
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ArrayFilter
  def matches?(source_files_list); end
end

class SimpleCov::ArrayFilter
end

class SimpleCov::BlockFilter
  def matches?(source_file); end
end

class SimpleCov::BlockFilter
end

module SimpleCov::Combine
end

module SimpleCov::Combine::BranchesCombiner
end

module SimpleCov::Combine::BranchesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::FilesCombiner
end

module SimpleCov::Combine::FilesCombiner
  def self.combine(coverage_a, coverage_b); end
end

module SimpleCov::Combine::LinesCombiner
end

module SimpleCov::Combine::LinesCombiner
  def self.combine(coverage_a, coverage_b); end

  def self.merge_line_coverage(first_val, second_val); end
end

module SimpleCov::Combine::ResultsCombiner
end

module SimpleCov::Combine::ResultsCombiner
  def self.combine(*results); end

  def self.combine_file_coverage(coverage_a, coverage_b); end

  def self.combine_result_sets(combined_results, result); end
end

module SimpleCov::Combine
  def self.combine(combiner_module, coverage_a, coverage_b); end

  def self.empty_coverage?(coverage_a, coverage_b); end

  def self.existing_coverage(coverage_a, coverage_b); end
end

module SimpleCov::CommandGuesser
end

module SimpleCov::CommandGuesser
  def self.guess(); end

  def self.original_run_command(); end

  def self.original_run_command=(original_run_command); end
end

module SimpleCov::Configuration
  def adapters(); end

  def add_filter(filter_argument=T.unsafe(nil), &filter_proc); end

  def add_group(group_name, filter_argument=T.unsafe(nil), &filter_proc); end

  def at_exit(&block); end

  def at_fork(&block); end

  def branch_coverage?(); end

  def branch_coverage_supported?(); end

  def clear_coverage_criteria(); end

  def command_name(name=T.unsafe(nil)); end

  def configure(&block); end

  def coverage_criteria(); end

  def coverage_criterion(criterion=T.unsafe(nil)); end

  def coverage_criterion_enabled?(criterion); end

  def coverage_dir(dir=T.unsafe(nil)); end

  def coverage_for_eval_enabled?(); end

  def coverage_for_eval_supported?(); end

  def coverage_path(); end

  def coverage_start_arguments_supported?(); end

  def enable_coverage(criterion); end

  def enable_coverage_for_eval(); end

  def enable_for_subprocesses(value=T.unsafe(nil)); end

  def enabled_for_subprocesses?(); end

  def filters(); end

  def filters=(filters); end

  def formatter(formatter=T.unsafe(nil)); end

  def formatter=(formatter); end

  def formatters(); end

  def formatters=(formatters); end

  def groups(); end

  def groups=(groups); end

  def maximum_coverage_drop(coverage_drop=T.unsafe(nil)); end

  def merge_timeout(seconds=T.unsafe(nil)); end

  def minimum_coverage(coverage=T.unsafe(nil)); end

  def minimum_coverage_by_file(coverage=T.unsafe(nil)); end

  def nocov_token(nocov_token=T.unsafe(nil)); end

  def primary_coverage(criterion=T.unsafe(nil)); end

  def print_error_status(); end

  def print_error_status=(print_error_status); end

  def profiles(); end

  def project_name(new_name=T.unsafe(nil)); end

  def raise_on_invalid_coverage(coverage, coverage_setting); end

  def refuse_coverage_drop(*criteria); end

  def root(root=T.unsafe(nil)); end

  def skip_token(nocov_token=T.unsafe(nil)); end

  def track_files(glob); end

  def tracked_files(); end

  def use_merging(use=T.unsafe(nil)); end
  DEFAULT_COVERAGE_CRITERION = ::T.let(nil, ::T.untyped)
  SUPPORTED_COVERAGE_CRITERIA = ::T.let(nil, ::T.untyped)
end

module SimpleCov::Configuration
end

class SimpleCov::CoverageStatistics
  def covered(); end

  def initialize(covered:, missed:, total_strength: T.unsafe(nil)); end

  def missed(); end

  def percent(); end

  def strength(); end

  def total(); end
end

class SimpleCov::CoverageStatistics
  def self.from(coverage_statistics); end
end

module SimpleCov::ExitCodes
  EXCEPTION = ::T.let(nil, ::T.untyped)
  MAXIMUM_COVERAGE_DROP = ::T.let(nil, ::T.untyped)
  MINIMUM_COVERAGE = ::T.let(nil, ::T.untyped)
  SUCCESS = ::T.let(nil, ::T.untyped)
end

module SimpleCov::ExitCodes::ExitCodeHandling
end

module SimpleCov::ExitCodes::ExitCodeHandling
  def self.call(result, coverage_limits:); end

  def self.coverage_checks(result, coverage_limits); end
end

class SimpleCov::ExitCodes::MaximumCoverageDropCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, maximum_coverage_drop); end

  def report(); end
  MAX_DROP_ACCURACY = ::T.let(nil, ::T.untyped)
end

class SimpleCov::ExitCodes::MaximumCoverageDropCheck
end

class SimpleCov::ExitCodes::MinimumCoverageByFileCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage_by_file); end

  def report(); end
end

class SimpleCov::ExitCodes::MinimumCoverageByFileCheck
end

class SimpleCov::ExitCodes::MinimumOverallCoverageCheck
  def exit_code(); end

  def failing?(); end

  def initialize(result, minimum_coverage); end

  def report(); end
end

class SimpleCov::ExitCodes::MinimumOverallCoverageCheck
end

module SimpleCov::ExitCodes
end

class SimpleCov::FileList
  include ::Enumerable
  def branch_covered_percent(); end

  def count(*args, **arg, &block); end

  def coverage_statistics(); end

  def coverage_statistics_by_file(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_percentages(); end

  def covered_strength(); end

  def each(*args, **arg, &block); end

  def empty?(*args, **arg, &block); end

  def initialize(files); end

  def least_covered_file(); end

  def length(*args, **arg, &block); end

  def lines_of_code(); end

  def map(*args, **arg, &block); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def size(*args, **arg, &block); end

  def skipped_lines(); end

  def to_a(*args, **arg, &block); end

  def to_ary(*args, **arg, &block); end

  def total_branches(); end
end

class SimpleCov::FileList
  extend ::Forwardable
end

class SimpleCov::Filter
  def filter_argument(); end

  def initialize(filter_argument); end

  def matches?(_source_file); end

  def passes?(source_file); end
end

class SimpleCov::Filter
  def self.build_filter(filter_argument); end

  def self.class_for_argument(filter_argument); end
end

module SimpleCov::Formatter
end

class SimpleCov::Formatter::HTMLFormatter
  def format(result); end
  CONTENT_TYPES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class SimpleCov::Formatter::HTMLFormatter
end

class SimpleCov::Formatter::JSONFormatter
  def format(result); end
end

class SimpleCov::Formatter::JSONFormatter
end

class SimpleCov::Formatter::MultiFormatter
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
  def format(result); end
end

module SimpleCov::Formatter::MultiFormatter::InstanceMethods
end

class SimpleCov::Formatter::MultiFormatter
  def self.[](*args); end

  def self.new(formatters=T.unsafe(nil)); end
end

class SimpleCov::Formatter::SimpleFormatter
  def format(result); end
end

class SimpleCov::Formatter::SimpleFormatter
end

module SimpleCov::Formatter
  def self.from_env(env); end
end

module SimpleCov::LastRun
end

module SimpleCov::LastRun
  def self.last_run_path(); end

  def self.read(); end

  def self.write(json); end
end

class SimpleCov::LinesClassifier
  def classify(lines); end
  COMMENT_LINE = ::T.let(nil, ::T.untyped)
  NOT_RELEVANT = ::T.let(nil, ::T.untyped)
  RELEVANT = ::T.let(nil, ::T.untyped)
  WHITESPACE_LINE = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_COMMENT_LINE = ::T.let(nil, ::T.untyped)
end

class SimpleCov::LinesClassifier
  def self.no_cov_line(); end

  def self.no_cov_line?(line); end

  def self.whitespace_line?(line); end
end

class SimpleCov::Profiles
  def define(name, &blk); end

  def load(name); end
end

class SimpleCov::Profiles
end

class SimpleCov::RegexFilter
  def matches?(source_file); end
end

class SimpleCov::RegexFilter
end

class SimpleCov::Result
  def command_name(); end

  def command_name=(command_name); end

  def coverage_statistics(*args, **arg, &block); end

  def coverage_statistics_by_file(*args, **arg, &block); end

  def covered_branches(*args, **arg, &block); end

  def covered_lines(*args, **arg, &block); end

  def covered_percent(*args, **arg, &block); end

  def covered_percentages(*args, **arg, &block); end

  def covered_strength(*args, **arg, &block); end

  def created_at(); end

  def created_at=(created_at); end

  def filenames(); end

  def files(); end

  def format!(); end

  def groups(); end

  def initialize(original_result, command_name: T.unsafe(nil), created_at: T.unsafe(nil)); end

  def least_covered_file(*args, **arg, &block); end

  def missed_branches(*args, **arg, &block); end

  def missed_lines(*args, **arg, &block); end

  def original_result(); end

  def source_files(); end

  def to_hash(); end

  def total_branches(*args, **arg, &block); end

  def total_lines(*args, **arg, &block); end
end

class SimpleCov::Result
  extend ::Forwardable
  def self.from_hash(hash); end
end

class SimpleCov::ResultAdapter
  def adapt(); end

  def initialize(result); end

  def result(); end
end

class SimpleCov::ResultAdapter
  def self.call(*args); end
end

module SimpleCov::ResultMerger
end

module SimpleCov::ResultMerger
  def self.adapt_pre_simplecov_0_18_result(result); end

  def self.adapt_result(result); end

  def self.create_result(command_names, coverage); end

  def self.merge_and_store(*file_paths, ignore_timeout: T.unsafe(nil)); end

  def self.merge_coverage(*results); end

  def self.merge_results(*file_paths, ignore_timeout: T.unsafe(nil)); end

  def self.merge_valid_results(results, ignore_timeout: T.unsafe(nil)); end

  def self.merged_result(); end

  def self.parse_file(path); end

  def self.parse_json(content); end

  def self.pre_simplecov_0_18_result?(result); end

  def self.read_file(path); end

  def self.read_resultset(); end

  def self.resultset_path(); end

  def self.resultset_writelock(); end

  def self.store_result(result); end

  def self.synchronize_resultset(); end

  def self.time_since_result_creation(data); end

  def self.valid_results(file_path, ignore_timeout: T.unsafe(nil)); end

  def self.within_merge_timeout?(data); end
end

module SimpleCov::SimulateCoverage
end

module SimpleCov::SimulateCoverage
  def self.call(absolute_path); end
end

class SimpleCov::SourceFile
  def branches(); end

  def branches_coverage_percent(); end

  def branches_for_line(line_number); end

  def branches_report(); end

  def coverage_data(); end

  def coverage_statistics(); end

  def covered_branches(); end

  def covered_lines(); end

  def covered_percent(); end

  def covered_strength(); end

  def filename(); end

  def initialize(filename, coverage_data); end

  def line(number); end

  def line_with_missed_branch?(line_number); end

  def lines(); end

  def lines_of_code(); end

  def missed_branches(); end

  def missed_lines(); end

  def never_lines(); end

  def no_branches?(); end

  def no_lines?(); end

  def project_filename(); end

  def relevant_lines(); end

  def skipped_lines(); end

  def source(); end

  def source_lines(); end

  def src(); end

  def total_branches(); end
  RUBY_FILE_ENCODING_MAGIC_COMMENT_REGEX = ::T.let(nil, ::T.untyped)
  SHEBANG_REGEX = ::T.let(nil, ::T.untyped)
end

class SimpleCov::SourceFile::Branch
  def coverage(); end

  def covered?(); end

  def end_line(); end

  def initialize(start_line:, end_line:, coverage:, inline:, type:); end

  def inline?(); end

  def missed?(); end

  def overlaps_with?(line_range); end

  def report(); end

  def report_line(); end

  def skipped!(); end

  def skipped?(); end

  def start_line(); end

  def type(); end
end

class SimpleCov::SourceFile::Branch
end

class SimpleCov::SourceFile::Line
  def coverage(); end

  def covered?(); end

  def initialize(src, line_number, coverage); end

  def line(); end

  def line_number(); end

  def missed?(); end

  def never?(); end

  def number(); end

  def skipped(); end

  def skipped!(); end

  def skipped?(); end

  def source(); end

  def src(); end

  def status(); end
end

class SimpleCov::SourceFile::Line
end

class SimpleCov::SourceFile
end

class SimpleCov::StringFilter
  def matches?(source_file); end
end

class SimpleCov::StringFilter
end

module SimpleCov::UselessResultsRemover
end

module SimpleCov::UselessResultsRemover
  def self.call(coverage_result); end

  def self.root_regx(); end
end

module SimpleCov
  extend ::SimpleCov::Configuration
  def self.at_exit_behavior(); end

  def self.clear_result(); end

  def self.collate(result_filenames, profile=T.unsafe(nil), ignore_timeout: T.unsafe(nil), &block); end

  def self.exit_and_report_previous_error(exit_status); end

  def self.exit_status_from_exception(); end

  def self.external_at_exit(); end

  def self.external_at_exit=(external_at_exit); end

  def self.external_at_exit?(); end

  def self.filtered(files); end

  def self.final_result_process?(); end

  def self.grouped(files); end

  def self.load_adapter(name); end

  def self.load_profile(name); end

  def self.pid(); end

  def self.pid=(pid); end

  def self.previous_error?(error_exit_status); end

  def self.process_result(result); end

  def self.process_results_and_report_error(); end

  def self.ready_to_process_results?(); end

  def self.result(); end

  def self.result?(); end

  def self.result_exit_status(result); end

  def self.round_coverage(coverage); end

  def self.run_exit_tasks!(); end

  def self.running(); end

  def self.running=(running); end

  def self.start(profile=T.unsafe(nil), &block); end

  def self.wait_for_other_processes(); end

  def self.write_last_run(result); end
end

module SimpleCovJSONFormatter
end

class SimpleCovJSONFormatter::ResultExporter
  def export(); end

  def initialize(result_hash); end
  FILENAME = ::T.let(nil, ::T.untyped)
end

class SimpleCovJSONFormatter::ResultExporter
end

class SimpleCovJSONFormatter::ResultHashFormatter
  def format(); end

  def initialize(result); end
end

class SimpleCovJSONFormatter::ResultHashFormatter
end

class SimpleCovJSONFormatter::SourceFileFormatter
  def format(); end

  def initialize(source_file); end
end

class SimpleCovJSONFormatter::SourceFileFormatter
end

module SimpleCovJSONFormatter
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassProperties
  def __init__(klass); end
end

module Singleton::SingletonClassProperties
  def self.extended(c); end

  def self.included(c); end
end

module Singleton::SingletonInstanceMethods
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton
  extend ::Singleton::SingletonClassProperties
  def self.module_with_class_methods(); end
end

class Socket
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_MTU_DISCOVER = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVERR = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_ALG = ::T.let(nil, ::T.untyped)
  AF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  AF_CAN = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_IB = ::T.let(nil, ::T.untyped)
  AF_KCM = ::T.let(nil, ::T.untyped)
  AF_KEY = ::T.let(nil, ::T.untyped)
  AF_LLC = ::T.let(nil, ::T.untyped)
  AF_MPLS = ::T.let(nil, ::T.untyped)
  AF_NETLINK = ::T.let(nil, ::T.untyped)
  AF_PPPOX = ::T.let(nil, ::T.untyped)
  AF_RDS = ::T.let(nil, ::T.untyped)
  AF_TIPC = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AF_XDP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_MTU_DISCOVER = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVERR = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  PF_ALG = ::T.let(nil, ::T.untyped)
  PF_BLUETOOTH = ::T.let(nil, ::T.untyped)
  PF_CAN = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_IB = ::T.let(nil, ::T.untyped)
  PF_KCM = ::T.let(nil, ::T.untyped)
  PF_LLC = ::T.let(nil, ::T.untyped)
  PF_MPLS = ::T.let(nil, ::T.untyped)
  PF_NETLINK = ::T.let(nil, ::T.untyped)
  PF_PPPOX = ::T.let(nil, ::T.untyped)
  PF_RDS = ::T.let(nil, ::T.untyped)
  PF_TIPC = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XDP = ::T.let(nil, ::T.untyped)
  SOCK_CLOEXEC = ::T.let(nil, ::T.untyped)
  SOCK_NONBLOCK = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
  SO_INCOMING_CPU = ::T.let(nil, ::T.untyped)
  SO_INCOMING_NAPI_ID = ::T.let(nil, ::T.untyped)
end

class Socket::ResolutionError
  def error_code(); end
end

class Socket
  def self.tcp_fast_fallback(); end

  def self.tcp_fast_fallback=(tcp_fast_fallback); end

  def self.tcp_with_fast_fallback(host, port, local_host=T.unsafe(nil), local_port=T.unsafe(nil), connect_timeout: T.unsafe(nil), resolv_timeout: T.unsafe(nil)); end
end

class String
  def append_as_bytes(*arg); end

  def blank?(); end

  def dedup(); end

  def ext(newext=T.unsafe(nil)); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def shell_split(); end
end

class String
  def self.new(*arg); end
end

class StringIO
  def pread(*arg); end

  def set_encoding_by_bom(); end
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end

  def named_captures(); end

  def peek_byte(); end

  def scan_byte(); end

  def scan_integer(base: T.unsafe(nil)); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct::UnameStruct
  def domainname(); end

  def domainname=(_); end

  def machine(); end

  def machine=(_); end

  def nodename(); end

  def nodename=(_); end

  def release(); end

  def release=(_); end

  def sysname(); end

  def sysname=(_); end

  def version(); end

  def version=(_); end
end

class Struct::UnameStruct
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Struct
  def self.new(*arg); end
end

class SymbolHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def initialize(symbolize_value=T.unsafe(nil)); end

  def key?(key); end

  def merge(hash); end

  def merge!(hash); end

  def update(hash); end
end

class SymbolHash
  def self.[](*hsh); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module Sys
end

class Sys::Platform
  ARCH = ::T.let(nil, ::T.untyped)
  IMPL = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sys::Platform
  def self.bsd?(); end

  def self.linux?(); end

  def self.mac?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class Sys::Uname
  def sysinfo(*arg); end

  def uname_c(*arg); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  SI_ARCHITECTURE = ::T.let(nil, ::T.untyped)
  SI_DHCP_CACHE = ::T.let(nil, ::T.untyped)
  SI_HOSTNAME = ::T.let(nil, ::T.untyped)
  SI_HW_PROVIDER = ::T.let(nil, ::T.untyped)
  SI_HW_SERIAL = ::T.let(nil, ::T.untyped)
  SI_ISALIST = ::T.let(nil, ::T.untyped)
  SI_MACHINE = ::T.let(nil, ::T.untyped)
  SI_PLATFORM = ::T.let(nil, ::T.untyped)
  SI_RELEASE = ::T.let(nil, ::T.untyped)
  SI_SRPC_DOMAIN = ::T.let(nil, ::T.untyped)
  SI_SYSNAME = ::T.let(nil, ::T.untyped)
  SI_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sys::Uname::Error
end

class Sys::Uname::Error
end

Sys::Uname::UnameStruct = Struct::UnameStruct

class Sys::Uname
  extend ::FFI::Library
  extend ::Memoist::InstanceMethods
  def self._unmemoized_machine(); end

  def self._unmemoized_nodename(); end

  def self._unmemoized_release(); end

  def self._unmemoized_sysname(); end

  def self._unmemoized_version(); end

  def self.architecture(); end

  def self.dhcp_cache(); end

  def self.hw_provider(); end

  def self.hw_serial(); end

  def self.isa_list(); end

  def self.machine(reload=T.unsafe(nil)); end

  def self.model(); end

  def self.nodename(reload=T.unsafe(nil)); end

  def self.platform(); end

  def self.release(reload=T.unsafe(nil)); end

  def self.srpc_domain(); end

  def self.sysname(reload=T.unsafe(nil)); end

  def self.uname(); end

  def self.version(reload=T.unsafe(nil)); end
end

module Sys
end

module TSort
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def finalizer_manager(); end

  def mode(); end

  def opts(); end

  def unlinked(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile::FinalizerManager
  def call(object_id); end

  def initialize(path); end

  def register(obj, file); end

  def unlinked(); end

  def unlinked=(unlinked); end
end

class Tempfile::FinalizerManager
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def deconstruct_keys(arg); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

class Timeout::Error
  def self.handle_timeout(message); end
end

module Timeout
  def self.ensure_timeout_thread_created(); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module URI
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def authority(); end

  def decoded_password(); end

  def decoded_user(); end

  def set_authority(user, password, host, port=T.unsafe(nil)); end
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
  TO_S = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil), &block); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SEG = ::T.let(nil, ::T.untyped)
  SEG_NC = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.const_missing(const); end

  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.open(name, *rest, **arg, &block); end

  def self.parser=(parser=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end
end

module Unicode
end

class Unicode::DisplayWidth
  def get_config(**kwargs); end

  def initialize(ambiguous: T.unsafe(nil), overwrite: T.unsafe(nil), emoji: T.unsafe(nil)); end

  def of(string, **kwargs); end
  AMBIGUOUS_MAP = ::T.let(nil, ::T.untyped)
  ASCII_BACKSPACE = ::T.let(nil, ::T.untyped)
  ASCII_NON_ZERO_REGEX = ::T.let(nil, ::T.untyped)
  ASCII_NON_ZERO_STRING = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEFAULT_AMBIGUOUS = ::T.let(nil, ::T.untyped)
  EMOJI_SEQUENCES_REGEX_MAPPING = ::T.let(nil, ::T.untyped)
  FIRST_4096 = ::T.let(nil, ::T.untyped)
  FIRST_AMBIGUOUS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  INITIAL_DEPTH = ::T.let(nil, ::T.untyped)
  NOT_COMMON_NARROW_REGEX = ::T.let(nil, ::T.untyped)
  REGEX_EMOJI_ALL_SEQUENCES = ::T.let(nil, ::T.untyped)
  REGEX_EMOJI_ALL_SEQUENCES_AND_VS16 = ::T.let(nil, ::T.untyped)
  REGEX_EMOJI_VS16 = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth::EmojiSupport
end

module Unicode::DisplayWidth::EmojiSupport
  def self._recommended(); end

  def self.recommended(); end
end

class Unicode::DisplayWidth
  def self.decompress_index(index, level); end

  def self.emoji_width(string, mode=T.unsafe(nil), ambiguous=T.unsafe(nil)); end

  def self.emoji_width_via_possible(string, emoji_set_regex, strict_eaw=T.unsafe(nil), ambiguous=T.unsafe(nil)); end

  def self.normalize_options(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), old_options=T.unsafe(nil), **options); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), old_options=T.unsafe(nil), **options); end

  def self.width_ascii(string); end

  def self.width_custom(string, overwrite); end
end

module Unicode::Emoji
  CANCEL_TAG = ::T.let(nil, ::T.untyped)
  CLDR_VERSION = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  EMOJI_CHAR = ::T.let(nil, ::T.untyped)
  EMOJI_COMPONENT = ::T.let(nil, ::T.untyped)
  EMOJI_KEYCAPS = ::T.let(nil, ::T.untyped)
  EMOJI_KEYCAP_SUFFIX = ::T.let(nil, ::T.untyped)
  EMOJI_MODIFIERS = ::T.let(nil, ::T.untyped)
  EMOJI_MODIFIER_BASES = ::T.let(nil, ::T.untyped)
  EMOJI_PRESENTATION = ::T.let(nil, ::T.untyped)
  EMOJI_TAG_BASE_FLAG = ::T.let(nil, ::T.untyped)
  EMOJI_VARIATION_SELECTOR = ::T.let(nil, ::T.untyped)
  EMOJI_VERSION = ::T.let(nil, ::T.untyped)
  EXTENDED_PICTOGRAPHIC = ::T.let(nil, ::T.untyped)
  EXTENDED_PICTOGRAPHIC_NO_EMOJI = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LIST_REMOVED_KEYS = ::T.let(nil, ::T.untyped)
  PROPERTY_NAMES = ::T.let(nil, ::T.untyped)
  RECOMMENDED_SUBDIVISION_FLAGS = ::T.let(nil, ::T.untyped)
  RECOMMENDED_ZWJ_SEQUENCES = ::T.let(nil, ::T.untyped)
  REGEX = ::T.let(nil, ::T.untyped)
  REGEX_BASIC = ::T.let(nil, ::T.untyped)
  REGEX_EMOJI_KEYCAP = ::T.let(nil, ::T.untyped)
  REGEX_INCLUDE_MQE = ::T.let(nil, ::T.untyped)
  REGEX_INCLUDE_MQE_UQE = ::T.let(nil, ::T.untyped)
  REGEX_INCLUDE_TEXT = ::T.let(nil, ::T.untyped)
  REGEX_PICTO = ::T.let(nil, ::T.untyped)
  REGEX_PICTO_NO_EMOJI = ::T.let(nil, ::T.untyped)
  REGEX_POSSIBLE = ::T.let(nil, ::T.untyped)
  REGEX_PROP_COMPONENT = ::T.let(nil, ::T.untyped)
  REGEX_PROP_EMOJI = ::T.let(nil, ::T.untyped)
  REGEX_PROP_MODIFIER = ::T.let(nil, ::T.untyped)
  REGEX_PROP_MODIFIER_BASE = ::T.let(nil, ::T.untyped)
  REGEX_PROP_PRESENTATION = ::T.let(nil, ::T.untyped)
  REGEX_TEXT = ::T.let(nil, ::T.untyped)
  REGEX_TEXT_PRESENTATION = ::T.let(nil, ::T.untyped)
  REGEX_VALID = ::T.let(nil, ::T.untyped)
  REGEX_VALID_INCLUDE_TEXT = ::T.let(nil, ::T.untyped)
  REGEX_WELL_FORMED = ::T.let(nil, ::T.untyped)
  REGEX_WELL_FORMED_INCLUDE_TEXT = ::T.let(nil, ::T.untyped)
  REGIONAL_INDICATORS = ::T.let(nil, ::T.untyped)
  SPEC_TAGS = ::T.let(nil, ::T.untyped)
  TEXT_PRESENTATION = ::T.let(nil, ::T.untyped)
  TEXT_VARIATION_SELECTOR = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VALID_REGION_FLAGS = ::T.let(nil, ::T.untyped)
  VALID_SUBDIVISIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VISUAL_COMPONENT = ::T.let(nil, ::T.untyped)
  ZWJ = ::T.let(nil, ::T.untyped)
end

module Unicode::Emoji
  def self.list(key=T.unsafe(nil), sub_key=T.unsafe(nil)); end

  def self.properties(char); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UnknownNodeError
end

class UnknownNodeError
end

class UnsupportedNodeError
end

class UnsupportedNodeError
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

class WEBrick::HTTPAuth::DigestAuth::OpaqueInfo
  def self.keyword_init?(); end
end

module WEBrick::HTTPAuth::ProxyAuthenticator
  ResponseInfoField = ::T.let(nil, ::T.untyped)
end

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end

  def xhr?(); end
  HOST_PATTERN = ::T.let(nil, ::T.untyped)
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def make_body_tempfile(); end

  def remove_body_tempfile(); end

  def upgrade(); end

  def upgrade!(protocol); end

  def upgrade=(upgrade); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServlet::CGIHandler
  CGIRunnerArray = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

class WEBrick::HTTPServlet::FileHandler
  def set_filesystem_encoding(str); end
end

class WEBrick::HTTPServlet::ProcHandler
  def do_PUT(request, response); end
end

module WEBrick::HTTPUtils
  HEADER_CLASSES = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPUtils::CookieHeader
  def join(separator=T.unsafe(nil)); end
end

class WEBrick::HTTPUtils::CookieHeader
end

class WEBrick::HTTPUtils::SplitHeader
  def join(separator=T.unsafe(nil)); end
end

class WEBrick::HTTPUtils::SplitHeader
end

module Warning
  extend ::Warning
end

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module YARD::CLI
end

class YARD::CLI::Command
  def common_options(opts); end

  def description(); end

  def load_script(file); end

  def parse_options(opts, args); end

  def unrecognized_option(err); end
end

class YARD::CLI::Command
  def self.run(*args); end
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::Yardoc
  def all_objects(); end

  def apis(); end

  def apis=(apis); end

  def assets(); end

  def assets=(assets); end

  def excluded(); end

  def excluded=(excluded); end

  def fail_on_warning(); end

  def fail_on_warning=(fail_on_warning); end

  def files(); end

  def files=(files); end

  def generate(); end

  def generate=(generate); end

  def has_markup(); end

  def has_markup=(has_markup); end

  def hidden_apis(); end

  def hidden_apis=(hidden_apis); end

  def hidden_tags(); end

  def hidden_tags=(hidden_tags); end

  def list(); end

  def list=(list); end

  def options(); end

  def run(*args); end

  def save_yardoc(); end

  def save_yardoc=(save_yardoc); end

  def statistics(); end

  def statistics=(statistics); end

  def use_cache(); end

  def use_cache=(use_cache); end

  def visibilities(); end

  def visibilities=(visibilities); end
end

class YARD::CLI::Yardoc
end

class YARD::CLI::YardocOptions
  def file(); end

  def file=(file); end

  def files(); end

  def files=(files); end

  def item(); end

  def item=(item); end

  def locale(); end

  def locale=(locale); end

  def objects(); end

  def objects=(objects); end

  def onefile(); end

  def onefile=(onefile); end

  def readme(); end

  def readme=(readme); end

  def title(); end

  def title=(title); end
end

class YARD::CLI::YardocOptions
end

class YARD::CLI::YardoptsCommand
  def options_file(); end

  def options_file=(options_file); end

  def parse_arguments(*args); end

  def use_document_file(); end

  def use_document_file=(use_document_file); end

  def use_yardopts_file(); end

  def use_yardopts_file=(use_yardopts_file); end

  def yardopts_options(opts); end
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YardoptsCommand
end

module YARD::CLI
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def initialize(namespace, name, *arg); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassObject
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::CodeObjectList
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ConstantObject
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::MethodObject
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

module YARD::CodeObjects::NamespaceMapper
  def clear_separators(); end

  def default_separator(value=T.unsafe(nil)); end

  def register_separator(sep, *valid_types); end

  def separators(); end

  def separators_for_type(type); end

  def separators_match(); end

  def types_for_separator(sep); end

  def unregister_separator_by_type(type); end
end

module YARD::CodeObjects::NamespaceMapper
  def self.default_separator(); end

  def self.default_separator=(default_separator); end

  def self.invalidate(); end

  def self.map(); end

  def self.map_match(); end

  def self.on_invalidate(&block); end

  def self.rev_map(); end
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end

  def mixins(*scopes); end
end

class YARD::CodeObjects::NamespaceObject
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def initialize(namespace, name, type=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::DocstringParser
  def create_directive(tag_name, tag_buf); end

  def create_ref_tag(tag_name, name, object_name); end

  def create_tag(tag_name, tag_buf=T.unsafe(nil)); end

  def directives(); end

  def directives=(directives); end

  def handler(); end

  def handler=(handler); end

  def initialize(library=T.unsafe(nil)); end

  def library(); end

  def library=(library); end

  def object(); end

  def object=(object); end

  def parse(content, object=T.unsafe(nil), handler=T.unsafe(nil)); end

  def parse_content(content); end

  def post_process(); end

  def raw_text(); end

  def raw_text=(raw_text); end

  def reference(); end

  def reference=(reference); end

  def state(); end

  def state=(state); end

  def tag_is_directive?(tag_name); end

  def tags(); end

  def tags=(tags); end

  def text(); end

  def text=(text); end

  def to_docstring(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  def self.after_parse(&block); end

  def self.after_parse_callbacks(); end
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

module YARD::Handlers
end

class YARD::Handlers::Base
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def abort!(); end

  def call_params(); end

  def caller_method(); end

  def ensure_loaded!(object, max_retries=T.unsafe(nil)); end

  def extra_state(); end

  def globals(); end

  def initialize(source_parser, stmt); end

  def namespace(); end

  def namespace=(v); end

  def owner(); end

  def owner=(v); end

  def parse_block(*arg); end

  def parser(); end

  def process(); end

  def push_state(opts=T.unsafe(nil)); end

  def register(*objects); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end

  def register_dynamic(object); end

  def register_ensure_loaded(object); end

  def register_file_info(object, file=T.unsafe(nil), line=T.unsafe(nil), comments=T.unsafe(nil)); end

  def register_group(object, group=T.unsafe(nil)); end

  def register_module_function(object); end

  def register_source(object, source=T.unsafe(nil), type=T.unsafe(nil)); end

  def register_transitive_tags(object); end

  def register_visibility(object, visibility=T.unsafe(nil)); end

  def scope(); end

  def scope=(v); end

  def statement(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::Handlers::Base
  def self.clear_subclasses(); end

  def self.handlers(); end

  def self.handles(*matches); end

  def self.handles?(statement); end

  def self.in_file(filename); end

  def self.inherited(subclass); end

  def self.matches_file?(filename); end

  def self.namespace_only(); end

  def self.namespace_only?(); end

  def self.process(&block); end
end

module YARD::Handlers::C
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
  ERROR_CLASS_NAMES = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::C
end

module YARD::Handlers::Common
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

module YARD::Handlers::Common
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::NamespaceMissingError
  def initialize(object); end

  def object(); end

  def object=(object); end
end

class YARD::Handlers::NamespaceMissingError
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

module YARD::Handlers::Ruby
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::AttributeHandler
end

class YARD::Handlers::Ruby::Base
  include ::YARD::Parser::Ruby
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ClassHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  def name(); end
end

class YARD::Handlers::Ruby::HandlesExtension
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MethodHandler
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
  def make_module_function(instance_method, namespace); end
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARD::CodeObjects
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

module YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
  def is_attribute_method?(node); end
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

module YARD::Handlers::Ruby
end

module YARD::Handlers
end

module YARD::I18n
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

module YARD::I18n
end

class YARD::Logger
  include ::YARD::Logger::Severity
  def <<(msg=T.unsafe(nil)); end

  def backtrace(exc, level_meth=T.unsafe(nil)); end

  def capture(msg, nontty_log=T.unsafe(nil)); end

  def clear_progress(); end

  def debug(message); end

  def enter_level(new_level=T.unsafe(nil)); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(pipe, *args); end

  def io(); end

  def io=(io); end

  def level(); end

  def level=(level); end

  def log(severity, message); end

  def print(msg=T.unsafe(nil)); end

  def progress(msg, nontty_log=T.unsafe(nil)); end

  def puts(msg=T.unsafe(nil)); end

  def show_backtraces(); end

  def show_backtraces=(show_backtraces); end

  def show_progress(); end

  def show_progress=(show_progress); end

  def unknown(message); end

  def warn(message); end

  def warn_no_continuations(); end

  def warned(); end

  def warned=(warned); end
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

module YARD::Logger::Severity
  DEBUG = ::T.let(nil, ::T.untyped)
  ERROR = ::T.let(nil, ::T.untyped)
  FATAL = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  SEVERITIES = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  WARN = ::T.let(nil, ::T.untyped)
end

module YARD::Logger::Severity
end

class YARD::Logger
  def self.create_log_method(name); end

  def self.instance(pipe=T.unsafe(nil)); end
end

class YARD::OpenStruct
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def dig(*keys); end

  def each_pair(&block); end

  def initialize(hash=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(name, *args); end

  def to_h(); end
end

class YARD::OpenStruct
end

class YARD::Options
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&blk); end

  def merge(opts); end

  def method_missing(meth, *args, &block); end

  def reset_defaults(); end

  def to_hash(); end

  def update(opts); end
end

class YARD::Options
  def self.default_attr(key, default); end
end

module YARD::Parser
end

class YARD::Parser::Base
  def enumerator(); end

  def initialize(source, filename); end

  def parse(); end

  def tokenize(); end
end

class YARD::Parser::Base
  def self.parse(source, filename=T.unsafe(nil)); end
end

module YARD::Parser::C
end

module YARD::Parser::C
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

class YARD::Parser::OrderedParser
end

class YARD::Parser::ParserSyntaxError
end

class YARD::Parser::ParserSyntaxError
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module YARD::Parser::Ruby
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Parser::UndocumentableError
end

class YARD::Parser::UndocumentableError
end

module YARD::Parser
end

module YARD::Rake
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Rake
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  extend ::Enumerable
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

module YARD::Serializers
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

module YARD::Serializers
end

module YARD::Server
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

module YARD::Server::Commands
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::YARD::Server::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::Commands
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

module YARD::Server::HTTPUtils
  DefaultMimeTypes = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  UNESCAPED = ::T.let(nil, ::T.untyped)
  UNESCAPED_FORM = ::T.let(nil, ::T.untyped)
  UNESCAPED_PCHAR = ::T.let(nil, ::T.untyped)
end

class YARD::Server::HTTPUtils::FormData
  def <<(str); end

  def [](*key); end

  def append_data(data); end

  def each_data(); end

  def filename(); end

  def filename=(filename); end

  def initialize(*args); end

  def list(); end

  def name(); end

  def name=(name); end

  def next_data(); end

  def next_data=(next_data); end

  def to_ary(); end
  EmptyHeader = ::T.let(nil, ::T.untyped)
  EmptyRawHeader = ::T.let(nil, ::T.untyped)
end

class YARD::Server::HTTPUtils::FormData
end

module YARD::Server::HTTPUtils
  def self._escape(str, regex); end

  def self._make_regex(str); end

  def self._make_regex!(str); end

  def self._unescape(str, regex); end

  def self.dequote(str); end

  def self.escape(str); end

  def self.escape8bit(str); end

  def self.escape_form(str); end

  def self.escape_path(str); end

  def self.load_mime_types(file); end

  def self.mime_type(filename, mime_tab); end

  def self.normalize_path(path); end

  def self.parse_form_data(io, boundary); end

  def self.parse_header(raw); end

  def self.parse_query(str); end

  def self.parse_qvalues(value); end

  def self.parse_range_header(ranges_specifier); end

  def self.quote(str); end

  def self.split_header_value(str); end

  def self.unescape(str); end

  def self.unescape_form(str); end
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

module YARD::Tags
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def inside_directive?(); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Directive
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def param_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_tag(text); end

  def yieldreturn_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::MethodDirective
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

class YARD::Tags::OverloadTag
  def docstring(); end

  def has_tag?(name); end

  def initialize(tag_name, text); end

  def is_a?(other); end

  def kind_of?(other); end

  def method_missing(*args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def object=(value); end

  def parameters(); end

  def signature(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end
end

class YARD::Tags::OverloadTag
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ParseDirective
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::Tag
  def explain_types(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def object(); end

  def object=(object); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def text(); end

  def text=(text); end

  def type(); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::Tag
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

class YARD::Tags::VisibilityDirective
end

class YARD::Tags::VisibilityDirective
end

module YARD::Tags
end

module YARD::Templates
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

module YARD::Templates::Helpers::Markup
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
  def [](n); end

  def initialize(length, exclusive); end

  def set_attrs(start, length, bits); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
  def add_html(tag, name, exclusive=T.unsafe(nil)); end

  def add_regexp_handling(pattern, name, exclusive=T.unsafe(nil)); end

  def add_word_pair(start, stop, name, exclusive=T.unsafe(nil)); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs, exclusive=T.unsafe(nil)); end

  def convert_attrs_matching_word_pairs(str, attrs, exclusive); end

  def convert_attrs_word_pair_map(str, attrs, exclusive); end

  def convert_html(str, attrs, exclusive=T.unsafe(nil)); end

  def convert_regexp_handlings(str, attrs, exclusive=T.unsafe(nil)); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def exclusive?(attr); end

  def exclusive_bitmap(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def accept_document(document); end

  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_regexp_handling(target); end

  def convert_string(string); end

  def each_attr_tag(attr_mask, reverse=T.unsafe(nil)); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end

  def tt_tag?(attr_mask, reverse=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def self.gen_relative_url(path, target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::MyStringScanner
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil), line=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Table
  def ==(other); end

  def accept(visitor); end

  def align(); end

  def align=(align); end

  def body(); end

  def body=(body); end

  def header(); end

  def header=(header); end

  def initialize(header, align, body); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Table
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_table(header, body, aligns); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_link_notation_regexp_handlings(); end

  def init_regexp_handlings(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
  URL_CHARACTERS_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil), rdoc_ref: T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil), rdoc_ref: T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_table(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_table(header, body, aligns); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
  DEFAULT_HEADINGS = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_table(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def self.to_toc(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def self.parse(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::Markup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

module YARD::Templates::Helpers
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(arg); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Templates::TemplateOptions
  def __globals(); end

  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def embed_mixins_match?(mixin); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def index(); end

  def index=(index); end

  def markup(); end

  def markup=(markup); end

  def markup_provider(); end

  def markup_provider=(markup_provider); end

  def no_highlight(); end

  def no_highlight=(value); end

  def object(); end

  def object=(object); end

  def owner(); end

  def owner=(owner); end

  def page_title(); end

  def page_title=(page_title); end

  def serialize(); end

  def serialize=(serialize); end

  def serializer(); end

  def serializer=(serializer); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Templates::TemplateOptions
end

module YARD::Templates
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module YARD
  def self.load_plugins(); end

  def self.parse(*args); end

  def self.parse_string(*args); end

  def self.ruby18?(); end

  def self.ruby19?(); end

  def self.ruby2?(); end

  def self.ruby31?(); end

  def self.ruby3?(); end

  def self.windows?(); end
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
